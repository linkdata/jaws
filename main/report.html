
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>core: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/linkdata/jaws/core/auth.go (100.0%)</option>
				
				<option value="file1">github.com/linkdata/jaws/core/bind.go (100.0%)</option>
				
				<option value="file2">github.com/linkdata/jaws/core/binding.go (100.0%)</option>
				
				<option value="file3">github.com/linkdata/jaws/core/bindinghook.go (100.0%)</option>
				
				<option value="file4">github.com/linkdata/jaws/core/clickhandler.go (100.0%)</option>
				
				<option value="file5">github.com/linkdata/jaws/core/defaultcookiename.go (100.0%)</option>
				
				<option value="file6">github.com/linkdata/jaws/core/element.go (100.0%)</option>
				
				<option value="file7">github.com/linkdata/jaws/core/errillegaltagtype.go (100.0%)</option>
				
				<option value="file8">github.com/linkdata/jaws/core/errnotcomparable.go (100.0%)</option>
				
				<option value="file9">github.com/linkdata/jaws/core/errnowebsocketrequest.go (100.0%)</option>
				
				<option value="file10">github.com/linkdata/jaws/core/errpendingcancelled.go (100.0%)</option>
				
				<option value="file11">github.com/linkdata/jaws/core/eventhandler.go (100.0%)</option>
				
				<option value="file12">github.com/linkdata/jaws/core/getter.go (100.0%)</option>
				
				<option value="file13">github.com/linkdata/jaws/core/htmlgetterfunc.go (100.0%)</option>
				
				<option value="file14">github.com/linkdata/jaws/core/jaws.go (100.0%)</option>
				
				<option value="file15">github.com/linkdata/jaws/core/js.go (100.0%)</option>
				
				<option value="file16">github.com/linkdata/jaws/core/makehtmlgetter.go (100.0%)</option>
				
				<option value="file17">github.com/linkdata/jaws/core/message.go (100.0%)</option>
				
				<option value="file18">github.com/linkdata/jaws/core/namedbool.go (100.0%)</option>
				
				<option value="file19">github.com/linkdata/jaws/core/namedboolarray.go (100.0%)</option>
				
				<option value="file20">github.com/linkdata/jaws/core/namedbooloption.go (100.0%)</option>
				
				<option value="file21">github.com/linkdata/jaws/core/parseparams.go (100.0%)</option>
				
				<option value="file22">github.com/linkdata/jaws/core/request.go (100.0%)</option>
				
				<option value="file23">github.com/linkdata/jaws/core/rwlocker.go (100.0%)</option>
				
				<option value="file24">github.com/linkdata/jaws/core/servehttp.go (100.0%)</option>
				
				<option value="file25">github.com/linkdata/jaws/core/session.go (100.0%)</option>
				
				<option value="file26">github.com/linkdata/jaws/core/sessioner.go (100.0%)</option>
				
				<option value="file27">github.com/linkdata/jaws/core/setter.go (100.0%)</option>
				
				<option value="file28">github.com/linkdata/jaws/core/setterfloat64.go (100.0%)</option>
				
				<option value="file29">github.com/linkdata/jaws/core/setup.go (100.0%)</option>
				
				<option value="file30">github.com/linkdata/jaws/core/stringgetterfunc.go (100.0%)</option>
				
				<option value="file31">github.com/linkdata/jaws/core/tag.go (100.0%)</option>
				
				<option value="file32">github.com/linkdata/jaws/core/testsupport.go (100.0%)</option>
				
				<option value="file33">github.com/linkdata/jaws/core/writehtml.go (100.0%)</option>
				
				<option value="file34">github.com/linkdata/jaws/core/ws.go (100.0%)</option>
				
				<option value="file35">github.com/linkdata/jaws/core/wsmsg.go (100.0%)</option>
				
				<option value="file36">github.com/linkdata/jaws/jaws.go (100.0%)</option>
				
				<option value="file37">github.com/linkdata/jaws/jawsboot/jawsboot.go (100.0%)</option>
				
				<option value="file38">github.com/linkdata/jaws/jawstest/testrequest.go (100.0%)</option>
				
				<option value="file39">github.com/linkdata/jaws/jawstree/node.go (100.0%)</option>
				
				<option value="file40">github.com/linkdata/jaws/jawstree/root.go (100.0%)</option>
				
				<option value="file41">github.com/linkdata/jaws/jawstree/setup.go (100.0%)</option>
				
				<option value="file42">github.com/linkdata/jaws/jawstree/tree.go (100.0%)</option>
				
				<option value="file43">github.com/linkdata/jaws/jid/jid.go (100.0%)</option>
				
				<option value="file44">github.com/linkdata/jaws/staticserve/handle.go (100.0%)</option>
				
				<option value="file45">github.com/linkdata/jaws/staticserve/newfs.go (100.0%)</option>
				
				<option value="file46">github.com/linkdata/jaws/staticserve/servehttp.go (100.0%)</option>
				
				<option value="file47">github.com/linkdata/jaws/staticserve/staticserve.go (100.0%)</option>
				
				<option value="file48">github.com/linkdata/jaws/staticserve/walkdir.go (100.0%)</option>
				
				<option value="file49">github.com/linkdata/jaws/templatereloader/templatereloader.go (100.0%)</option>
				
				<option value="file50">github.com/linkdata/jaws/ui/a.go (100.0%)</option>
				
				<option value="file51">github.com/linkdata/jaws/ui/button.go (100.0%)</option>
				
				<option value="file52">github.com/linkdata/jaws/ui/checkbox.go (100.0%)</option>
				
				<option value="file53">github.com/linkdata/jaws/ui/common.go (100.0%)</option>
				
				<option value="file54">github.com/linkdata/jaws/ui/container.go (100.0%)</option>
				
				<option value="file55">github.com/linkdata/jaws/ui/container_widgets.go (100.0%)</option>
				
				<option value="file56">github.com/linkdata/jaws/ui/date.go (100.0%)</option>
				
				<option value="file57">github.com/linkdata/jaws/ui/div.go (100.0%)</option>
				
				<option value="file58">github.com/linkdata/jaws/ui/errmissingtemplate.go (100.0%)</option>
				
				<option value="file59">github.com/linkdata/jaws/ui/handler.go (100.0%)</option>
				
				<option value="file60">github.com/linkdata/jaws/ui/html_widgets.go (100.0%)</option>
				
				<option value="file61">github.com/linkdata/jaws/ui/img.go (100.0%)</option>
				
				<option value="file62">github.com/linkdata/jaws/ui/input_widgets.go (100.0%)</option>
				
				<option value="file63">github.com/linkdata/jaws/ui/jsvar.go (100.0%)</option>
				
				<option value="file64">github.com/linkdata/jaws/ui/label.go (100.0%)</option>
				
				<option value="file65">github.com/linkdata/jaws/ui/li.go (100.0%)</option>
				
				<option value="file66">github.com/linkdata/jaws/ui/number.go (100.0%)</option>
				
				<option value="file67">github.com/linkdata/jaws/ui/option.go (100.0%)</option>
				
				<option value="file68">github.com/linkdata/jaws/ui/password.go (100.0%)</option>
				
				<option value="file69">github.com/linkdata/jaws/ui/radio.go (100.0%)</option>
				
				<option value="file70">github.com/linkdata/jaws/ui/range.go (100.0%)</option>
				
				<option value="file71">github.com/linkdata/jaws/ui/register.go (100.0%)</option>
				
				<option value="file72">github.com/linkdata/jaws/ui/requestwriter.go (100.0%)</option>
				
				<option value="file73">github.com/linkdata/jaws/ui/rwlocker.go (100.0%)</option>
				
				<option value="file74">github.com/linkdata/jaws/ui/select.go (100.0%)</option>
				
				<option value="file75">github.com/linkdata/jaws/ui/span.go (100.0%)</option>
				
				<option value="file76">github.com/linkdata/jaws/ui/tbody.go (100.0%)</option>
				
				<option value="file77">github.com/linkdata/jaws/ui/td.go (100.0%)</option>
				
				<option value="file78">github.com/linkdata/jaws/ui/template.go (100.0%)</option>
				
				<option value="file79">github.com/linkdata/jaws/ui/text.go (100.0%)</option>
				
				<option value="file80">github.com/linkdata/jaws/ui/textarea.go (100.0%)</option>
				
				<option value="file81">github.com/linkdata/jaws/ui/tr.go (100.0%)</option>
				
				<option value="file82">github.com/linkdata/jaws/what/what.go (100.0%)</option>
				
				<option value="file83">github.com/linkdata/jaws/what/what_string.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package core

type Auth interface {
        Data() map[string]any // returns authenticated user data, or nil
        Email() string        // returns authenticated user email, or an empty string
        IsAdmin() bool        // return true if admins are defined and current user is one, or if no admins are defined
}

type MakeAuthFn func(*Request) Auth

type DefaultAuth struct{}

func (DefaultAuth) Data() map[string]any <span class="cov8" title="1">{ return nil }</span>
func (DefaultAuth) Email() string        <span class="cov8" title="1">{ return "" }</span>
func (DefaultAuth) IsAdmin() bool        <span class="cov8" title="1">{ return true }</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package core

import (
        "sync"
)

// Bind returns a Binder[T] with the given sync.Locker (or RWLocker) and a pointer to the underlying value of type T.
//
// The pointer will be used as the UI tag.
func Bind[T comparable](l sync.Locker, p *T) Binder[T] <span class="cov8" title="1">{
        if rl, ok := l.(RWLocker); ok </span><span class="cov8" title="1">{
                return binding[T]{RWLocker: rl, ptr: p}
        }</span>
        <span class="cov8" title="1">return binding[T]{RWLocker: rwlocker{l}, ptr: p}</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package core

import (
        "fmt"
        "html/template"
)

type binding[T comparable] struct {
        RWLocker
        ptr *T
}

func (bind binding[T]) JawsBinderPrev() Binder[T] <span class="cov8" title="1">{
        return nil
}</span>

func (bind binding[T]) JawsGetLocked(*Element) T <span class="cov8" title="1">{
        return *bind.ptr
}</span>

func (bind binding[T]) JawsGet(elem *Element) (value T) <span class="cov8" title="1">{
        bind.RWLocker.RLock()
        value = bind.JawsGetLocked(elem)
        bind.RWLocker.RUnlock()
        return
}</span>

func (bind binding[T]) JawsSetLocked(elem *Element, value T) (err error) <span class="cov8" title="1">{
        if value != *bind.ptr </span><span class="cov8" title="1">{
                *bind.ptr = value
                return nil
        }</span>
        <span class="cov8" title="1">return ErrValueUnchanged</span>
}

func (bind binding[T]) JawsSet(elem *Element, value T) (err error) <span class="cov8" title="1">{
        bind.RWLocker.Lock()
        err = bind.JawsSetLocked(elem, value)
        bind.RWLocker.Unlock()
        return
}</span>

func (bind binding[T]) JawsGetTag(*Request) any <span class="cov8" title="1">{
        return bind.ptr
}</span>

// SetLocked returns a Binder[T] that will call fn instead of JawsSetLocked.
//
// The lock will be held at this point.
// Do not lock or unlock the Binder within fn. Do not call JawsSet.
//
// The bind argument to the function is the previous Binder in the chain,
// and you probably want to call it's JawsSetLocked first.
func (bind binding[T]) SetLocked(fn BindSetHook[T]) Binder[T] <span class="cov8" title="1">{
        return bindingHook[T]{
                Binder: bind,
                hook:   fn,
        }
}</span>

// GetLocked returns a Binder[T] that will call fn instead of JawsGetLocked.
//
// The lock will be held at this point, preferring RLock over Lock, if available.
// Do not lock or unlock the Binder within fn. Do not call JawsGet.
//
// The bind argument to the function is the previous Binder in the chain,
// and you probably want to call it's JawsGetLocked first.
func (bind binding[T]) GetLocked(fn BindGetHook[T]) Binder[T] <span class="cov8" title="1">{
        return bindingHook[T]{
                Binder: bind,
                hook:   fn,
        }
}</span>

// Success returns a Binder[T] that will call fn after the value has been set
// with no errors. No locks are held when the function is called.
// If the function returns an error, that will be returned from JawsSet.
//
// The function must have one of the following signatures:
//   - func()
//   - func() error
//   - func(*Element)
//   - func(*Element) error
func (bind binding[T]) Success(fn any) Binder[T] <span class="cov8" title="1">{
        return bindingHook[T]{
                Binder: bind,
                hook:   wrapSuccessHook(fn),
        }
}</span>

// Format returns a Getter[string] using fmt.Sprintf(f, JawsGet[T](elem))
func (bind binding[T]) Format(f string) (getter Getter[string]) <span class="cov8" title="1">{
        return StringGetterFunc(func(elem *Element) (s string) </span><span class="cov8" title="1">{ return fmt.Sprintf(f, bind.JawsGet(elem)) }</span>, bind)
}

// FormatHTML returns a HTMLGetter using fmt.Sprintf(f, JawsGet[T](elem)).
// Ensure that the generated string is valid HTML.
func (bind binding[T]) FormatHTML(f string) (getter HTMLGetter) <span class="cov8" title="1">{
        return HTMLGetterFunc(func(elem *Element) (tmpl template.HTML) </span><span class="cov8" title="1">{
                return template.HTML( /*#nosec G203*/ fmt.Sprintf(f, bind.JawsGet(elem)))
        }</span>, bind)
}

func wrapSuccessHook(fn any) (hook BindSuccessHook) <span class="cov8" title="1">{
        switch fn := fn.(type) </span>{
        case func():<span class="cov8" title="1">
                return func(*Element) error </span><span class="cov8" title="1">{
                        fn()
                        return nil
                }</span>
        case func() error:<span class="cov8" title="1">
                return func(*Element) error </span><span class="cov8" title="1">{
                        return fn()
                }</span>
        case func(*Element):<span class="cov8" title="1">
                return func(elem *Element) error </span><span class="cov8" title="1">{
                        fn(elem)
                        return nil
                }</span>
        case func(*Element) error:<span class="cov8" title="1">
                return fn</span>
        }
        <span class="cov8" title="1">panic("Binding[T].Success(): function has wrong signature")</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package core

import (
        "fmt"
        "html/template"
)

type bindingHook[T comparable] struct {
        Binder[T]
        hook any // one of: BindGetHook[T] BindSetHook[T] BindSuccessHook
}

func (bind bindingHook[T]) JawsBinderPrev() Binder[T] <span class="cov8" title="1">{
        return bind.Binder
}</span>

func (bind bindingHook[T]) JawsGetLocked(elem *Element) T <span class="cov8" title="1">{
        if fn, ok := bind.hook.(BindGetHook[T]); ok </span><span class="cov8" title="1">{
                return fn(bind.Binder, elem)
        }</span>
        <span class="cov8" title="1">return bind.Binder.JawsGetLocked(elem)</span>
}

func (bind bindingHook[T]) JawsGet(elem *Element) T <span class="cov8" title="1">{
        bind.RLock()
        defer bind.RUnlock()
        return bind.JawsGetLocked(elem)
}</span>

func (bind bindingHook[T]) JawsSetLocked(elem *Element, value T) error <span class="cov8" title="1">{
        if fn, ok := bind.hook.(BindSetHook[T]); ok </span><span class="cov8" title="1">{
                return fn(bind.Binder, elem, value)
        }</span>
        <span class="cov8" title="1">return bind.Binder.JawsSetLocked(elem, value)</span>
}

func (bind bindingHook[T]) jawsSetLocking(elem *Element, value T) (err error) <span class="cov8" title="1">{
        bind.Lock()
        defer bind.Unlock()
        return bind.JawsSetLocked(elem, value)
}</span>

func callSuccess[T comparable](binder Binder[T], elem *Element) (err error) <span class="cov8" title="1">{
        if prev := binder.JawsBinderPrev(); prev != nil </span><span class="cov8" title="1">{
                err = callSuccess(prev, elem)
        }</span>
        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                if bind, ok := binder.(bindingHook[T]); ok </span><span class="cov8" title="1">{
                        if fn, ok := bind.hook.(BindSuccessHook); ok </span><span class="cov8" title="1">{
                                return fn(elem)
                        }</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

func (bind bindingHook[T]) JawsSet(elem *Element, value T) (err error) <span class="cov8" title="1">{
        if err = bind.jawsSetLocking(elem, value); err == nil </span><span class="cov8" title="1">{
                err = callSuccess(bind, elem)
        }</span>
        <span class="cov8" title="1">return</span>
}

// SetLocked returns a Binder[T] that will call fn instead of JawsSetLocked.
//
// The lock will be held at this point.
// Do not lock or unlock the Binder within fn. Do not call JawsSet.
//
// The bind argument to the function is the previous Binder in the chain,
// and you probably want to call it's JawsSetLocked first.
func (bind bindingHook[T]) SetLocked(setFn BindSetHook[T]) Binder[T] <span class="cov8" title="1">{
        return bindingHook[T]{
                Binder: bind,
                hook:   setFn,
        }
}</span>

// GetLocked returns a Binder[T] that will call fn instead of JawsGetLocked.
//
// The lock will be held at this point, preferring RLock over Lock, if available.
// Do not lock or unlock the Binder within fn. Do not call JawsGet.
//
// The bind argument to the function is the previous Binder in the chain,
// and you probably want to call it's JawsGetLocked first.
func (bind bindingHook[T]) GetLocked(setFn BindGetHook[T]) Binder[T] <span class="cov8" title="1">{
        return bindingHook[T]{
                Binder: bind,
                hook:   setFn,
        }
}</span>

// Success returns a Binder[T] that will call fn after the value has been set
// with no errors. No locks are held when the function is called.
// If the function returns an error, that will be returned from JawsSet.
//
// The function must have one of the following signatures:
//   - func()
//   - func() error
//   - func(*Element)
//   - func(*Element) error
func (bind bindingHook[T]) Success(fn any) Binder[T] <span class="cov8" title="1">{
        return bindingHook[T]{
                Binder: bind,
                hook:   wrapSuccessHook(fn),
        }
}</span>

// Format returns a Getter[string] using fmt.Sprintf(f, JawsGet[T](elem))
func (bind bindingHook[T]) Format(f string) (getter Getter[string]) <span class="cov8" title="1">{
        return StringGetterFunc(func(elem *Element) (s string) </span><span class="cov8" title="1">{ return fmt.Sprintf(f, bind.JawsGet(elem)) }</span>, bind)
}

// FormatHTML returns a HTMLGetter using fmt.Sprintf(f, JawsGet[T](elem)).
// Ensure that the generated string is valid HTML.
func (bind bindingHook[T]) FormatHTML(f string) (getter HTMLGetter) <span class="cov8" title="1">{
        return HTMLGetterFunc(func(elem *Element) (tmpl template.HTML) </span><span class="cov8" title="1">{
                return template.HTML( /*#nosec G203*/ fmt.Sprintf(f, bind.JawsGet(elem)))
        }</span>, bind)
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package core

import "github.com/linkdata/jaws/what"

type ClickHandler interface {
        // JawsClick is called when an Element's HTML element or something within it
        // is clicked in the browser.
        //
        // The name parameter is taken from the first 'name' HTML attribute or HTML
        // 'button' textContent found when traversing the DOM. It may be empty.
        JawsClick(e *Element, name string) (err error)
}

type clickHandlerWrapper struct{ ClickHandler }

func (chw clickHandlerWrapper) JawsEvent(*Element, what.What, string) error <span class="cov8" title="1">{
        return ErrEventUnhandled
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package core

import (
        "os"
        "path/filepath"
        "strings"
)

// DefaultCookieName holds the default JaWS cookie name.
// It will be generated from the executable name, or "jaws" if that fails.
var DefaultCookieName string

func init() <span class="cov8" title="1">{
        exename, _ := os.Executable()
        DefaultCookieName = makeCookieName(exename)
}</span>

func makeCookieName(exename string) (cookie string) <span class="cov8" title="1">{
        cookie = "jaws"
        exename = filepath.Base(exename)
        exename = strings.TrimSuffix(exename, filepath.Ext(exename))
        var b []byte
        for _, ch := range exename </span><span class="cov8" title="1">{
                if ('a' &lt;= ch &amp;&amp; ch &lt;= 'z') || ('A' &lt;= ch &amp;&amp; ch &lt;= 'Z') || ('0' &lt;= ch &amp;&amp; ch &lt;= '9') </span><span class="cov8" title="1">{
                        b = append(b, byte(ch)) //#nosec G115
                }</span>
        }
        <span class="cov8" title="1">if len(b) &gt; 0 </span><span class="cov8" title="1">{
                cookie = string(b)
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package core

import (
        "bytes"
        "errors"
        "fmt"
        "html/template"
        "io"
        "strings"
        "sync/atomic"

        "github.com/linkdata/jaws/jid"
        "github.com/linkdata/jaws/what"
)

// An Element is an instance of a *Request, an UI object and a Jid.
type Element struct {
        *Request // (read-only) the Request the Element belongs to
        // internals
        ui       UI             // the UI object
        handlers []EventHandler // custom event handlers registered, if any
        jid      jid.Jid        // JaWS ID, unique to this Element within it's Request
        deleted  atomic.Bool    // true if deleteElement() has been called for this Element
}

func (e *Element) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("Element{%T, id=%q, Tags: %v}", e.Ui(), e.Jid(), e.Request.TagsOf(e))
}</span>

// AddHandler adds the given handlers to the Element.
func (e *Element) AddHandlers(h ...EventHandler) <span class="cov8" title="1">{
        if !e.deleted.Load() </span><span class="cov8" title="1">{
                e.handlers = append(e.handlers, h...)
        }</span>
}

// Tag adds the given tags to the Element.
func (e *Element) Tag(tags ...any) <span class="cov8" title="1">{
        if !e.deleted.Load() </span><span class="cov8" title="1">{
                e.Request.Tag(e, tags...)
        }</span>
}

// HasTag returns true if this Element has the given tag.
func (e *Element) HasTag(tag any) bool <span class="cov8" title="1">{
        return !e.deleted.Load() &amp;&amp; e.Request.HasTag(e, tag)
}</span>

// Jid returns the JaWS ID for this Element, unique within it's Request.
func (e *Element) Jid() jid.Jid <span class="cov8" title="1">{
        return e.jid
}</span>

// Ui returns the UI object.
func (e *Element) Ui() UI <span class="cov8" title="1">{
        return e.ui
}</span>

func (e *Element) maybeDirty(tag any, err error) (bool, error) <span class="cov8" title="1">{
        switch err </span>{
        case nil:<span class="cov8" title="1">
                e.Dirty(tag)
                return true, nil</span>
        case ErrValueUnchanged:<span class="cov8" title="1">
                return false, nil</span>
        }
        <span class="cov8" title="1">return false, err</span>
}

func (e *Element) renderDebug(w io.Writer) <span class="cov8" title="1">{
        var sb strings.Builder
        _, _ = fmt.Fprintf(&amp;sb, "&lt;!-- id=%q %T tags=[", e.Jid(), e.Ui())
        if e.mu.TryRLock() </span><span class="cov8" title="1">{
                defer e.mu.RUnlock()
                for i, tag := range e.tagsOfLocked(e) </span><span class="cov8" title="1">{
                        if i &gt; 0 </span><span class="cov8" title="1">{
                                sb.WriteString(", ")
                        }</span>
                        <span class="cov8" title="1">sb.WriteString(TagString(tag))</span>
                }
        } else<span class="cov8" title="1"> {
                sb.WriteString("n/a")
        }</span>
        <span class="cov8" title="1">sb.WriteByte(']')
        _, _ = w.Write([]byte(strings.ReplaceAll(sb.String(), "--&gt;", "==&gt;") + " --&gt;"))</span>
}

// JawsRender calls Ui().JawsRender() for this Element.
//
// Do not call this yourself unless it's from within another JawsRender implementation.
func (e *Element) JawsRender(w io.Writer, params []any) (err error) <span class="cov8" title="1">{
        if !e.deleted.Load() </span><span class="cov8" title="1">{
                if err = e.Ui().JawsRender(e, w, params); err == nil </span><span class="cov8" title="1">{
                        if e.Jaws.Debug </span><span class="cov8" title="1">{
                                e.renderDebug(w)
                        }</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

// JawsUpdate calls Ui().JawsUpdate() for this Element.
//
// Do not call this yourself unless it's from within another JawsUpdate implementation.
func (e *Element) JawsUpdate() <span class="cov8" title="1">{
        if !e.deleted.Load() </span><span class="cov8" title="1">{
                e.Ui().JawsUpdate(e)
        }</span>
}

func (e *Element) queue(wht what.What, data string) <span class="cov8" title="1">{
        if !e.deleted.Load() </span><span class="cov8" title="1">{
                e.Request.queue(WsMsg{
                        Data: data,
                        Jid:  e.jid,
                        What: wht,
                })
        }</span>
}

// SetAttr queues sending a new attribute value
// to the browser for the Element with the given JaWS ID in this Request.
//
// Call this only during JawsRender() or JawsUpdate() processing.
func (e *Element) SetAttr(attr, val string) <span class="cov8" title="1">{
        e.queue(what.SAttr, attr+"\n"+val)
}</span>

// RemoveAttr queues sending a request to remove an attribute
// to the browser for the Element with the given JaWS ID in this Request.
//
// Call this only during JawsRender() or JawsUpdate() processing.
func (e *Element) RemoveAttr(attr string) <span class="cov8" title="1">{
        e.queue(what.RAttr, attr)
}</span>

// SetClass a queues sending a class
// to the browser for the Element with the given JaWS ID in this Request.
//
// Call this only during JawsRender() or JawsUpdate() processing.
func (e *Element) SetClass(cls string) <span class="cov8" title="1">{
        e.queue(what.SClass, cls)
}</span>

// RemoveClass queues sending a request to remove a class
// to the browser for the Element with the given JaWS ID in this Request.
//
// Call this only during JawsRender() or JawsUpdate() processing.
func (e *Element) RemoveClass(cls string) <span class="cov8" title="1">{
        e.queue(what.RClass, cls)
}</span>

// SetInner queues sending a new inner HTML content
// to the browser for the Element.
//
// Call this only during JawsRender() or JawsUpdate() processing.
func (e *Element) SetInner(innerHTML template.HTML) <span class="cov8" title="1">{
        e.queue(what.Inner, string(innerHTML))
}</span>

// SetValue queues sending a new current input value in textual form
// to the browser for the Element with the given JaWS ID in this Request.
//
// Call this only during JawsRender() or JawsUpdate() processing.
func (e *Element) SetValue(val string) <span class="cov8" title="1">{
        e.queue(what.Value, val)
}</span>

// Replace replaces the elements entire HTML DOM node with new HTML code.
// If the HTML code doesn't seem to contain correct HTML ID, it panics.
//
// Call this only during JawsRender() or JawsUpdate() processing.
func (e *Element) Replace(htmlCode template.HTML) <span class="cov8" title="1">{
        if !e.deleted.Load() </span><span class="cov8" title="1">{
                var b []byte
                b = append(b, "id="...)
                b = e.Jid().AppendQuote(b)
                if !bytes.Contains([]byte(htmlCode), b) </span><span class="cov8" title="1">{
                        panic(errors.New("jaws: Element.Replace(): expected HTML " + string(b)))</span>
                }
                <span class="cov8" title="1">e.queue(what.Replace, string(htmlCode))</span>
        }
}

// Append appends a new HTML element as a child to the current one.
//
// Call this only during JawsRender() or JawsUpdate() processing.
func (e *Element) Append(htmlCode template.HTML) <span class="cov8" title="1">{
        e.queue(what.Append, string(htmlCode))
}</span>

// Order reorders the HTML elements.
//
// Call this only during JawsRender() or JawsUpdate() processing.
func (e *Element) Order(jidList []jid.Jid) <span class="cov8" title="1">{
        if !e.deleted.Load() &amp;&amp; len(jidList) &gt; 0 </span><span class="cov8" title="1">{
                var b []byte
                for i, jid := range jidList </span><span class="cov8" title="1">{
                        if i &gt; 0 </span><span class="cov8" title="1">{
                                b = append(b, ' ')
                        }</span>
                        <span class="cov8" title="1">b = jid.Append(b)</span>
                }
                <span class="cov8" title="1">e.queue(what.Order, string(b))</span>
        }
}

// Remove requests that the HTML child with the given HTML ID of this Element
// is removed from the Request and it's HTML element from the browser.
//
// Call this only during JawsRender() or JawsUpdate() processing.
func (e *Element) Remove(htmlId string) <span class="cov8" title="1">{
        e.queue(what.Remove, htmlId)
}</span>

// ApplyParams parses the parameters passed to UI() when creating a new Element,
// adding UI tags, adding any additional event handlers found.
//
// Returns the list of HTML attributes found, if any.
func (e *Element) ApplyParams(params []any) (retv []template.HTMLAttr) <span class="cov8" title="1">{
        tags, handlers, attrs := ParseParams(params)
        if !e.deleted.Load() </span><span class="cov8" title="1">{
                e.handlers = append(e.handlers, handlers...)
                e.Tag(tags...)
                for _, s := range attrs </span><span class="cov8" title="1">{
                        attr := template.HTMLAttr(s) // #nosec G203
                        retv = append(retv, attr)
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// ApplyGetter examines getter, and if it's not nil, either adds it
// as a Tag, or, if it is a TagGetter, adds the result of that as a Tag.
//
// If getter is a ClickHandler or an EventHandler, it's added to the
// list of handlers for the Element.
//
// Finally, if getter is an InitHandler, it's JawsInit()
// function is called.
//
// Returns the Tag(s) added, or nil if getter was nil, along with
// any error returned from JawsInit() if it was called.
func (e *Element) ApplyGetter(getter any) (tag any, err error) <span class="cov8" title="1">{
        if getter != nil </span><span class="cov8" title="1">{
                tag = getter
                if tagger, ok := getter.(TagGetter); ok </span><span class="cov8" title="1">{
                        tag = tagger.JawsGetTag(e.Request)
                }</span>
                <span class="cov8" title="1">if eh, ok := getter.(EventHandler); ok </span><span class="cov8" title="1">{
                        e.handlers = append(e.handlers, eh)
                }</span> else<span class="cov8" title="1"> if ch, ok := getter.(ClickHandler); ok </span><span class="cov8" title="1">{
                        e.handlers = append(e.handlers, clickHandlerWrapper{ch})
                }</span>
                <span class="cov8" title="1">e.Tag(tag)
                if initer, ok := getter.(InitHandler); ok </span><span class="cov8" title="1">{
                        err = initer.JawsInit(e)
                }</span>
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package core

import "fmt"

// ErrIllegalTagType is returned when a UI tag type is disallowed
var ErrIllegalTagType errIllegalTagType

type errIllegalTagType struct {
        tag any
}

func (e errIllegalTagType) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("illegal tag type %T", e.tag)
}</span>

func (errIllegalTagType) Is(other error) bool <span class="cov8" title="1">{
        return other == ErrIllegalTagType
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package core

import (
        "reflect"
)

// ErrNotComparable is returned when a UI object or tag is not comparable.
var ErrNotComparable errNotComparable

type errNotComparable struct {
        t reflect.Type
}

func (e errNotComparable) Error() (s string) <span class="cov8" title="1">{
        if e.t != nil </span><span class="cov8" title="1">{
                s = e.t.String() + " is "
        }</span>
        <span class="cov8" title="1">return s + "not comparable"</span>
}

func (errNotComparable) Is(target error) bool <span class="cov8" title="1">{
        return target == ErrNotComparable
}</span>

func newErrNotComparable(x any) error <span class="cov8" title="1">{
        if t := reflect.TypeOf(x); t != nil &amp;&amp; !t.Comparable() </span><span class="cov8" title="1">{
                return errNotComparable{t: t}
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package core

import (
        "fmt"
        "net/netip"
)

// ErrNoWebSocketRequest is returned when the WebSocket callback was not received
// within the timeout period. Most common reason is that client is not using
// Javascript.
var ErrNoWebSocketRequest errNoWebSocketRequest

type errNoWebSocketRequest struct {
        netip.Addr
}

func (e errNoWebSocketRequest) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("no WebSocket request received from %v", e.Addr)
}</span>

func (e errNoWebSocketRequest) Is(target error) bool <span class="cov8" title="1">{
        return target == ErrNoWebSocketRequest
}</span>

func newErrNoWebSocketRequest(rq *Request) error <span class="cov8" title="1">{
        return errNoWebSocketRequest{Addr: rq.remoteIP}
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package core

import (
        "fmt"
)

// ErrPendingCancelled indicates a pending Request was cancelled. Use Unwrap() to see the underlying cause.
var ErrPendingCancelled errPendingCancelled

type errPendingCancelled struct {
        JawsKey uint64
        Cause   error
        Initial string
}

func (e errPendingCancelled) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("Request&lt;%s&gt;:%s %v", JawsKeyString(e.JawsKey), e.Initial, e.Cause)
}</span>

func (e errPendingCancelled) Is(target error) (yes bool) <span class="cov8" title="1">{
        return target == ErrPendingCancelled
}</span>

func (e errPendingCancelled) Unwrap() error <span class="cov8" title="1">{
        return e.Cause
}</span>

func newErrPendingCancelledLocked(rq *Request, cause error) (err error) <span class="cov8" title="1">{
        var initial string
        if rq.initial != nil </span><span class="cov8" title="1">{
                initial = fmt.Sprintf(" %s %q:", rq.initial.Method, rq.initial.RequestURI)
        }</span>
        <span class="cov8" title="1">return errPendingCancelled{
                JawsKey: rq.JawsKey,
                Cause:   cause,
                Initial: initial,
        }</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package core

import (
        "fmt"
        "reflect"

        "github.com/linkdata/jaws/what"
)

// ErrEventHandlerPanic is returned when an event handler panics.
var ErrEventHandlerPanic errEventHandlerPanic

type errEventHandlerPanic struct {
        Type  reflect.Type
        Value any
}

func (e errEventHandlerPanic) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("jaws: %v panic: %v", e.Type, e.Value)
}</span>

func (errEventHandlerPanic) Is(target error) bool <span class="cov8" title="1">{
        return target == ErrEventHandlerPanic
}</span>

func (e errEventHandlerPanic) Unwrap() error <span class="cov8" title="1">{
        if err, ok := e.Value.(error); ok </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

type EventHandler interface {
        JawsEvent(e *Element, wht what.What, val string) (err error)
}

type errEventUnhandled struct{}

func (errEventUnhandled) Error() string <span class="cov8" title="1">{
        return "event unhandled"
}</span>

// ErrEventUnhandled returned by JawsEvent() or JawsClick() causes the next
// available handler to be invoked.
var ErrEventUnhandled = errEventUnhandled{}

// EventFn is the signature of a event handling function to be called when JaWS receives
// an event message from the Javascript via the WebSocket connection.
type EventFn = func(e *Element, wht what.What, val string) (err error)

type eventFnWrapper struct{ EventFn }

func (ehf eventFnWrapper) JawsEvent(e *Element, w what.What, v string) (err error) <span class="cov8" title="1">{
        return ehf.EventFn(e, w, v)
}</span>

var _ EventFn = eventFnWrapper{}.JawsEvent // statically ensure JawsEvent and EventFn are compatible

func callEventHandler(obj any, e *Element, wht what.What, val string) (err error) <span class="cov8" title="1">{
        if wht == what.Click </span><span class="cov8" title="1">{
                if h, ok := obj.(ClickHandler); ok </span><span class="cov8" title="1">{
                        if err = h.JawsClick(e, val); err != ErrEventUnhandled </span><span class="cov8" title="1">{
                                return
                        }</span>
                }
        }
        <span class="cov8" title="1">if h, ok := obj.(EventHandler); ok </span><span class="cov8" title="1">{
                return h.JawsEvent(e, wht, val)
        }</span>
        <span class="cov8" title="1">return ErrEventUnhandled</span>
}

func callEventHandlers(ui any, e *Element, wht what.What, val string) (err error) <span class="cov8" title="1">{
        if err = callEventHandler(ui, e, wht, val); err == ErrEventUnhandled </span><span class="cov8" title="1">{
                for _, h := range e.handlers </span><span class="cov8" title="1">{
                        if err = callEventHandler(h, e, wht, val); err != ErrEventUnhandled </span><span class="cov8" title="1">{
                                return
                        }</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

// CallEventHandlers calls the event handlers for the given Element.
// Recovers from panics in user-provided handlers, returning them as errors.
func CallEventHandlers(ui any, e *Element, wht what.What, val string) (err error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if x := recover(); x != nil </span><span class="cov8" title="1">{
                        err = errEventHandlerPanic{
                                Type:  reflect.TypeOf(ui),
                                Value: x,
                        }
                }</span>
        }()
        <span class="cov8" title="1">return callEventHandlers(ui, e, wht, val)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package core

import (
        "errors"
        "fmt"
)

var ErrValueNotSettable = errors.New("value not settable")

type Getter[T comparable] interface {
        JawsGet(elem *Element) (value T)
}

type getterStatic[T comparable] struct {
        v T
}

func (getterStatic[T]) JawsSet(*Element, T) error <span class="cov8" title="1">{
        return ErrValueNotSettable
}</span>

func (s getterStatic[T]) JawsGet(*Element) T <span class="cov8" title="1">{
        return s.v
}</span>

func (s getterStatic[T]) JawsGetTag(*Request) any <span class="cov8" title="1">{
        return nil
}</span>

func makeStaticGetter[T comparable](v T) Getter[T] <span class="cov8" title="1">{
        return getterStatic[T]{v}
}</span>

func MakeGetter[T comparable](v any) Getter[T] <span class="cov8" title="1">{
        switch v := v.(type) </span>{
        case Getter[T]:<span class="cov8" title="1">
                return v</span>
        case T:<span class="cov8" title="1">
                return makeStaticGetter(v)</span>
        }
        <span class="cov8" title="1">var blank T
        panic(fmt.Errorf("expected jaws.Getter[%T] or %T not %T", blank, blank, v))</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package core

import "html/template"

type htmlGetterFunc struct {
        fn   func(*Element) template.HTML
        tags []any
}

var _ TagGetter = &amp;htmlGetterFunc{}

func (g *htmlGetterFunc) JawsGetHTML(e *Element) template.HTML <span class="cov8" title="1">{
        return g.fn(e)
}</span>

func (g *htmlGetterFunc) JawsGetTag(e *Request) any <span class="cov8" title="1">{
        return g.tags
}</span>

// HTMLGetterFunc wraps a function and returns a HTMLGetter.
func HTMLGetterFunc(fn func(elem *Element) (tmpl template.HTML), tags ...any) HTMLGetter <span class="cov8" title="1">{
        return &amp;htmlGetterFunc{fn: fn, tags: tags}
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">// package core provides a mechanism to create dynamic
// webpages using Javascript and WebSockets.
//
// It integrates well with Go's html/template package,
// but can be used without it. It can be used with any
// router that supports the standard ServeHTTP interface.
package core

import (
        "bufio"
        "context"
        "crypto/rand"
        "encoding/binary"
        "errors"
        "fmt"
        "html/template"
        "io"
        "net"
        "net/http"
        "net/netip"
        "net/textproto"
        "net/url"
        "slices"
        "sort"
        "strconv"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/linkdata/deadlock"
        "github.com/linkdata/jaws/jid"
        "github.com/linkdata/jaws/staticserve"
        "github.com/linkdata/jaws/what"
)

const (
        DefaultUpdateInterval = time.Millisecond * 100 // Default browser update interval
)

// Jid is the identifier type used for HTML elements managed by JaWS.
//
// It is provided as a convenience alias to the value defined in the jid
// subpackage so applications do not have to import that package directly
// when working with element IDs.
type Jid = jid.Jid // convenience alias

// Jaws holds the server-side state and configuration for a JaWS instance.
//
// A single Jaws value coordinates template lookup, session handling and the
// request lifecycle that keeps the browser and backend synchronized via
// WebSockets. The zero value is not ready for use; construct instances with
// New to ensure the helper goroutines and static assets are prepared.
type Jaws struct {
        CookieName   string          // Name for session cookies, defaults to "jaws"
        Logger       Logger          // Optional logger to use
        Debug        bool            // Set to true to enable debug info in generated HTML code
        MakeAuth     MakeAuthFn      // Optional function to create With.Auth for Templates
        BaseContext  context.Context // Non-nil base context for Requests, set to context.Background() in New()
        bcastCh      chan Message
        subCh        chan subscription
        unsubCh      chan chan Message
        updateTicker *time.Ticker
        reqPool      sync.Pool
        serveJS      *staticserve.StaticServe
        serveCSS     *staticserve.StaticServe
        mu           deadlock.RWMutex // protects following
        headPrefix   string
        faviconURL   string
        tmplookers   []TemplateLookuper
        kg           *bufio.Reader
        closeCh      chan struct{} // closed when Close() has been called
        requests     map[uint64]*Request
        sessions     map[uint64]*Session
        dirty        map[any]int
        dirtOrder    int
}

// New allocates a JaWS instance with the default configuration.
//
// The returned Jaws value is ready for use: static assets are embedded,
// internal goroutines are configured and the request pool is primed. Call
// Close when the instance is no longer needed to free associated resources.
func New() (jw *Jaws, err error) <span class="cov8" title="1">{
        var serveJS, serveCSS *staticserve.StaticServe
        if serveJS, err = staticserve.New("/jaws/.jaws.js", JavascriptText); err == nil </span><span class="cov8" title="1">{
                if serveCSS, err = staticserve.New("/jaws/.jaws.css", JawsCSS); err == nil </span><span class="cov8" title="1">{
                        tmp := &amp;Jaws{
                                CookieName:   DefaultCookieName,
                                BaseContext:  context.Background(),
                                serveJS:      serveJS,
                                serveCSS:     serveCSS,
                                bcastCh:      make(chan Message, 1),
                                subCh:        make(chan subscription, 1),
                                unsubCh:      make(chan chan Message, 1),
                                updateTicker: time.NewTicker(DefaultUpdateInterval),
                                kg:           bufio.NewReader(rand.Reader),
                                requests:     make(map[uint64]*Request),
                                sessions:     make(map[uint64]*Session),
                                dirty:        make(map[any]int),
                                closeCh:      make(chan struct{}),
                        }
                        if err = tmp.GenerateHeadHTML(); err == nil </span><span class="cov8" title="1">{
                                jw = tmp
                                jw.reqPool.New = func() any </span><span class="cov8" title="1">{
                                        return (&amp;Request{
                                                Jaws:   jw,
                                                tagMap: make(map[any][]*Element),
                                        }).clearLocked()
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return</span>
}

// Close frees resources associated with the JaWS object, and
// closes the completion channel if the JaWS was created with New().
// Once the completion channel is closed, broadcasts and sends may be discarded.
// Subsequent calls to Close() have no effect.
func (jw *Jaws) Close() <span class="cov8" title="1">{
        jw.mu.Lock()
        select </span>{
        case &lt;-jw.closeCh:<span class="cov8" title="1"></span>
                // already closed
        default:<span class="cov8" title="1">
                close(jw.closeCh)</span>
        }
        <span class="cov8" title="1">jw.updateTicker.Stop()
        jw.mu.Unlock()</span>
}

// Done returns the channel that is closed when Close has been called.
func (jw *Jaws) Done() &lt;-chan struct{} <span class="cov8" title="1">{
        return jw.closeCh
}</span>

// AddTemplateLookuper adds an object that can resolve
// strings to *template.Template.
func (jw *Jaws) AddTemplateLookuper(tl TemplateLookuper) (err error) <span class="cov8" title="1">{
        if tl != nil </span><span class="cov8" title="1">{
                if err = newErrNotComparable(tl); err == nil </span><span class="cov8" title="1">{
                        jw.mu.Lock()
                        if !slices.Contains(jw.tmplookers, tl) </span><span class="cov8" title="1">{
                                jw.tmplookers = append(jw.tmplookers, tl)
                        }</span>
                        <span class="cov8" title="1">jw.mu.Unlock()</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

// RemoveTemplateLookuper removes the given object from
// the list of TemplateLookupers.
func (jw *Jaws) RemoveTemplateLookuper(tl TemplateLookuper) (err error) <span class="cov8" title="1">{
        if tl != nil </span><span class="cov8" title="1">{
                if err = newErrNotComparable(tl); err == nil </span><span class="cov8" title="1">{
                        jw.mu.Lock()
                        jw.tmplookers = slices.DeleteFunc(jw.tmplookers, func(x TemplateLookuper) bool </span><span class="cov8" title="1">{ return x == tl }</span>)
                        <span class="cov8" title="1">jw.mu.Unlock()</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

// LookupTemplate queries the known TemplateLookupers in the order
// they were added and returns the first found.
func (jw *Jaws) LookupTemplate(name string) *template.Template <span class="cov8" title="1">{
        jw.mu.RLock()
        defer jw.mu.RUnlock()
        for _, tl := range jw.tmplookers </span><span class="cov8" title="1">{
                if t := tl.Lookup(name); t != nil </span><span class="cov8" title="1">{
                        return t
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// RequestCount returns the number of Requests.
//
// The count includes all Requests, including those being rendered,
// those waiting for the WebSocket callback and those active.
func (jw *Jaws) RequestCount() (n int) <span class="cov8" title="1">{
        jw.mu.RLock()
        n = len(jw.requests)
        jw.mu.RUnlock()
        return
}</span>

// Log sends an error to the Logger set in the Jaws.
// Has no effect if the err is nil or the Logger is nil.
// Returns err.
func (jw *Jaws) Log(err error) error <span class="cov8" title="1">{
        if err != nil &amp;&amp; jw != nil &amp;&amp; jw.Logger != nil </span><span class="cov8" title="1">{
                jw.Logger.Error("jaws", "err", err)
        }</span>
        <span class="cov8" title="1">return err</span>
}

// MustLog sends an error to the Logger set in the Jaws or
// panics with the given error if no Logger is set.
// Has no effect if the err is nil.
func (jw *Jaws) MustLog(err error) <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                if jw != nil &amp;&amp; jw.Logger != nil </span><span class="cov8" title="1">{
                        jw.Logger.Error("jaws", "err", err)
                }</span> else<span class="cov8" title="1"> {
                        panic(err)</span>
                }
        }
}

// NextID returns an int64 unique within lifetime of the program.
func NextID() int64 <span class="cov8" title="1">{
        return atomic.AddInt64((*int64)(&amp;NextJid), 1)
}</span>

// AppendID appends the result of NextID() in text form to the given slice.
func AppendID(b []byte) []byte <span class="cov8" title="1">{
        return strconv.AppendInt(b, NextID(), 32)
}</span>

// MakeID returns a string in the form 'jaws.X' where X is a unique string within lifetime of the program.
func MakeID() string <span class="cov8" title="1">{
        return string(AppendID([]byte("jaws.")))
}</span>

// NewRequest returns a new pending JaWS request.
//
// Call this as soon as you start processing a HTML request, and store the
// returned Request pointer so it can be used while constructing the HTML
// response in order to register the JaWS id's you use in the response, and
// use it's Key attribute when sending the Javascript portion of the reply.
//
// Automatic timeout handling is performed by ServeWithTimeout. The default
// Serve() helper uses a 10-second timeout.
func (jw *Jaws) NewRequest(hr *http.Request) (rq *Request) <span class="cov8" title="1">{
        jw.mu.Lock()
        defer jw.mu.Unlock()
        for rq == nil </span><span class="cov8" title="1">{
                jawsKey := jw.nonZeroRandomLocked()
                if _, ok := jw.requests[jawsKey]; !ok </span><span class="cov8" title="1">{
                        rq = jw.getRequestLocked(jawsKey, hr)
                        jw.requests[jawsKey] = rq
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func (jw *Jaws) nonZeroRandomLocked() (val uint64) <span class="cov8" title="1">{
        random := make([]byte, 8)
        for val == 0 </span><span class="cov8" title="1">{
                if _, err := io.ReadFull(jw.kg, random); err != nil </span><span class="cov8" title="1">{
                        panic(err)</span>
                }
                <span class="cov8" title="1">val = binary.LittleEndian.Uint64(random)</span>
        }
        <span class="cov8" title="1">return</span>
}

// UseRequest extracts the JaWS request with the given key from the request
// map if it exists and the HTTP request remote IP matches.
//
// Call it when receiving the WebSocket connection on '/jaws/:key' to get the
// associated Request, and then call it's ServeHTTP method to process the
// WebSocket messages.
//
// Returns nil if the key was not found or the IP doesn't match, in which
// case you should return a HTTP "404 Not Found" status.
func (jw *Jaws) UseRequest(jawsKey uint64, hr *http.Request) (rq *Request) <span class="cov8" title="1">{
        if jawsKey != 0 </span><span class="cov8" title="1">{
                var err error
                jw.mu.Lock()
                if waitingRq, ok := jw.requests[jawsKey]; ok </span><span class="cov8" title="1">{
                        if err = waitingRq.claim(hr); err == nil </span><span class="cov8" title="1">{
                                rq = waitingRq
                        }</span>
                }
                <span class="cov8" title="1">jw.mu.Unlock()
                _ = jw.Log(err)</span>
        }
        <span class="cov8" title="1">return</span>
}

// SessionCount returns the number of active sessions.
func (jw *Jaws) SessionCount() (n int) <span class="cov8" title="1">{
        jw.mu.RLock()
        n = len(jw.sessions)
        jw.mu.RUnlock()
        return
}</span>

// Sessions returns a list of all active sessions, which may be nil.
func (jw *Jaws) Sessions() (sl []*Session) <span class="cov8" title="1">{
        jw.mu.RLock()
        if n := len(jw.sessions); n &gt; 0 </span><span class="cov8" title="1">{
                sl = make([]*Session, 0, n)
                for _, sess := range jw.sessions </span><span class="cov8" title="1">{
                        sl = append(sl, sess)
                }</span>
        }
        <span class="cov8" title="1">jw.mu.RUnlock()
        return</span>
}

func (jw *Jaws) getSessionLocked(sessIds []uint64, remoteIP netip.Addr) *Session <span class="cov8" title="1">{
        for _, sessId := range sessIds </span><span class="cov8" title="1">{
                if sess, ok := jw.sessions[sessId]; ok &amp;&amp; equalIP(remoteIP, sess.remoteIP) </span><span class="cov8" title="1">{
                        if !sess.isDead() </span><span class="cov8" title="1">{
                                return sess
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func cutString(s string, sep byte) (before, after string) <span class="cov8" title="1">{
        if i := strings.IndexByte(s, sep); i &gt;= 0 </span><span class="cov8" title="1">{
                return s[:i], s[i+1:]
        }</span>
        <span class="cov8" title="1">return s, ""</span>
}

func getCookieSessionsIds(h http.Header, wanted string) (cookies []uint64) <span class="cov8" title="1">{
        for _, line := range h["Cookie"] </span><span class="cov8" title="1">{
                if strings.Contains(line, wanted) </span><span class="cov8" title="1">{
                        var part string
                        line = textproto.TrimString(line)
                        for len(line) &gt; 0 </span><span class="cov8" title="1">{
                                part, line = cutString(line, ';')
                                if part = textproto.TrimString(part); part != "" </span><span class="cov8" title="1">{
                                        name, val := cutString(part, '=')
                                        name = textproto.TrimString(name)
                                        if name == wanted </span><span class="cov8" title="1">{
                                                if len(val) &gt; 1 &amp;&amp; val[0] == '"' &amp;&amp; val[len(val)-1] == '"' </span><span class="cov8" title="1">{
                                                        val = val[1 : len(val)-1]
                                                }</span>
                                                <span class="cov8" title="1">if sessId := JawsKeyValue(val); sessId != 0 </span><span class="cov8" title="1">{
                                                        cookies = append(cookies, sessId)
                                                }</span>
                                        }
                                }
                        }
                }
        }
        <span class="cov8" title="1">return</span>
}

// GetSession returns the Session associated with the given *http.Request, or nil.
func (jw *Jaws) GetSession(hr *http.Request) (sess *Session) <span class="cov8" title="1">{
        if hr != nil </span><span class="cov8" title="1">{
                if sessIds := getCookieSessionsIds(hr.Header, jw.CookieName); len(sessIds) &gt; 0 </span><span class="cov8" title="1">{
                        remoteIP := parseIP(hr.RemoteAddr)
                        jw.mu.RLock()
                        sess = jw.getSessionLocked(sessIds, remoteIP)
                        jw.mu.RUnlock()
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// NewSession creates a new Session.
//
// Any pre-existing Session will be cleared and closed.
// This may call Session.Close() on an existing session and therefore requires
// the JaWS processing loop (`Serve()` or `ServeWithTimeout()`) to be running.
//
// Subsequent Requests created with `NewRequest()` that have the cookie set and
// originates from the same IP will be able to access the Session.
func (jw *Jaws) NewSession(w http.ResponseWriter, hr *http.Request) (sess *Session) <span class="cov8" title="1">{
        if hr != nil </span><span class="cov8" title="1">{
                if oldSess := jw.GetSession(hr); oldSess != nil </span><span class="cov8" title="1">{
                        oldSess.Clear()
                        oldSess.Close()
                }</span>
                <span class="cov8" title="1">sess = jw.newSession(w, hr)</span>
        }
        <span class="cov8" title="1">return</span>
}

func (jw *Jaws) newSession(w http.ResponseWriter, hr *http.Request) (sess *Session) <span class="cov8" title="1">{
        secure := requestIsSecure(hr)
        jw.mu.Lock()
        defer jw.mu.Unlock()
        for sess == nil </span><span class="cov8" title="1">{
                sessionID := jw.nonZeroRandomLocked()
                if _, ok := jw.sessions[sessionID]; !ok </span><span class="cov8" title="1">{
                        sess = newSession(jw, sessionID, parseIP(hr.RemoteAddr), secure)
                        jw.sessions[sessionID] = sess
                        if w != nil </span><span class="cov8" title="1">{
                                http.SetCookie(w, &amp;sess.cookie)
                        }</span>
                        <span class="cov8" title="1">hr.AddCookie(&amp;sess.cookie)</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

func (jw *Jaws) deleteSession(sessionID uint64) <span class="cov8" title="1">{
        jw.mu.Lock()
        delete(jw.sessions, sessionID)
        jw.mu.Unlock()
}</span>

func (jw *Jaws) FaviconURL() (s string) <span class="cov8" title="1">{
        jw.mu.RLock()
        s = jw.faviconURL
        jw.mu.RUnlock()
        return
}</span>

// GenerateHeadHTML (re-)generates the HTML code that goes in the HEAD section, ensuring
// that the provided URL resources in `extra` are loaded, along with the JaWS javascript.
// If one of the resources is named "favicon", it's URL will be stored and can
// be retrieved using FaviconURL().
//
// You only need to call this if you add your own images, scripts and stylesheets.
func (jw *Jaws) GenerateHeadHTML(extra ...string) (err error) <span class="cov8" title="1">{
        var jawsurl *url.URL
        if jawsurl, err = url.Parse(jw.serveJS.Name); err == nil </span><span class="cov8" title="1">{
                var cssurl *url.URL
                if cssurl, err = url.Parse(jw.serveCSS.Name); err == nil </span><span class="cov8" title="1">{
                        var urls []*url.URL
                        urls = append(urls, cssurl)
                        urls = append(urls, jawsurl)
                        for _, urlstr := range extra </span><span class="cov8" title="1">{
                                if u, e := url.Parse(urlstr); e == nil </span><span class="cov8" title="1">{
                                        if !strings.HasSuffix(u.Path, jawsurl.Path) </span><span class="cov8" title="1">{
                                                urls = append(urls, u)
                                        }</span>
                                } else<span class="cov8" title="1"> {
                                        err = errors.Join(err, e)
                                }</span>
                        }
                        <span class="cov8" title="1">headPrefix, faviconURL := PreloadHTML(urls...)
                        headPrefix += `&lt;meta name="jawsKey" content="`
                        jw.mu.Lock()
                        jw.headPrefix = headPrefix
                        jw.faviconURL = faviconURL
                        jw.mu.Unlock()</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

// Broadcast sends a message to all Requests.
//
// It must not be called before the JaWS processing loop (`Serve()` or
// `ServeWithTimeout()`) is running. Otherwise this call may block once the
// internal broadcast channel fills.
//
// All convenience helpers on Jaws that call Broadcast inherit this requirement.
func (jw *Jaws) Broadcast(msg Message) <span class="cov8" title="1">{
        switch msg.Dest.(type) </span>{
        case nil:<span class="cov8" title="1"></span> // send to all requests
        case *Request:<span class="cov8" title="1"></span> // send to that request
        case string:<span class="cov8" title="1"></span> // HTML id (accepted by all requests)
        default:<span class="cov8" title="1">
                tags, err := TagExpand(nil, msg.Dest)
                jw.MustLog(err)
                switch len(tags) </span>{
                case 0:<span class="cov8" title="1">
                        // no tags, so no requests will match
                        return</span>
                case 1:<span class="cov8" title="1">
                        msg.Dest = tags[0]</span>
                default:<span class="cov8" title="1">
                        msg.Dest = tags</span>
                }
        }
        <span class="cov8" title="1">select </span>{
        case &lt;-jw.Done():<span class="cov8" title="1"></span>
        case jw.bcastCh &lt;- msg:<span class="cov8" title="1"></span>
        }
}

// setDirty marks all Elements that have one or more of the given tags as dirty.
func (jw *Jaws) setDirty(tags []any) <span class="cov8" title="1">{
        jw.mu.Lock()
        defer jw.mu.Unlock()
        for _, tag := range tags </span><span class="cov8" title="1">{
                jw.dirtOrder++
                jw.dirty[tag] = jw.dirtOrder
        }</span>
}

// Dirty marks all Elements that have one or more of the given tags as dirty.
//
// Note that if any of the tags are a TagGetter, it will be called with a nil Request.
// Prefer using Request.Dirty() which avoids this.
func (jw *Jaws) Dirty(tags ...any) <span class="cov8" title="1">{
        jw.setDirty(MustTagExpand(nil, tags))
}</span>

func (jw *Jaws) distributeDirt() int <span class="cov8" title="1">{
        type orderedDirt struct {
                tag   any
                order int
        }

        jw.mu.Lock()
        dirt := make([]orderedDirt, 0, len(jw.dirty))
        for k, v := range jw.dirty </span><span class="cov8" title="1">{
                dirt = append(dirt, orderedDirt{tag: k, order: v})
                delete(jw.dirty, k)
        }</span>
        <span class="cov8" title="1">jw.dirtOrder = 0

        var reqs []*Request
        if len(dirt) &gt; 0 </span><span class="cov8" title="1">{
                reqs = make([]*Request, 0, len(jw.requests))
                for _, rq := range jw.requests </span><span class="cov8" title="1">{
                        reqs = append(reqs, rq)
                }</span>
        }
        <span class="cov8" title="1">jw.mu.Unlock()

        if len(dirt) &gt; 0 </span><span class="cov8" title="1">{
                sort.Slice(dirt, func(i, j int) bool </span><span class="cov8" title="1">{ return dirt[i].order &lt; dirt[j].order }</span>)
                <span class="cov8" title="1">tags := make([]any, len(dirt))
                for i := range dirt </span><span class="cov8" title="1">{
                        tags[i] = dirt[i].tag
                }</span>
                <span class="cov8" title="1">for _, rq := range reqs </span><span class="cov8" title="1">{
                        rq.appendDirtyTags(tags)
                }</span>
        }
        <span class="cov8" title="1">return len(dirt)</span>
}

// Reload requests all Requests to reload their current page.
func (jw *Jaws) Reload() <span class="cov8" title="1">{
        jw.Broadcast(Message{
                What: what.Reload,
        })
}</span>

// Redirect requests all Requests to navigate to the given URL.
func (jw *Jaws) Redirect(url string) <span class="cov8" title="1">{
        jw.Broadcast(Message{
                What: what.Redirect,
                Data: url,
        })
}</span>

// Alert sends an alert to all Requests. The lvl argument should be one of Bootstraps alert levels:
// primary, secondary, success, danger, warning, info, light or dark.
func (jw *Jaws) Alert(lvl, msg string) <span class="cov8" title="1">{
        jw.Broadcast(Message{
                What: what.Alert,
                Data: lvl + "\n" + msg,
        })
}</span>

// Pending returns the number of requests waiting for their WebSocket callbacks.
func (jw *Jaws) Pending() (n int) <span class="cov8" title="1">{
        jw.mu.RLock()
        defer jw.mu.RUnlock()
        for _, rq := range jw.requests </span><span class="cov8" title="1">{
                if !rq.claimed.Load() </span><span class="cov8" title="1">{
                        n++
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// ServeWithTimeout begins processing requests with the given timeout.
// It is intended to run on it's own goroutine.
// It returns when Close is called.
func (jw *Jaws) ServeWithTimeout(requestTimeout time.Duration) <span class="cov8" title="1">{
        const minInterval = time.Millisecond * 10
        const maxInterval = time.Second
        maintenanceInterval := requestTimeout / 2
        if maintenanceInterval &gt; maxInterval </span><span class="cov8" title="1">{
                maintenanceInterval = maxInterval
        }</span>
        <span class="cov8" title="1">if maintenanceInterval &lt; minInterval </span><span class="cov8" title="1">{
                maintenanceInterval = minInterval
        }</span>

        <span class="cov8" title="1">subs := map[chan Message]*Request{}
        t := time.NewTicker(maintenanceInterval)

        defer func() </span><span class="cov8" title="1">{
                t.Stop()
                for ch, rq := range subs </span><span class="cov8" title="1">{
                        rq.cancel(nil)
                        close(ch)
                }</span>
        }()

        <span class="cov8" title="1">killSub := func(msgCh chan Message) </span><span class="cov8" title="1">{
                if _, ok := subs[msgCh]; ok </span><span class="cov8" title="1">{
                        delete(subs, msgCh)
                        close(msgCh)
                }</span>
        }

        // it's critical that we keep the broadcast
        // distribution loop running, so any Request
        // that fails to process it's messages quickly
        // enough must be terminated. the alternative
        // would be to drop some messages, but that
        // could mean nonreproducible and seemingly
        // random failures in processing logic.
        <span class="cov8" title="1">mustBroadcast := func(msg Message) </span><span class="cov8" title="1">{
                for msgCh, rq := range subs </span><span class="cov8" title="1">{
                        if msg.Dest == nil || rq.wantMessage(&amp;msg) </span><span class="cov8" title="1">{
                                select </span>{
                                case msgCh &lt;- msg:<span class="cov8" title="1"></span>
                                default:<span class="cov8" title="1">
                                        // the exception is Update messages, more will follow eventually
                                        if msg.What != what.Update </span><span class="cov8" title="1">{
                                                killSub(msgCh)
                                                rq.cancel(fmt.Errorf("%v: broadcast channel full sending %s", rq, msg.String()))
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-jw.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-jw.updateTicker.C:<span class="cov8" title="1">
                        if jw.distributeDirt() &gt; 0 </span><span class="cov8" title="1">{
                                mustBroadcast(Message{What: what.Update})
                        }</span>
                case &lt;-t.C:<span class="cov8" title="1">
                        jw.maintenance(requestTimeout)</span>
                case sub := &lt;-jw.subCh:<span class="cov8" title="1">
                        if sub.msgCh != nil </span><span class="cov8" title="1">{
                                subs[sub.msgCh] = sub.rq
                        }</span>
                case msgCh := &lt;-jw.unsubCh:<span class="cov8" title="1">
                        killSub(msgCh)</span>
                case msg, ok := &lt;-jw.bcastCh:<span class="cov8" title="1">
                        if ok </span><span class="cov8" title="1">{
                                mustBroadcast(msg)
                        }</span>
                }
        }
}

// Serve calls ServeWithTimeout(time.Second * 10).
// It is intended to run on it's own goroutine.
// It returns when Close is called.
func (jw *Jaws) Serve() <span class="cov8" title="1">{
        jw.ServeWithTimeout(time.Second * 10)
}</span>

func (jw *Jaws) subscribe(rq *Request, size int) chan Message <span class="cov8" title="1">{
        msgCh := make(chan Message, size)
        select </span>{
        case &lt;-jw.Done():<span class="cov8" title="1">
                close(msgCh)
                return nil</span>
        case jw.subCh &lt;- subscription{msgCh: msgCh, rq: rq}:<span class="cov8" title="1"></span>
        }
        <span class="cov8" title="1">return msgCh</span>
}

func (jw *Jaws) unsubscribe(msgCh chan Message) <span class="cov8" title="1">{
        select </span>{
        case &lt;-jw.Done():<span class="cov8" title="1"></span>
        case jw.unsubCh &lt;- msgCh:<span class="cov8" title="1"></span>
        }
}

func (jw *Jaws) maintenance(requestTimeout time.Duration) <span class="cov8" title="1">{
        jw.mu.Lock()
        defer jw.mu.Unlock()
        now := time.Now()
        for _, rq := range jw.requests </span><span class="cov8" title="1">{
                if rq.maintenance(now, requestTimeout) </span><span class="cov8" title="1">{
                        jw.recycleLocked(rq)
                }</span>
        }
        <span class="cov8" title="1">for k, sess := range jw.sessions </span><span class="cov8" title="1">{
                if sess.isDead() </span><span class="cov8" title="1">{
                        delete(jw.sessions, k)
                }</span>
        }
}

func equalIP(a, b netip.Addr) bool <span class="cov8" title="1">{
        return a.Compare(b) == 0 || (a.IsLoopback() &amp;&amp; b.IsLoopback())
}</span>

func parseIP(remoteAddr string) (ip netip.Addr) <span class="cov8" title="1">{
        if remoteAddr != "" </span><span class="cov8" title="1">{
                if host, _, err := net.SplitHostPort(remoteAddr); err == nil </span><span class="cov8" title="1">{
                        ip, _ = netip.ParseAddr(host)
                }</span> else<span class="cov8" title="1"> {
                        ip, _ = netip.ParseAddr(remoteAddr)
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func requestIsSecure(hr *http.Request) (yes bool) <span class="cov8" title="1">{
        if hr != nil </span><span class="cov8" title="1">{
                yes = (hr.TLS != nil)
                yes = yes || strings.EqualFold(strings.TrimSpace(hr.Header.Get("X-Forwarded-Ssl")), "on")
                yes = yes || strings.EqualFold(strings.TrimSpace(hr.Header.Get("Front-End-Https")), "on")
                if !yes </span><span class="cov8" title="1">{
                        for proto := range strings.FieldsFuncSeq(hr.Header.Get("X-Forwarded-Proto"), func(r rune) bool </span><span class="cov8" title="1">{ return r == ',' || r == ' ' }</span>) <span class="cov8" title="1">{
                                yes = yes || strings.EqualFold(proto, "https")
                        }</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

func maybePanic(err error) <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                panic(err)</span>
        }
}

// SetInner sends a request to replace the inner HTML of
// all HTML elements matching target.
func (jw *Jaws) SetInner(target any, innerHTML template.HTML) <span class="cov8" title="1">{
        jw.Broadcast(Message{
                Dest: target,
                What: what.Inner,
                Data: string(innerHTML),
        })
}</span>

// SetAttr sends a request to replace the given attribute value in
// all HTML elements matching target.
func (jw *Jaws) SetAttr(target any, attr, val string) <span class="cov8" title="1">{
        jw.Broadcast(Message{
                Dest: target,
                What: what.SAttr,
                Data: attr + "\n" + val,
        })
}</span>

// RemoveAttr sends a request to remove the given attribute from
// all HTML elements matching target.
func (jw *Jaws) RemoveAttr(target any, attr string) <span class="cov8" title="1">{
        jw.Broadcast(Message{
                Dest: target,
                What: what.RAttr,
                Data: attr,
        })
}</span>

// SetClass sends a request to set the given class in
// all HTML elements matching target.
func (jw *Jaws) SetClass(target any, cls string) <span class="cov8" title="1">{
        jw.Broadcast(Message{
                Dest: target,
                What: what.SClass,
                Data: cls,
        })
}</span>

// RemoveClass sends a request to remove the given class from
// all HTML elements matching target.
func (jw *Jaws) RemoveClass(target any, cls string) <span class="cov8" title="1">{
        jw.Broadcast(Message{
                Dest: target,
                What: what.RClass,
                Data: cls,
        })
}</span>

// SetValue sends a request to set the HTML "value" attribute of
// all HTML elements matching target.
func (jw *Jaws) SetValue(target any, val string) <span class="cov8" title="1">{
        jw.Broadcast(Message{
                Dest: target,
                What: what.Value,
                Data: val,
        })
}</span>

// Insert calls the Javascript 'insertBefore()' method on
// all HTML elements matching target.
//
// The position parameter 'where' may be either a HTML ID, an child index or the text 'null'.
func (jw *Jaws) Insert(target any, where, html string) <span class="cov8" title="1">{
        jw.Broadcast(Message{
                Dest: target,
                What: what.Insert,
                Data: where + "\n" + html,
        })
}</span>

// Replace replaces the HTML content on
// all HTML elements matching target.
//
// The position parameter 'where' may be either a HTML ID or an index.
func (jw *Jaws) Replace(target any, where, html string) <span class="cov8" title="1">{
        jw.Broadcast(Message{
                Dest: target,
                What: what.Replace,
                Data: where + "\n" + html,
        })
}</span>

// Delete removes the HTML element(s) matching target.
func (jw *Jaws) Delete(target any) <span class="cov8" title="1">{
        jw.Broadcast(Message{
                Dest: target,
                What: what.Delete,
        })
}</span>

// Append calls the Javascript 'appendChild()' method on all HTML elements matching target.
func (jw *Jaws) Append(target any, html template.HTML) <span class="cov8" title="1">{
        jw.Broadcast(Message{
                Dest: target,
                What: what.Append,
                Data: string(html),
        })
}</span>

// JsCall calls the Javascript function 'jsfunc' with the argument 'jsonstr'
// on all Requests that have the target UI tag.
// The jsonstr argument must a valid JSON object in string format.
func (jw *Jaws) JsCall(tag any, jsfunc, jsonstr string) <span class="cov8" title="1">{
        jw.Broadcast(Message{
                Dest: tag,
                What: what.Call,
                Data: jsfunc + "=" + jsonstr,
        })
}</span>

func (jw *Jaws) getRequestLocked(jawsKey uint64, hr *http.Request) (rq *Request) <span class="cov8" title="1">{
        rq = jw.reqPool.Get().(*Request)
        rq.JawsKey = jawsKey
        rq.lastWrite = time.Now()
        rq.initial = hr
        rq.ctx, rq.cancelFn = context.WithCancelCause(jw.BaseContext)
        if hr != nil </span><span class="cov8" title="1">{
                rq.remoteIP = parseIP(hr.RemoteAddr)
                if sess := jw.getSessionLocked(getCookieSessionsIds(hr.Header, jw.CookieName), rq.remoteIP); sess != nil </span><span class="cov8" title="1">{
                        sess.addRequest(rq)
                        rq.session = sess
                }</span>
        }
        <span class="cov8" title="1">return rq</span>
}

func (jw *Jaws) recycleLocked(rq *Request) <span class="cov8" title="1">{
        rq.mu.Lock()
        defer rq.mu.Unlock()
        if rq.JawsKey != 0 </span><span class="cov8" title="1">{
                delete(jw.requests, rq.JawsKey)
                rq.clearLocked()
                jw.reqPool.Put(rq)
        }</span>
}

func (jw *Jaws) recycle(rq *Request) <span class="cov8" title="1">{
        jw.mu.Lock()
        defer jw.mu.Unlock()
        jw.recycleLocked(rq)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package core

import (
        _ "embed"
        "mime"
        "net/url"
        "path/filepath"
        "strconv"
        "strings"
)

// JavascriptText is the source code for the client-side JaWS Javascript library.
//
//go:embed jaws.js
var JavascriptText []byte

//go:embed jaws.css
var JawsCSS []byte

// JawsKeyAppend appends the JaWS key as a string to the buffer.
func JawsKeyAppend(b []byte, jawsKey uint64) []byte <span class="cov8" title="1">{
        if jawsKey != 0 </span><span class="cov8" title="1">{
                b = strconv.AppendUint(b, jawsKey, 32)
        }</span>
        <span class="cov8" title="1">return b</span>
}

// JawsKeyString returns the string to be used for the given JaWS key.
func JawsKeyString(jawsKey uint64) string <span class="cov8" title="1">{
        return string(JawsKeyAppend(nil, jawsKey))
}</span>

// JawsKeyValue parses a key string (as returned JawsKeyString) into a uint64.
func JawsKeyValue(jawsKey string) uint64 <span class="cov8" title="1">{
        slashIdx := strings.IndexByte(jawsKey, '/')
        if slashIdx &lt; 0 </span><span class="cov8" title="1">{
                slashIdx = len(jawsKey)
        }</span>
        <span class="cov8" title="1">if val, err := strconv.ParseUint(jawsKey[:slashIdx], 32, 64); err == nil </span><span class="cov8" title="1">{
                return val
        }</span>
        <span class="cov8" title="1">return 0</span>
}

// PreloadHTML returns HTML code to load the given resources efficiently.
func PreloadHTML(urls ...*url.URL) (htmlcode, faviconurl string) <span class="cov8" title="1">{
        var jsurls, cssurls []string
        var favicontype string
        var buf []byte
        for _, u := range urls </span><span class="cov8" title="1">{
                if u != nil </span><span class="cov8" title="1">{
                        var asattr string
                        ext := strings.ToLower(filepath.Ext(u.Path))
                        mimetype := mime.TypeByExtension(ext)
                        if semi := strings.IndexByte(mimetype, ';'); semi &gt; 0 </span><span class="cov8" title="1">{
                                mimetype = mimetype[:semi]
                        }</span>
                        <span class="cov8" title="1">urlstr := u.String()
                        switch ext </span>{
                        case ".js":<span class="cov8" title="1">
                                jsurls = append(jsurls, urlstr)
                                continue</span>
                        case ".css":<span class="cov8" title="1">
                                cssurls = append(cssurls, urlstr)
                                continue</span>
                        default:<span class="cov8" title="1">
                                if strings.HasPrefix(mimetype, "image") </span><span class="cov8" title="1">{
                                        asattr = "image"
                                        if strings.HasPrefix(filepath.Base(u.Path), "favicon") </span><span class="cov8" title="1">{
                                                favicontype = mimetype
                                                faviconurl = urlstr
                                                continue</span>
                                        }
                                } else<span class="cov8" title="1"> if strings.HasPrefix(mimetype, "font") </span><span class="cov8" title="1">{
                                        asattr = "font"
                                }</span>
                        }
                        <span class="cov8" title="1">buf = append(buf, `&lt;link rel="preload" href="`...)
                        buf = append(buf, urlstr...)
                        buf = append(buf, '"')
                        if asattr != "" </span><span class="cov8" title="1">{
                                buf = append(buf, ` as="`...)
                                buf = append(buf, asattr...)
                                buf = append(buf, '"')
                        }</span>
                        <span class="cov8" title="1">if mimetype != "" </span><span class="cov8" title="1">{
                                buf = append(buf, ` type="`...)
                                buf = append(buf, mimetype...)
                                buf = append(buf, '"')
                        }</span>
                        <span class="cov8" title="1">buf = append(buf, "&gt;\n"...)</span>
                }
        }
        <span class="cov8" title="1">for _, urlstr := range cssurls </span><span class="cov8" title="1">{
                buf = append(buf, `&lt;link rel="stylesheet" href="`...)
                buf = append(buf, urlstr...)
                buf = append(buf, "\"&gt;\n"...)
        }</span>
        <span class="cov8" title="1">if faviconurl != "" </span><span class="cov8" title="1">{
                buf = append(buf, `&lt;link rel="icon" type="`...)
                buf = append(buf, favicontype...)
                buf = append(buf, `" href="`...)
                buf = append(buf, faviconurl...)
                buf = append(buf, "\"&gt;\n"...)
        }</span>
        <span class="cov8" title="1">for _, urlstr := range jsurls </span><span class="cov8" title="1">{
                buf = append(buf, `&lt;script defer src="`...)
                buf = append(buf, []byte(urlstr)...)
                buf = append(buf, "\"&gt;&lt;/script&gt;\n"...)
        }</span>
        <span class="cov8" title="1">htmlcode = string(buf)
        return</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package core

import (
        "fmt"
        "html"
        "html/template"
)

type htmlGetter struct{ v template.HTML }

func (g htmlGetter) JawsGetHTML(e *Element) template.HTML <span class="cov8" title="1">{
        return g.v
}</span>

func (g htmlGetter) JawsGetTag(rq *Request) any <span class="cov8" title="1">{
        return nil
}</span>

type htmlStringerGetter struct{ sg fmt.Stringer }

func (g htmlStringerGetter) JawsGetHTML(e *Element) template.HTML <span class="cov8" title="1">{
        return template.HTML(html.EscapeString(g.sg.String())) // #nosec G203
}</span>

func (g htmlStringerGetter) JawsGetTag(rq *Request) any <span class="cov8" title="1">{
        return g.sg
}</span>

type htmlGetterString struct{ sg Getter[string] }

func (g htmlGetterString) JawsGetHTML(e *Element) template.HTML <span class="cov8" title="1">{
        return template.HTML(html.EscapeString(g.sg.JawsGet(e))) // #nosec G203
}</span>

func (g htmlGetterString) JawsGetTag(rq *Request) any <span class="cov8" title="1">{
        return g.sg
}</span>

// MakeHTMLGetter returns a HTMLGetter for v.
//
// Depending on the type of v, we return:
//
//   - HTMLGetter: `JawsGetHTML(e *Element) template.HTML` to be used as-is.
//   - Getter[string]: `JawsGet(elem *Element) string` that will be escaped using `html.EscapeString`.
//   - Formatter: `Format("%v") string` that will be escaped using `html.EscapeString`.
//   - fmt.Stringer: `String() string` that will be escaped using `html.EscapeString`.
//   - a static `template.HTML` or `string` to be used as-is with no HTML escaping.
//   - everything else is rendered using `fmt.Sprint()` and escaped using `html.EscapeString`.
//
// WARNING: Plain string values are NOT HTML-escaped. This is intentional so that
// HTML markup can be passed conveniently from Go templates (e.g. `{{$.Span "&lt;i&gt;text&lt;/i&gt;"}}`).
// Never pass untrusted user input as a plain string; use [template.HTML] to signal
// that the content is trusted, or wrap user input in a [Getter] or [fmt.Stringer]
// so it will be escaped automatically.
func MakeHTMLGetter(v any) HTMLGetter <span class="cov8" title="1">{
        switch v := v.(type) </span>{
        case HTMLGetter:<span class="cov8" title="1">
                return v</span>
        case template.HTML:<span class="cov8" title="1">
                return htmlGetter{v}</span>
        case Getter[string]:<span class="cov8" title="1">
                return htmlGetterString{v}</span>
        case Formatter:<span class="cov8" title="1">
                return htmlGetterString{v.Format("%v")}</span>
        case fmt.Stringer:<span class="cov8" title="1">
                return htmlStringerGetter{v}</span>
        case string:<span class="cov8" title="1">
                return htmlGetter{template.HTML(v)}</span> // #nosec G203
        default:<span class="cov8" title="1">
                return htmlGetter{template.HTML(html.EscapeString(fmt.Sprint(v)))}</span> // #nosec G203
        }
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package core

import (
        "fmt"

        "github.com/linkdata/jaws/what"
)

// Message contains the elements of a message to be sent to Requests.
type Message struct {
        Dest any       // destination (tag, html ID or *Element)
        What what.What // what to change or do
        Data string    // data (e.g. inner HTML content or slice of tags)
}

// String returns the Message in a form suitable for debug output.
func (msg *Message) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("{%v, %v, %q}",
                msg.Dest,
                msg.What,
                msg.Data,
        )
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package core

import (
        "fmt"
        "html/template"

        "github.com/linkdata/deadlock"
)

// NamedBool stores a named boolen value with a HTML representation.
type NamedBool struct {
        nba     *NamedBoolArray  // (read-only) NamedBoolArray that this is part of (may be nil)
        name    string           // (read-only) name within the named bool set
        html    template.HTML    // (read-only) HTML code used in select lists or labels
        mu      deadlock.RWMutex // protects following
        checked bool             // it's state
}

func NewNamedBool(nba *NamedBoolArray, name string, html template.HTML, checked bool) *NamedBool <span class="cov8" title="1">{
        return &amp;NamedBool{
                nba:     nba,
                name:    name,
                html:    html,
                checked: checked,
        }
}</span>

func (nb *NamedBool) Array() *NamedBoolArray <span class="cov8" title="1">{
        return nb.nba
}</span>

func (nb *NamedBool) Name() (s string) <span class="cov8" title="1">{
        s = nb.name
        return
}</span>

func (nb *NamedBool) HTML() (h template.HTML) <span class="cov8" title="1">{
        h = nb.html
        return
}</span>

func (nb *NamedBool) JawsGetHTML(*Element) (h template.HTML) <span class="cov8" title="1">{
        return nb.HTML()
}</span>

func (nb *NamedBool) JawsGet(*Element) (v bool) <span class="cov8" title="1">{
        nb.mu.RLock()
        v = nb.checked
        nb.mu.RUnlock()
        return
}</span>

func (nb *NamedBool) JawsSet(e *Element, checked bool) (err error) <span class="cov8" title="1">{
        err = ErrValueUnchanged
        nba := nb.nba
        if nba != nil </span><span class="cov8" title="1">{
                nba.mu.Lock()
                defer nba.mu.Unlock()
        }</span>
        <span class="cov8" title="1">nb.mu.Lock()
        if nb.checked != checked </span><span class="cov8" title="1">{
                nb.checked = checked
                err = nil
        }</span>
        <span class="cov8" title="1">nb.mu.Unlock()
        if err == nil </span><span class="cov8" title="1">{
                e.Dirty(nb)
                if nba != nil </span><span class="cov8" title="1">{
                        nba.deselectOthersLocked(nb.name, checked)
                        e.Dirty(nba)
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func (nb *NamedBool) Checked() (checked bool) <span class="cov8" title="1">{
        nb.mu.RLock()
        checked = nb.checked
        nb.mu.RUnlock()
        return
}</span>

func (nb *NamedBool) Set(checked bool) (changed bool) <span class="cov8" title="1">{
        nb.mu.Lock()
        if nb.checked != checked </span><span class="cov8" title="1">{
                nb.checked = checked
                changed = true
        }</span>
        <span class="cov8" title="1">nb.mu.Unlock()
        return</span>
}

// String returns a string representation of the NamedBool suitable for debugging.
func (nb *NamedBool) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("&amp;{%q,%q,%v}", nb.Name(), nb.HTML(), nb.Checked())
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package core

import (
        "html/template"
        "strings"

        "github.com/linkdata/deadlock"
)

// NamedBoolArray stores the data required to support HTML 'select' elements
// and sets of HTML radio buttons. It it safe to use from multiple goroutines
// concurrently.
type NamedBoolArray struct {
        Multi bool             // allow multiple NamedBools to be true
        mu    deadlock.RWMutex // protects following
        data  []*NamedBool
}

var _ SelectHandler = (*NamedBoolArray)(nil)

func NewNamedBoolArray() *NamedBoolArray <span class="cov8" title="1">{
        return &amp;NamedBoolArray{}
}</span>

// ReadLocked calls the given function with the NamedBoolArray locked for reading.
func (nba *NamedBoolArray) ReadLocked(fn func(nbl []*NamedBool)) <span class="cov8" title="1">{
        nba.mu.RLock()
        defer nba.mu.RUnlock()
        fn(nba.data)
}</span>

// WriteLocked calls the given function with the NamedBoolArray locked for writing and
// replaces the internal []*NamedBool slice with the return value.
func (nba *NamedBoolArray) WriteLocked(fn func(nbl []*NamedBool) []*NamedBool) <span class="cov8" title="1">{
        nba.mu.Lock()
        defer nba.mu.Unlock()
        nba.data = fn(nba.data)
}</span>

func (nba *NamedBoolArray) JawsContains(e *Element) (contents []UI) <span class="cov8" title="1">{
        nba.mu.RLock()
        for _, nb := range nba.data </span><span class="cov8" title="1">{
                contents = append(contents, namedBoolOption{nb})
        }</span>
        <span class="cov8" title="1">nba.mu.RUnlock()
        return</span>
}

// Add adds a NamedBool with the given name and the given text.
// Returns itself.
//
// Note that while it's legal to have multiple NamedBool with the same name
// since it's allowed in HTML, it's probably not a good idea.
func (nba *NamedBoolArray) Add(name string, text template.HTML) *NamedBoolArray <span class="cov8" title="1">{
        nba.mu.Lock()
        nba.data = append(nba.data, NewNamedBool(nba, name, text, false))
        nba.mu.Unlock()
        return nba
}</span>

// Set sets the Checked state for the NamedBool(s) with the given name.
//
// If the given name doesn't match any NamedBool(s) in single-select
// mode, everything will be deselected.
func (nba *NamedBoolArray) Set(name string, state bool) (changed bool) <span class="cov8" title="1">{
        nba.mu.Lock()
        defer nba.mu.Unlock()
        for _, nb := range nba.data </span><span class="cov8" title="1">{
                if nb.Name() == name </span><span class="cov8" title="1">{
                        changed = nb.Set(state) || changed
                }</span>
        }
        <span class="cov8" title="1">changed = nba.deselectOthersLocked(name, state) || changed
        return</span>
}

// deselectOthersLocked clears all NamedBools whose name differs from
// the given name when the array is in single-select mode and state is true.
func (nba *NamedBoolArray) deselectOthersLocked(name string, state bool) (changed bool) <span class="cov8" title="1">{
        if state &amp;&amp; !nba.Multi </span><span class="cov8" title="1">{
                for _, nb := range nba.data </span><span class="cov8" title="1">{
                        if nb.Name() != name </span><span class="cov8" title="1">{
                                changed = nb.Set(false) || changed
                        }</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

// Get returns the name of first NamedBool in the group that
// has it's Checked value set to true. Returns an empty string
// if none are true.
//
// In case you can have more than one selected or you need to
// distinguish between a blank name and the fact that none are
// set to true, use ReadLocked() to inspect the data directly.
func (nba *NamedBoolArray) Get() (name string) <span class="cov8" title="1">{
        nba.mu.RLock()
        for _, nb := range nba.data </span><span class="cov8" title="1">{
                if nb.Checked() </span><span class="cov8" title="1">{
                        name = nb.Name()
                        break</span>
                }
        }
        <span class="cov8" title="1">nba.mu.RUnlock()
        return</span>
}

func (nba *NamedBoolArray) isCheckedLocked(name string) bool <span class="cov8" title="1">{
        for _, nb := range nba.data </span><span class="cov8" title="1">{
                if nb.Checked() &amp;&amp; nb.Name() == name </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// IsChecked returns true if any of the NamedBool in the set that have the
// given name are Checked. Returns false if the name is not found.
func (nba *NamedBoolArray) IsChecked(name string) (state bool) <span class="cov8" title="1">{
        nba.mu.RLock()
        state = nba.isCheckedLocked(name)
        nba.mu.RUnlock()
        return
}</span>

// String returns a string representation of the NamedBoolArray suitable for debugging.
func (nba *NamedBoolArray) String() string <span class="cov8" title="1">{
        var sb strings.Builder
        sb.WriteString("&amp;NamedBoolArray{[")
        nba.mu.RLock()
        for i, nb := range nba.data </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        sb.WriteByte(',')
                }</span>
                <span class="cov8" title="1">sb.WriteString(nb.String())</span>
        }
        <span class="cov8" title="1">nba.mu.RUnlock()
        sb.WriteString("]}")
        return sb.String()</span>
}

func (nba *NamedBoolArray) JawsGet(e *Element) string <span class="cov8" title="1">{
        return nba.Get()
}</span>

func (nba *NamedBoolArray) JawsSet(e *Element, name string) (err error) <span class="cov8" title="1">{
        if nba.Set(name, true) </span><span class="cov8" title="1">{
                e.Dirty(nba)
        }</span> else<span class="cov8" title="1"> {
                err = ErrValueUnchanged
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package core

import (
        "html"
        "html/template"
        "io"
)

// namedBoolOption is an internal UI wrapper used by NamedBoolArray.JawsContains.
// It intentionally stays unexported; public option widgets live in package ui.
type namedBoolOption struct {
        *NamedBool
}

func (ui namedBoolOption) JawsRender(e *Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        e.Tag(ui.NamedBool)
        attrs := e.ApplyParams(params)
        valattr := template.HTMLAttr(`value="` + html.EscapeString(ui.Name()) + `"`) // #nosec G203
        attrs = append(attrs, valattr)
        if ui.Checked() </span><span class="cov8" title="1">{
                attrs = append(attrs, "selected")
        }</span>
        <span class="cov8" title="1">return WriteHTMLInner(w, e.Jid(), "option", "", ui.JawsGetHTML(e), attrs...)</span>
}

func (ui namedBoolOption) JawsUpdate(e *Element) <span class="cov8" title="1">{
        if ui.Checked() </span><span class="cov8" title="1">{
                e.SetAttr("selected", "")
        }</span> else<span class="cov8" title="1"> {
                e.RemoveAttr("selected")
        }</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package core

import "html/template"

// shouldAutoTagHandler returns true if a handler value is safe to use as a tag.
// Non-comparable handlers are only auto-tagged when they provide an explicit TagGetter.
func shouldAutoTagHandler(handler any) any <span class="cov8" title="1">{
        if _, ok := handler.(TagGetter); ok || newErrNotComparable(handler) == nil </span><span class="cov8" title="1">{
                return handler
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ParseParams parses the parameters passed to UI() when creating a new Element,
// returning UI tags, event handlers and HTML attributes.
func ParseParams(params []any) (tags []any, handlers []EventHandler, attrs []string) <span class="cov8" title="1">{
        for i := range params </span><span class="cov8" title="1">{
                switch data := params[i].(type) </span>{
                case template.HTMLAttr:<span class="cov8" title="1">
                        attrs = append(attrs, string(data))</span>
                case []template.HTMLAttr:<span class="cov8" title="1">
                        for _, s := range data </span><span class="cov8" title="1">{
                                attrs = append(attrs, string(s))
                        }</span>
                case string:<span class="cov8" title="1">
                        attrs = append(attrs, data)</span>
                case []string:<span class="cov8" title="1">
                        attrs = append(attrs, data...)</span>
                case EventFn:<span class="cov8" title="1">
                        if data != nil </span><span class="cov8" title="1">{
                                handlers = append(handlers, eventFnWrapper{data})
                        }</span>
                default:<span class="cov8" title="1">
                        if h, ok := data.(EventHandler); ok </span><span class="cov8" title="1">{
                                handlers = append(handlers, h)
                                data = shouldAutoTagHandler(data)
                        }</span> else<span class="cov8" title="1"> if h, ok := data.(ClickHandler); ok </span><span class="cov8" title="1">{
                                handlers = append(handlers, clickHandlerWrapper{h})
                                data = shouldAutoTagHandler(data)
                        }</span>
                        <span class="cov8" title="1">tags = append(tags, data)</span>
                }
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package core

import (
        "bytes"
        "cmp"
        "context"
        "errors"
        "fmt"
        "html"
        "io"
        "net/http"
        "net/netip"
        "net/url"
        "slices"
        "sort"
        "strconv"
        "strings"
        "sync/atomic"
        "time"

        "github.com/linkdata/deadlock"
        "github.com/linkdata/jaws/jid"
        "github.com/linkdata/jaws/what"
)

// ConnectFn can be used to interact with a Request before message processing starts.
// Returning an error causes the Request to abort, and the WebSocket connection to close.
type ConnectFn = func(rq *Request) error

// Request maintains the state for a JaWS WebSocket connection, and handles processing
// of events and broadcasts.
//
// Note that we have to store the context inside the struct because there is no call chain
// between the Request being created and it being used once the WebSocket is created.
type Request struct {
        Jaws       *Jaws                   // (read-only) the JaWS instance the Request belongs to
        JawsKey    uint64                  // (read-only) a random number used in the WebSocket URI to identify this Request
        remoteIP   netip.Addr              // (read-only) remote IP, or nil
        Rendering  atomic.Bool             // set to true by RequestWriter.Write()
        running    atomic.Bool             // if ServeHTTP() is running
        claimed    atomic.Bool             // if UseRequest() has been called for it
        mu         deadlock.RWMutex        // protects following
        lastWrite  time.Time               // when the initial HTML was last written to, used for automatic cleanup
        initial    *http.Request           // initial HTTP request passed to Jaws.NewRequest
        session    *Session                // session, if established
        todoDirt   []any                   // dirty tags
        ctx        context.Context         // current context, derived from either Jaws or WS HTTP req
        httpDoneCh &lt;-chan struct{}         // once claimed, set to http.Request.Context().Done()
        cancelFn   context.CancelCauseFunc // cancel function
        connectFn  ConnectFn               // a ConnectFn to call before starting message processing for the Request
        elems      []*Element              // our Elements
        tagMap     map[any][]*Element      // maps tags to Elements
        muQueue    deadlock.Mutex          // protects wsQueue
        wsQueue    []WsMsg                 // queued messages to send
}

type eventFnCall struct {
        jid  Jid
        wht  what.What
        data string
}

var (
        ErrWebsocketOriginMissing     = errors.New("websocket request missing Origin header")
        ErrWebsocketOriginWrongScheme = errors.New("websocket Origin not http or https")
        ErrWebsocketOriginWrongHost   = errors.New("websocket Origin host mismatch")
        ErrRequestAlreadyClaimed      = errors.New("request already claimed")
        ErrJavascriptDisabled         = errors.New("javascript is disabled")
)

func (rq *Request) JawsKeyString() string <span class="cov8" title="1">{
        jawsKey := uint64(0)
        if rq != nil </span><span class="cov8" title="1">{
                jawsKey = rq.JawsKey
        }</span>
        <span class="cov8" title="1">return JawsKeyString(jawsKey)</span>
}

func (rq *Request) String() string <span class="cov8" title="1">{
        return "Request&lt;" + rq.JawsKeyString() + "&gt;"
}</span>

func (rq *Request) claim(hr *http.Request) error <span class="cov8" title="1">{
        if !rq.claimed.Load() </span><span class="cov8" title="1">{
                var actualIP netip.Addr
                var httpDoneCh &lt;-chan struct{}
                if hr != nil </span><span class="cov8" title="1">{ // can be nil in tests
                        actualIP = parseIP(hr.RemoteAddr)
                        httpDoneCh = hr.Context().Done()
                }</span>
                <span class="cov8" title="1">rq.mu.Lock()
                defer rq.mu.Unlock()
                if !equalIP(rq.remoteIP, actualIP) </span><span class="cov8" title="1">{
                        return fmt.Errorf("/jaws/%s: expected IP %q, got %q", rq.JawsKeyString(), rq.remoteIP.String(), actualIP.String())
                }</span>
                <span class="cov8" title="1">if rq.claimed.CompareAndSwap(false, true) </span><span class="cov8" title="1">{
                        rq.ctx, rq.cancelFn = context.WithCancelCause(rq.ctx)
                        rq.httpDoneCh = httpDoneCh
                        return nil
                }</span>
        }
        <span class="cov8" title="1">return ErrRequestAlreadyClaimed</span>
}

func (rq *Request) killSessionLocked() <span class="cov8" title="1">{
        if rq.session != nil </span><span class="cov8" title="1">{
                rq.session.delRequest(rq)
                rq.session = nil
        }</span>
}

func (rq *Request) killSession() <span class="cov8" title="1">{
        rq.mu.Lock()
        rq.killSessionLocked()
        rq.mu.Unlock()
}</span>

func (rq *Request) deadSession(sess *Session) <span class="cov8" title="1">{
        rq.mu.Lock()
        if rq.session == sess </span><span class="cov8" title="1">{
                rq.session = nil
        }</span>
        <span class="cov8" title="1">rq.mu.Unlock()</span>
}

func (rq *Request) clearLocked() *Request <span class="cov8" title="1">{
        rq.JawsKey = 0
        rq.connectFn = nil
        rq.lastWrite = time.Time{}
        rq.initial = nil
        rq.running.Store(false)
        rq.claimed.Store(false)
        rq.Rendering.Store(false)
        if rq.cancelFn != nil </span><span class="cov8" title="1">{
                rq.cancelFn(nil)
        }</span>
        <span class="cov8" title="1">rq.httpDoneCh = nil
        rq.todoDirt = rq.todoDirt[:0]
        rq.remoteIP = netip.Addr{}
        for _, e := range rq.elems </span><span class="cov8" title="1">{
                if e != nil </span><span class="cov8" title="1">{
                        e.Request = nil
                        e.handlers = nil
                        e.ui = nil
                }</span>
        }
        <span class="cov8" title="1">clear(rq.elems)
        rq.elems = rq.elems[:0]
        rq.wsQueue = rq.wsQueue[:0]
        clear(rq.tagMap)
        rq.killSessionLocked()
        return rq</span>
}

// HeadHTML writes the HTML code needed in the HTML page's HEAD section.
func (rq *Request) HeadHTML(w io.Writer) (err error) <span class="cov8" title="1">{
        var b []byte
        rq.Jaws.mu.RLock()
        b = append(b, rq.Jaws.headPrefix...)
        rq.Jaws.mu.RUnlock()
        b = JawsKeyAppend(b, rq.JawsKey)
        b = append(b, `"&gt;`...)
        _, err = w.Write(b)
        return
}</span>

// appendJSQuote is like strconv.AppendQuote but also escapes '&lt;' as '\x3c'
// to prevent '&lt;/script&gt;' from closing the script block when embedded in HTML.
func appendJSQuote(b []byte, s string) []byte <span class="cov8" title="1">{
        quoted := strconv.AppendQuote(nil, s)
        return append(b, bytes.ReplaceAll(quoted, []byte("&lt;"), []byte(`\x3c`))...)
}</span>

func (rq *Request) getTailActions() (b []byte) <span class="cov8" title="1">{
        rq.muQueue.Lock()
        defer rq.muQueue.Unlock()
        n := 0
        for _, msg := range rq.wsQueue </span><span class="cov8" title="1">{
                var fn string
                switch msg.What </span>{
                case what.SAttr:<span class="cov8" title="1">
                        fn = "setAttribute"</span>
                case what.RAttr:<span class="cov8" title="1">
                        fn = "removeAttribute"</span>
                case what.SClass:<span class="cov8" title="1">
                        fn = "classList?.add"</span>
                case what.RClass:<span class="cov8" title="1">
                        fn = "classList?.remove"</span>
                }
                <span class="cov8" title="1">if fn != "" </span><span class="cov8" title="1">{
                        if len(b) == 0 </span><span class="cov8" title="1">{
                                b = append(b, "\n&lt;script&gt;"...)
                        }</span>
                        <span class="cov8" title="1">b = append(b, "\ndocument.getElementById("...)
                        b = msg.Jid.AppendQuote(b)
                        b = append(b, ")?."...)
                        b = append(b, fn...)
                        b = append(b, "("...)
                        attr, val, ok := strings.Cut(msg.Data, "\n")
                        b = appendJSQuote(b, attr)
                        if ok </span><span class="cov8" title="1">{
                                b = append(b, ',')
                                b = appendJSQuote(b, val)
                        }</span>
                        <span class="cov8" title="1">b = append(b, ");"...)</span>
                } else<span class="cov8" title="1"> {
                        rq.wsQueue[n] = msg
                        n++
                }</span>
        }
        <span class="cov8" title="1">for i := n; i &lt; len(rq.wsQueue); i++ </span><span class="cov8" title="1">{
                rq.wsQueue[i] = WsMsg{}
        }</span>
        <span class="cov8" title="1">rq.wsQueue = rq.wsQueue[:n]
        if len(b) &gt; 0 </span><span class="cov8" title="1">{
                b = append(b, "\n&lt;/script&gt;"...)
        }</span>
        <span class="cov8" title="1">return</span>
}

// TailHTML writes optional HTML code at the end of the page's BODY section that
// will immediately apply HTML attribute and class updates made during initial
// rendering, which eliminates flicker without having to write the correct
// value in templates or during JawsRender().
//
// It also adds a &lt;noscript&gt; tag that warns of reduces functionality.
func (rq *Request) TailHTML(w io.Writer) (err error) <span class="cov8" title="1">{
        if _, err = fmt.Fprintf(w, "\n"+`&lt;noscript&gt;`+
                `&lt;div class="jaws-alert"&gt;This site requires Javascript for full functionality.&lt;/div&gt;`+
                `&lt;img src="/jaws/%s/noscript" alt="noscript"&gt;&lt;/noscript&gt;`, rq.JawsKeyString()); err == nil </span><span class="cov8" title="1">{
                if actions := rq.getTailActions(); len(actions) &gt; 0 </span><span class="cov8" title="1">{
                        _, err = w.Write(actions)
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// GetConnectFn returns the currently set ConnectFn. That function will be called before starting the WebSocket tunnel if not nil.
func (rq *Request) GetConnectFn() (fn ConnectFn) <span class="cov8" title="1">{
        rq.mu.RLock()
        fn = rq.connectFn
        rq.mu.RUnlock()
        return
}</span>

// SetConnectFn sets ConnectFn. That function will be called before starting the WebSocket tunnel if not nil.
func (rq *Request) SetConnectFn(fn ConnectFn) <span class="cov8" title="1">{
        rq.mu.Lock()
        rq.connectFn = fn
        rq.mu.Unlock()
}</span>

// Session returns the Request's Session, or nil.
func (rq *Request) Session() (sess *Session) <span class="cov8" title="1">{
        rq.mu.RLock()
        sess = rq.session
        rq.mu.RUnlock()
        return
}</span>

// Initial returns the Request's initial HTTP request, or nil.
func (rq *Request) Initial() (r *http.Request) <span class="cov8" title="1">{
        rq.mu.RLock()
        r = rq.initial
        rq.mu.RUnlock()
        return
}</span>

// Get is shorthand for `Session().Get()` and returns the session value associated with the key, or nil.
// It no session is associated with the Request, returns nil.
func (rq *Request) Get(key string) any <span class="cov8" title="1">{
        return rq.Session().Get(key)
}</span>

// Set is shorthand for `Session().Set()` and sets a session value to be associated with the key.
// If value is nil, the key is removed from the session.
// Does nothing if there is no session is associated with the Request.
func (rq *Request) Set(key string, val any) <span class="cov8" title="1">{
        rq.Session().Set(key, val)
}</span>

// Context returns the Request's Context, which is by default derived from jaws.BaseContext.
func (rq *Request) Context() (ctx context.Context) <span class="cov8" title="1">{
        rq.mu.RLock()
        ctx = rq.ctx
        rq.mu.RUnlock()
        return
}</span>

// SetContext atomically replaces the Request's context with the function return value.
// The function is given the current context and must return a non-nil context.
// The returned context must be derived from oldctx so cancellation and deadlines
// continue to propagate to Request.Context().
func (rq *Request) SetContext(fn func(oldctx context.Context) (newctx context.Context)) <span class="cov8" title="1">{
        rq.mu.Lock()
        defer rq.mu.Unlock()
        if rq.ctx = fn(rq.ctx); rq.ctx == nil </span><span class="cov8" title="1">{
                panic("context must not be nil")</span>
        }
}

func (rq *Request) maintenance(now time.Time, requestTimeout time.Duration) bool <span class="cov8" title="1">{
        if !rq.running.Load() </span><span class="cov8" title="1">{
                if rq.Rendering.Swap(false) </span><span class="cov8" title="1">{
                        rq.mu.Lock()
                        rq.lastWrite = now
                        rq.mu.Unlock()
                }</span>
                <span class="cov8" title="1">rq.mu.RLock()
                err := rq.ctx.Err()
                since := now.Sub(rq.lastWrite)
                rq.mu.RUnlock()
                if err != nil </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">if since &gt; requestTimeout </span><span class="cov8" title="1">{
                        rq.cancel(newErrNoWebSocketRequest(rq))
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (rq *Request) cancelLocked(err error) <span class="cov8" title="1">{
        if rq.JawsKey != 0 &amp;&amp; rq.ctx.Err() == nil </span><span class="cov8" title="1">{
                if !rq.running.Load() </span><span class="cov8" title="1">{
                        err = newErrPendingCancelledLocked(rq, err)
                }</span>
                <span class="cov8" title="1">rq.cancelFn(rq.Jaws.Log(err))</span>
        }
}

func (rq *Request) cancel(err error) <span class="cov8" title="1">{
        rq.mu.Lock()
        defer rq.mu.Unlock()
        rq.cancelLocked(err)
}</span>

// Alert attempts to show an alert message on the current request webpage if it has an HTML element with the id 'jaws-alert'.
// The lvl argument should be one of Bootstraps alert levels: primary, secondary, success, danger, warning, info, light or dark.
//
// The default JaWS javascript only supports Bootstrap.js dismissable alerts.
// See Jaws.Broadcast for processing-loop requirements.
func (rq *Request) Alert(lvl, msg string) <span class="cov8" title="1">{
        rq.Jaws.Broadcast(Message{
                Dest: rq,
                What: what.Alert,
                Data: lvl + "\n" + msg,
        })
}</span>

// AlertError calls Alert if the given error is not nil.
func (rq *Request) AlertError(err error) <span class="cov8" title="1">{
        if rq.Jaws.Log(err) != nil </span><span class="cov8" title="1">{
                rq.Alert("danger", html.EscapeString(err.Error()))
        }</span>
}

// Redirect requests the current Request to navigate to the given URL.
// See Jaws.Broadcast for processing-loop requirements.
func (rq *Request) Redirect(url string) <span class="cov8" title="1">{
        rq.Jaws.Broadcast(Message{
                Dest: rq,
                What: what.Redirect,
                Data: url,
        })
}</span>

func (rq *Request) tagsOfLocked(elem *Element) (tags []any) <span class="cov8" title="1">{
        for tag, elems := range rq.tagMap </span><span class="cov8" title="1">{
                for _, e := range elems </span><span class="cov8" title="1">{
                        if e == elem </span><span class="cov8" title="1">{
                                tags = append(tags, tag)
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">return</span>
}

func (rq *Request) TagsOf(elem *Element) (tags []any) <span class="cov8" title="1">{
        if elem != nil </span><span class="cov8" title="1">{
                rq.mu.RLock()
                defer rq.mu.RUnlock()
                tags = rq.tagsOfLocked(elem)
        }</span>
        <span class="cov8" title="1">return</span>
}

// Dirty marks all Elements that have one or more of the given tags as dirty.
func (rq *Request) Dirty(tags ...any) <span class="cov8" title="1">{
        rq.Jaws.setDirty(MustTagExpand(rq, tags))
}</span>

// wantMessage returns true if the Request want the message.
func (rq *Request) wantMessage(msg *Message) (yes bool) <span class="cov8" title="1">{
        switch dest := msg.Dest.(type) </span>{
        case *Request:<span class="cov8" title="1">
                return dest == rq</span>
        case string:<span class="cov8" title="1"> // HTML id
                return true</span>
        case []any:<span class="cov8" title="1"> // more than one tag
                rq.mu.RLock()
                defer rq.mu.RUnlock()
                for i := range dest </span><span class="cov8" title="1">{
                        if _, yes = rq.tagMap[dest[i]]; yes </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
        default:<span class="cov8" title="1">
                rq.mu.RLock()
                _, yes = rq.tagMap[msg.Dest]
                rq.mu.RUnlock()</span>
        }
        <span class="cov8" title="1">return</span>
}

// NextJid is the next Jid that should be used. Used when testing. Do not modify it outside of tests.
var NextJid Jid

func (rq *Request) newElementLocked(ui UI) (elem *Element) <span class="cov8" title="1">{
        elem = &amp;Element{
                jid:     Jid(atomic.AddInt64((*int64)(&amp;NextJid), 1)),
                ui:      ui,
                Request: rq,
        }
        rq.elems = append(rq.elems, elem)
        return
}</span>

// NewElement creates a new Element using the given UI object.
//
// Panics if the build tag "debug" is set and the UI object doesn't satisfy all requirements.
func (rq *Request) NewElement(ui UI) *Element <span class="cov8" title="1">{
        if deadlock.Debug </span><span class="cov8" title="1">{
                if err := newErrNotComparable(ui); err != nil </span><span class="cov8" title="1">{
                        panic(err)</span>
                }
        }
        <span class="cov8" title="1">rq.mu.Lock()
        defer rq.mu.Unlock()
        return rq.newElementLocked(ui)</span>
}

func (rq *Request) GetElementByJid(jid Jid) (e *Element) <span class="cov8" title="1">{
        rq.mu.RLock()
        defer rq.mu.RUnlock()
        e = rq.getElementByJidLocked(jid)
        return
}</span>

func (rq *Request) getElementByJidLocked(jid Jid) (elem *Element) <span class="cov8" title="1">{
        for _, e := range rq.elems </span><span class="cov8" title="1">{
                if e.Jid() == jid </span><span class="cov8" title="1">{
                        elem = e
                        break</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

func (rq *Request) hasTagLocked(elem *Element, tag any) bool <span class="cov8" title="1">{
        for _, e := range rq.tagMap[tag] </span><span class="cov8" title="1">{
                if elem == e </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (rq *Request) HasTag(elem *Element, tag any) (yes bool) <span class="cov8" title="1">{
        rq.mu.RLock()
        yes = rq.hasTagLocked(elem, tag)
        rq.mu.RUnlock()
        return
}</span>

func (rq *Request) appendDirtyTags(tags []any) <span class="cov8" title="1">{
        rq.mu.Lock()
        rq.todoDirt = append(rq.todoDirt, tags...)
        rq.mu.Unlock()
}</span>

// Tag adds the given tags to the given Element.
func (rq *Request) TagExpanded(elem *Element, expandedtags []any) <span class="cov8" title="1">{
        if elem != nil &amp;&amp; !elem.deleted.Load() &amp;&amp; elem.Request == rq </span><span class="cov8" title="1">{
                rq.mu.Lock()
                defer rq.mu.Unlock()
                for _, tag := range expandedtags </span><span class="cov8" title="1">{
                        if !rq.hasTagLocked(elem, tag) </span><span class="cov8" title="1">{
                                rq.tagMap[tag] = append(rq.tagMap[tag], elem)
                        }</span>
                }
        }
}

// Tag adds the given tags to the given Element.
func (rq *Request) Tag(elem *Element, tags ...any) <span class="cov8" title="1">{
        if elem != nil &amp;&amp; len(tags) &gt; 0 &amp;&amp; elem.Request == rq </span><span class="cov8" title="1">{
                rq.TagExpanded(elem, MustTagExpand(elem.Request, tags))
        }</span>
}

// GetElements returns a list of the UI elements in the Request that have the given tag(s).
func (rq *Request) GetElements(tagitem any) (elems []*Element) <span class="cov8" title="1">{
        tags := MustTagExpand(rq, tagitem)
        seen := map[*Element]struct{}{}
        rq.mu.RLock()
        defer rq.mu.RUnlock()
        for _, tag := range tags </span><span class="cov8" title="1">{
                if el, ok := rq.tagMap[tag]; ok </span><span class="cov8" title="1">{
                        for _, e := range el </span><span class="cov8" title="1">{
                                if _, ok = seen[e]; !ok </span><span class="cov8" title="1">{
                                        seen[e] = struct{}{}
                                        elems = append(elems, e)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return</span>
}

// process is the main message processing loop. Will unsubscribe broadcastMsgCh and close outboundMsgCh on exit.
func (rq *Request) process(broadcastMsgCh chan Message, incomingMsgCh &lt;-chan WsMsg, outboundMsgCh chan&lt;- WsMsg) <span class="cov8" title="1">{
        jawsDoneCh := rq.Jaws.Done()
        httpDoneCh := rq.httpDoneCh
        eventDoneCh := make(chan struct{})
        eventCallCh := make(chan eventFnCall, cap(outboundMsgCh))
        go rq.eventCaller(eventCallCh, outboundMsgCh, eventDoneCh)

        defer func() </span><span class="cov8" title="1">{
                rq.Jaws.unsubscribe(broadcastMsgCh)
                rq.killSession()
                rq.cancelFn(nil)
                close(eventCallCh)
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case _, ok := &lt;-incomingMsgCh:<span class="cov8" title="1">
                                if !ok </span><span class="cov8" title="1">{
                                        incomingMsgCh = nil
                                }</span>
                        case &lt;-eventDoneCh:<span class="cov8" title="1">
                                close(outboundMsgCh)
                                if x := recover(); x != nil </span><span class="cov8" title="1">{
                                        var err error
                                        var ok bool
                                        if err, ok = x.(error); !ok </span><span class="cov8" title="1">{
                                                err = fmt.Errorf("jaws: %v panic: %v", rq, x)
                                        }</span>
                                        <span class="cov8" title="1">rq.Jaws.MustLog(err)</span>
                                }
                                <span class="cov8" title="1">return</span>
                        }
                }
        }()

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                var tagmsg Message
                var wsmsg WsMsg
                var ok bool

                rq.sendQueue(outboundMsgCh)

                // Empty the dirty tags list and call JawsUpdate()
                // for identified elements. This queues up wsMsg's
                // in elem.wsQueue.
                for _, elem := range rq.makeUpdateList() </span><span class="cov8" title="1">{
                        elem.JawsUpdate()
                }</span>

                <span class="cov8" title="1">rq.sendQueue(outboundMsgCh)

                select </span>{
                case &lt;-jawsDoneCh:<span class="cov8" title="1"></span>
                case &lt;-httpDoneCh:<span class="cov8" title="1"></span>
                case &lt;-rq.Context().Done():<span class="cov8" title="1"></span>
                case tagmsg, ok = &lt;-broadcastMsgCh:<span class="cov8" title="1"></span>
                case wsmsg, ok = &lt;-incomingMsgCh:<span class="cov8" title="1">
                        if ok </span><span class="cov8" title="1">{
                                // incoming event message from the websocket
                                if wsmsg.Jid.IsValid() </span><span class="cov8" title="1">{
                                        switch wsmsg.What </span>{
                                        case what.Input, what.Click, what.Set:<span class="cov8" title="1">
                                                rq.queueEvent(eventCallCh, eventFnCall{jid: wsmsg.Jid, wht: wsmsg.What, data: wsmsg.Data})</span>
                                        case what.Remove:<span class="cov8" title="1">
                                                rq.handleRemove(wsmsg.Data)</span>
                                        }
                                }
                                <span class="cov8" title="1">continue</span>
                        }
                }

                <span class="cov8" title="1">if !ok </span><span class="cov8" title="1">{
                        // one of the channels are closed, so we're done
                        return
                }</span>

                // collect all elements marked with the tag in the message
                <span class="cov8" title="1">var todo []*Element
                switch v := tagmsg.Dest.(type) </span>{
                case nil:<span class="cov8" title="1"></span>
                        // matches no elements
                case *Request:<span class="cov8" title="1"></span>
                case string:<span class="cov8" title="1">
                        // target is a regular HTML ID
                        data := tagmsg.Data
                        if tagmsg.What != what.Set &amp;&amp; tagmsg.What != what.Call </span><span class="cov8" title="1">{
                                data = strconv.Quote(data)
                        }</span>
                        <span class="cov8" title="1">rq.queue(WsMsg{
                                Data: v + "\t" + data,
                                What: tagmsg.What,
                                Jid:  -1,
                        })</span>
                default:<span class="cov8" title="1">
                        todo = rq.GetElements(v)</span>
                }

                <span class="cov8" title="1">switch tagmsg.What </span>{
                case what.Reload, what.Redirect, what.Order, what.Alert:<span class="cov8" title="1">
                        rq.queue(WsMsg{
                                Jid:  0,
                                Data: tagmsg.Data,
                                What: tagmsg.What,
                        })</span>
                default:<span class="cov8" title="1">
                        for _, elem := range todo </span><span class="cov8" title="1">{
                                switch tagmsg.What </span>{
                                case what.Delete:<span class="cov8" title="1">
                                        rq.queue(WsMsg{
                                                Jid:  elem.Jid(),
                                                What: what.Delete,
                                        })
                                        rq.DeleteElement(elem)</span>
                                case what.Input, what.Click:<span class="cov8" title="1">
                                        // Input or Click messages received here are from Request.Send() or broadcasts.
                                        // they won't be sent out on the WebSocket, but will queue up a
                                        // call to the event function (if any).
                                        // primary usecase is tests.
                                        rq.queueEvent(eventCallCh, eventFnCall{jid: elem.Jid(), wht: tagmsg.What, data: tagmsg.Data})</span>
                                case what.Hook:<span class="cov8" title="1">
                                        // "hook" messages are used to synchronously call an event function.
                                        // the function must not send any messages itself, but may return
                                        // an error to be sent out as an alert message.
                                        // primary usecase is tests.
                                        if err := rq.Jaws.Log(rq.callAllEventHandlers(elem.Jid(), tagmsg.What, tagmsg.Data)); err != nil </span><span class="cov8" title="1">{
                                                var m WsMsg
                                                m.FillAlert(err)
                                                m.Jid = elem.Jid()
                                                rq.queue(m)
                                        }</span>
                                case what.Update:<span class="cov8" title="1">
                                        elem.JawsUpdate()</span>
                                default:<span class="cov8" title="1">
                                        rq.queue(WsMsg{
                                                Data: tagmsg.Data,
                                                Jid:  elem.Jid(),
                                                What: tagmsg.What,
                                        })</span>
                                }
                        }
                }
        }
}

func (rq *Request) handleRemove(data string) <span class="cov8" title="1">{
        rq.mu.Lock()
        defer rq.mu.Unlock()
        for _, jidstr := range strings.Split(data, "\t") </span><span class="cov8" title="1">{
                if e := rq.getElementByJidLocked(jid.ParseString(jidstr)); e != nil </span><span class="cov8" title="1">{
                        rq.deleteElementLocked(e)
                }</span>
        }
}

func (rq *Request) queue(msg WsMsg) <span class="cov8" title="1">{
        rq.muQueue.Lock()
        rq.wsQueue = append(rq.wsQueue, msg)
        rq.muQueue.Unlock()
}</span>

func (rq *Request) callAllEventHandlers(id Jid, wht what.What, val string) (err error) <span class="cov8" title="1">{
        var elems []*Element
        rq.mu.RLock()
        if id == 0 </span><span class="cov8" title="1">{
                if wht == what.Click </span><span class="cov8" title="1">{
                        var after string
                        var found bool
                        val, after, found = strings.Cut(val, "\t")
                        for found </span><span class="cov8" title="1">{
                                var jidStr string
                                jidStr, after, found = strings.Cut(after, "\t")
                                if id = jid.ParseString(jidStr); id &gt; 0 </span><span class="cov8" title="1">{
                                        if e := rq.getElementByJidLocked(id); e != nil &amp;&amp; !e.deleted.Load() </span><span class="cov8" title="1">{
                                                elems = append(elems, e)
                                        }</span>
                                }
                        }
                }
        } else<span class="cov8" title="1"> {
                if e := rq.getElementByJidLocked(id); e != nil &amp;&amp; !e.deleted.Load() </span><span class="cov8" title="1">{
                        elems = append(elems, e)
                }</span>
        }
        <span class="cov8" title="1">rq.mu.RUnlock()

        for _, e := range elems </span><span class="cov8" title="1">{
                if err = CallEventHandlers(e.Ui(), e, wht, val); err != ErrEventUnhandled </span><span class="cov8" title="1">{
                        return
                }</span>
        }
        <span class="cov8" title="1">if err == ErrEventUnhandled </span><span class="cov8" title="1">{
                err = nil
        }</span>
        <span class="cov8" title="1">return</span>
}

func (rq *Request) queueEvent(eventCallCh chan eventFnCall, call eventFnCall) <span class="cov8" title="1">{
        select </span>{
        case eventCallCh &lt;- call:<span class="cov8" title="1"></span>
        default:<span class="cov8" title="1">
                rq.Jaws.MustLog(fmt.Errorf("jaws: %v: eventCallCh is full sending %v", rq, call))
                return</span>
        }
}

func (rq *Request) getSendMsgs() (toSend []WsMsg) <span class="cov8" title="1">{
        rq.mu.RLock()
        defer rq.mu.RUnlock()

        validJids := map[Jid]struct{}{}
        for _, elem := range rq.elems </span><span class="cov8" title="1">{
                if !elem.deleted.Load() </span><span class="cov8" title="1">{
                        validJids[elem.Jid()] = struct{}{}
                }</span>
        }

        <span class="cov8" title="1">rq.muQueue.Lock()
        defer rq.muQueue.Unlock()
        if len(rq.wsQueue) &gt; 0 </span><span class="cov8" title="1">{
                for i := range rq.wsQueue </span><span class="cov8" title="1">{
                        ok := rq.wsQueue[i].Jid &lt; 1 || rq.wsQueue[i].What == what.Delete
                        if !ok </span><span class="cov8" title="1">{
                                _, ok = validJids[rq.wsQueue[i].Jid]
                        }</span>
                        <span class="cov8" title="1">if ok </span><span class="cov8" title="1">{
                                toSend = append(toSend, rq.wsQueue[i])
                        }</span>
                }
                <span class="cov8" title="1">rq.wsQueue = rq.wsQueue[:0]</span>
        }

        <span class="cov8" title="1">slices.SortStableFunc(toSend, func(a, b WsMsg) int </span><span class="cov8" title="1">{ return cmp.Compare(a.Jid, b.Jid) }</span>)
        <span class="cov8" title="1">return</span>
}

func (rq *Request) sendQueue(outboundMsgCh chan&lt;- WsMsg) <span class="cov8" title="1">{
        for _, msg := range rq.getSendMsgs() </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-rq.Context().Done():<span class="cov8" title="1"></span>
                case outboundMsgCh &lt;- msg:<span class="cov8" title="1"></span>
                }
        }
}

func deleteElement(s []*Element, e *Element) []*Element <span class="cov8" title="1">{
        for i, v := range s </span><span class="cov8" title="1">{
                if e == v </span><span class="cov8" title="1">{
                        j := i
                        for i++; i &lt; len(s); i++ </span><span class="cov8" title="1">{
                                v = s[i]
                                if e != v </span><span class="cov8" title="1">{
                                        s[j] = v
                                        j++
                                }</span>
                        }
                        <span class="cov8" title="1">for i := j; i &lt; len(s); i++ </span><span class="cov8" title="1">{
                                s[i] = nil
                        }</span>
                        <span class="cov8" title="1">return s[:j]</span>
                }
        }
        <span class="cov8" title="1">return s</span>
}

func (rq *Request) deleteElementLocked(e *Element) <span class="cov8" title="1">{
        if e.Request == rq </span><span class="cov8" title="1">{
                e.deleted.Store(true)
                rq.elems = deleteElement(rq.elems, e)
                for k := range rq.tagMap </span><span class="cov8" title="1">{
                        rq.tagMap[k] = deleteElement(rq.tagMap[k], e)
                        if len(rq.tagMap[k]) == 0 </span><span class="cov8" title="1">{
                                delete(rq.tagMap, k)
                        }</span>
                }
        }
}

// DeleteElement removes elem from the Request element registry.
//
// This is primarily intended for UI implementations that manage dynamic child
// element sets and need to drop stale elements after issuing a corresponding
// DOM remove operation.
func (rq *Request) DeleteElement(elem *Element) <span class="cov8" title="1">{
        rq.mu.Lock()
        defer rq.mu.Unlock()
        rq.deleteElementLocked(elem)
}</span>

func (rq *Request) makeUpdateList() (todo []*Element) <span class="cov8" title="1">{
        rq.mu.Lock()
        seen := map[*Element]struct{}{}
        for _, tag := range rq.todoDirt </span><span class="cov8" title="1">{
                for _, elem := range rq.tagMap[tag] </span><span class="cov8" title="1">{
                        if _, ok := seen[elem]; !ok </span><span class="cov8" title="1">{
                                seen[elem] = struct{}{}
                                todo = append(todo, elem)
                        }</span>
                }
        }
        <span class="cov8" title="1">clear(rq.todoDirt)
        rq.todoDirt = rq.todoDirt[:0]
        rq.mu.Unlock()
        sort.Slice(todo, func(i, j int) bool </span><span class="cov8" title="1">{ return todo[i].Jid() &lt; todo[j].Jid() }</span>)
        <span class="cov8" title="1">return</span>
}

// eventCaller calls event functions
func (rq *Request) eventCaller(eventCallCh &lt;-chan eventFnCall, outboundMsgCh chan&lt;- WsMsg, eventDoneCh chan&lt;- struct{}) <span class="cov8" title="1">{
        defer close(eventDoneCh)
        for call := range eventCallCh </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-rq.Context().Done():<span class="cov8" title="1">
                        continue</span>
                default:<span class="cov8" title="1"></span>
                }
                <span class="cov8" title="1">if err := rq.callAllEventHandlers(call.jid, call.wht, call.data); err != nil </span><span class="cov8" title="1">{
                        var m WsMsg
                        m.FillAlert(err)
                        select </span>{
                        case outboundMsgCh &lt;- m:<span class="cov8" title="1"></span>
                        default:<span class="cov8" title="1">
                                _ = rq.Jaws.Log(fmt.Errorf("jaws: outboundMsgCh full sending event error '%s'", err.Error()))</span>
                        }
                }
        }
}

// onConnect calls the Request's ConnectFn if it's not nil, and returns the error from it.
// Returns nil if ConnectFn is nil.
func (rq *Request) onConnect() (err error) <span class="cov8" title="1">{
        rq.mu.RLock()
        connectFn := rq.connectFn
        rq.mu.RUnlock()
        if connectFn != nil </span><span class="cov8" title="1">{
                err = connectFn(rq)
        }</span>
        <span class="cov8" title="1">return</span>
}

func (rq *Request) validateWebSocketOrigin(r *http.Request) (err error) <span class="cov8" title="1">{
        err = ErrWebsocketOriginMissing
        if origin := r.Header.Get("Origin"); origin != "" </span><span class="cov8" title="1">{
                var u *url.URL
                if u, err = url.Parse(origin); err == nil </span><span class="cov8" title="1">{
                        if initial := rq.Initial(); initial != nil </span><span class="cov8" title="1">{
                                secure := requestIsSecure(initial)
                                port := ""
                                uhost := u.Host
                                ihost := initial.Host
                                err = ErrWebsocketOriginWrongScheme
                                switch u.Scheme </span>{
                                case "http":<span class="cov8" title="1">
                                        if secure </span><span class="cov8" title="1">{
                                                return
                                        }</span>
                                        <span class="cov8" title="1">port = ":80"</span>
                                case "https":<span class="cov8" title="1">
                                        if !secure </span><span class="cov8" title="1">{
                                                return
                                        }</span>
                                        <span class="cov8" title="1">port = ":443"</span>
                                default:<span class="cov8" title="1">
                                        return</span>
                                }
                                <span class="cov8" title="1">uhost = strings.TrimSuffix(uhost, port)
                                ihost = strings.TrimSuffix(ihost, port)
                                err = ErrWebsocketOriginWrongHost
                                if uhost != "" </span><span class="cov8" title="1">{
                                        // Browser WebSocket requests use the page origin.
                                        // Compare both scheme and host against the initial request.
                                        if strings.EqualFold(uhost, ihost) </span><span class="cov8" title="1">{
                                                err = nil
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">return</span>
}

// MustLog sends an error to the Logger set in the Jaws or
// panics with the given error if no Logger is set.
// Has no effect if the err is nil.
func (rq *Request) MustLog(err error) <span class="cov8" title="1">{
        var jw *Jaws
        if rq != nil </span><span class="cov8" title="1">{
                jw = rq.Jaws
        }</span>
        <span class="cov8" title="1">jw.MustLog(err)</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package core

import "sync"

type RWLocker interface {
        sync.Locker
        RLock()
        RUnlock()
}

type rwlocker struct {
        sync.Locker
}

func (l rwlocker) RLock() <span class="cov8" title="1">{
        l.Lock()
}</span>

func (l rwlocker) RUnlock() <span class="cov8" title="1">{
        l.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package core

import (
        "net/http"
        "strings"
)

var headerCacheNoCache = []string{"no-cache"}

// ServeHTTP can handle the required JaWS endpoints, which all start with "/jaws/".
func (jw *Jaws) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusMethodNotAllowed)
                return
        }</span>
        <span class="cov8" title="1">if len(r.URL.Path) &gt; 6 &amp;&amp; strings.HasPrefix(r.URL.Path, "/jaws/") </span><span class="cov8" title="1">{
                if r.URL.Path[6] == '.' </span><span class="cov8" title="1">{
                        switch r.URL.Path </span>{
                        case jw.serveCSS.Name:<span class="cov8" title="1">
                                jw.serveCSS.ServeHTTP(w, r)
                                return</span>
                        case jw.serveJS.Name:<span class="cov8" title="1">
                                jw.serveJS.ServeHTTP(w, r)
                                return</span>
                        case "/jaws/.ping":<span class="cov8" title="1">
                                w.Header()["Cache-Control"] = headerCacheNoCache
                                select </span>{
                                case &lt;-jw.Done():<span class="cov8" title="1">
                                        w.WriteHeader(http.StatusServiceUnavailable)</span>
                                default:<span class="cov8" title="1">
                                        w.WriteHeader(http.StatusNoContent)</span>
                                }
                                <span class="cov8" title="1">return</span>
                        }
                } else<span class="cov8" title="1"> if rq := jw.UseRequest(JawsKeyValue(r.URL.Path[6:]), r); rq != nil </span><span class="cov8" title="1">{
                        rq.ServeHTTP(w, r)
                        return
                }</span>
        }
        <span class="cov8" title="1">w.WriteHeader(http.StatusNotFound)</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package core

import (
        "net/http"
        "net/netip"
        "time"

        "github.com/linkdata/deadlock"
        "github.com/linkdata/jaws/what"
)

type Session struct {
        jw        *Jaws
        sessionID uint64
        remoteIP  netip.Addr
        mu        deadlock.RWMutex // protects following
        requests  []*Request
        deadline  time.Time
        cookie    http.Cookie
        data      map[string]any
}

func newSession(jw *Jaws, sessionID uint64, remoteIP netip.Addr, secure bool) *Session <span class="cov8" title="1">{
        return &amp;Session{
                jw:        jw,
                sessionID: sessionID,
                remoteIP:  remoteIP,
                deadline:  time.Now().Add(time.Minute),
                cookie: http.Cookie{
                        Name:     jw.CookieName,
                        Path:     "/",
                        Value:    JawsKeyString(sessionID),
                        Secure:   secure,
                        HttpOnly: true,
                        SameSite: http.SameSiteLaxMode,
                },
                data: make(map[string]any),
        }
}</span>

func (sess *Session) isDeadLocked() bool <span class="cov8" title="1">{
        return sess.cookie.MaxAge &lt; 0 || (len(sess.requests) == 0 &amp;&amp; time.Since(sess.deadline) &gt; 0)
}</span>

func (sess *Session) isDead() (yes bool) <span class="cov8" title="1">{
        sess.mu.RLock()
        yes = sess.isDeadLocked()
        sess.mu.RUnlock()
        return
}</span>

func (sess *Session) addRequest(rq *Request) <span class="cov8" title="1">{
        sess.mu.Lock()
        sess.requests = append(sess.requests, rq)
        sess.mu.Unlock()
}</span>

func (sess *Session) delRequest(rq *Request) <span class="cov8" title="1">{
        sess.mu.Lock()
        defer sess.mu.Unlock()
        for i := range sess.requests </span><span class="cov8" title="1">{
                if sess.requests[i] == rq </span><span class="cov8" title="1">{
                        l := len(sess.requests)
                        if l &gt; 1 </span><span class="cov8" title="1">{
                                sess.requests[i] = sess.requests[l-1]
                        }</span>
                        <span class="cov8" title="1">sess.requests = sess.requests[:l-1]
                        break</span>
                }
        }
        <span class="cov8" title="1">if len(sess.requests) == 0 </span><span class="cov8" title="1">{
                sess.deadline = time.Now().Add(time.Minute)
        }</span>
}

// Jaws returns the Jaws instance of the Session, or nil.
// It is safe to call on a nil Session.
func (sess *Session) Jaws() (jw *Jaws) <span class="cov8" title="1">{
        if sess != nil </span><span class="cov8" title="1">{
                jw = sess.jw
        }</span>
        <span class="cov8" title="1">return</span>
}

// Get returns the value associated with the key, or nil.
// It is safe to call on a nil Session.
func (sess *Session) Get(key string) (val any) <span class="cov8" title="1">{
        if sess != nil </span><span class="cov8" title="1">{
                sess.mu.RLock()
                val = sess.data[key]
                sess.mu.RUnlock()
        }</span>
        <span class="cov8" title="1">return</span>
}

// Set sets a value to be associated with the key.
// If value is nil, the key is removed from the session.
// It is safe to call on a nil Session.
func (sess *Session) Set(key string, val any) <span class="cov8" title="1">{
        if sess != nil </span><span class="cov8" title="1">{
                sess.mu.Lock()
                if val == nil </span><span class="cov8" title="1">{
                        delete(sess.data, key)
                }</span> else<span class="cov8" title="1"> {
                        sess.data[key] = val
                }</span>
                <span class="cov8" title="1">sess.mu.Unlock()</span>
        }
}

// ID returns the session ID, a 64-bit random value.
// It is safe to call on a nil Session, in which case it returns zero.
func (sess *Session) ID() (id uint64) <span class="cov8" title="1">{
        if sess != nil </span><span class="cov8" title="1">{
                id = sess.sessionID
        }</span>
        <span class="cov8" title="1">return</span>
}

// CookieValue returns the session cookie value.
// It is safe to call on a nil Session, in which case it returns an empty string.
func (sess *Session) CookieValue() (s string) <span class="cov8" title="1">{
        if sess != nil </span><span class="cov8" title="1">{
                s = sess.cookie.Value
        }</span>
        <span class="cov8" title="1">return</span>
}

// IP returns the remote IP the session is bound to (which may be nil).
// It is safe to call on a nil Session, in which case it returns nil.
func (sess *Session) IP() (ip netip.Addr) <span class="cov8" title="1">{
        if sess != nil </span><span class="cov8" title="1">{
                ip = sess.remoteIP
        }</span>
        <span class="cov8" title="1">return</span>
}

// Cookie returns a cookie for the Session. Returns a delete cookie if the Session is expired.
// It is safe to call on a nil Session, in which case it returns nil.
func (sess *Session) Cookie() (cookie *http.Cookie) <span class="cov8" title="1">{
        if sess != nil </span><span class="cov8" title="1">{
                cookie = &amp;http.Cookie{}
                sess.mu.RLock()
                *cookie = sess.cookie
                if sess.isDeadLocked() </span><span class="cov8" title="1">{
                        cookie.MaxAge = -1
                }</span>
                <span class="cov8" title="1">sess.mu.RUnlock()</span>
        }
        <span class="cov8" title="1">return</span>
}

// Close invalidates and expires the Session.
// Future Requests won't be able to associate with it, and Cookie() will return a deletion cookie.
//
// Existing Requests already associated with the Session will ask the browser to reload the pages.
// Key/value pairs in the Session are left unmodified, you can use `Session.Clear()` to remove all of them.
//
// It must not be called before the JaWS processing loop (`Serve()` or
// `ServeWithTimeout()`) is running, because reload broadcasts may block.
//
// Returns a cookie to be sent to the client browser that will delete the browser cookie.
// Returns nil if the session was not found.
// It is safe to call on a nil Session.
func (sess *Session) Close() (cookie *http.Cookie) <span class="cov8" title="1">{
        if sess != nil </span><span class="cov8" title="1">{
                sess.jw.deleteSession(sess.sessionID)

                sess.mu.Lock()
                sess.cookie.MaxAge = -1
                requests := sess.requests
                sess.requests = nil
                cookie = new(http.Cookie)
                *cookie = sess.cookie
                sess.mu.Unlock()

                msg := Message{What: what.Reload}
                for _, rq := range requests </span><span class="cov8" title="1">{
                        rq.deadSession(sess)
                        msg.Dest = rq
                        sess.jw.Broadcast(msg)
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// Reload calls Broadcast with a message asking browsers to reload the page.
// See Broadcast for the processing-loop requirement.
func (sess *Session) Reload() <span class="cov8" title="1">{
        sess.Broadcast(Message{What: what.Reload})
}</span>

// Clear removes all key/value pairs from the session.
// It is safe to call on a nil Session.
func (sess *Session) Clear() <span class="cov8" title="1">{
        if sess != nil </span><span class="cov8" title="1">{
                sess.mu.Lock()
                clear(sess.data)
                sess.mu.Unlock()
        }</span>
}

// Requests returns a list of the Requests using this Session.
// It is safe to call on a nil Session.
func (sess *Session) Requests() (rl []*Request) <span class="cov8" title="1">{
        if sess != nil </span><span class="cov8" title="1">{
                sess.mu.RLock()
                rl = append(rl, sess.requests...)
                sess.mu.RUnlock()
        }</span>
        <span class="cov8" title="1">return</span>
}

// Broadcast attempts to send a message to all Requests using this session.
//
// It must not be called before the JaWS processing loop (`Serve()` or
// `ServeWithTimeout()`) is running. Otherwise this call may block.
// It is safe to call on a nil Session.
func (sess *Session) Broadcast(msg Message) <span class="cov8" title="1">{
        if sess != nil </span><span class="cov8" title="1">{
                sess.mu.RLock()
                defer sess.mu.RUnlock()
                for _, rq := range sess.requests </span><span class="cov8" title="1">{
                        msg.Dest = rq
                        sess.jw.Broadcast(msg)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package core

import "net/http"

type sessioner struct {
        jw *Jaws
        h  http.Handler
}

func (sess sessioner) ServeHTTP(wr http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if sess.jw.GetSession(r) == nil </span><span class="cov8" title="1">{
                sess.jw.newSession(wr, r)
        }</span>
        <span class="cov8" title="1">sess.h.ServeHTTP(wr, r)</span>
}

// Session returns a http.Handler that ensures a JaWS Session exists before invoking h.
func (jw *Jaws) Session(h http.Handler) http.Handler <span class="cov8" title="1">{
        return sessioner{jw: jw, h: h}
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package core

import (
        "fmt"
)

type Setter[T comparable] interface {
        Getter[T]
        // JawsSet may return ErrValueUnchanged to indicate value was already set.
        JawsSet(elem *Element, value T) (err error)
}

type setterReadOnly[T comparable] struct {
        Getter[T]
}

func (setterReadOnly[T]) JawsSet(*Element, T) error <span class="cov8" title="1">{
        return ErrValueNotSettable
}</span>

func (s setterReadOnly[T]) JawsGetTag(*Request) any <span class="cov8" title="1">{
        return s.Getter
}</span>

type setterStatic[T comparable] struct {
        v T
}

func (setterStatic[T]) JawsSet(*Element, T) error <span class="cov8" title="1">{
        return ErrValueNotSettable
}</span>

func (s setterStatic[T]) JawsGet(*Element) T <span class="cov8" title="1">{
        return s.v
}</span>

func (s setterStatic[T]) JawsGetTag(*Request) any <span class="cov8" title="1">{
        return nil
}</span>

func MakeSetter[T comparable](v any) Setter[T] <span class="cov8" title="1">{
        switch v := v.(type) </span>{
        case Setter[T]:<span class="cov8" title="1">
                return v</span>
        case Getter[T]:<span class="cov8" title="1">
                return setterReadOnly[T]{v}</span>
        case T:<span class="cov8" title="1">
                return setterStatic[T]{v}</span>
        }
        <span class="cov8" title="1">var blank T
        panic(fmt.Errorf("expected jaws.Setter[%T], jaws.Getter[%T] or %T not %T", blank, blank, blank, v))</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package core

import (
        "fmt"
)

type numeric interface {
        ~float32 | ~float64 |
                ~int | ~int8 | ~int16 | ~int32 | ~int64 |
                ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64
}

type SetterFloat64[T numeric] interface {
        Getter[T]
        // JawsSet may return ErrValueUnchanged to indicate value was already set.
        JawsSet(elem *Element, value T) (err error)
}

type setterFloat64[T numeric] struct {
        Setter[T]
}

func (s setterFloat64[T]) JawsGet(e *Element) float64 <span class="cov8" title="1">{
        v := s.Setter.JawsGet(e)
        return float64(v)
}</span>

func (s setterFloat64[T]) JawsSet(e *Element, v float64) error <span class="cov8" title="1">{
        return s.Setter.JawsSet(e, T(v))
}</span>

func (s setterFloat64[T]) JawsGetTag(*Request) any <span class="cov8" title="1">{
        return s.Setter
}</span>

type setterFloat64ReadOnly[T numeric] struct {
        Getter[T]
}

func (s setterFloat64ReadOnly[T]) JawsGet(e *Element) float64 <span class="cov8" title="1">{
        v := s.Getter.JawsGet(e)
        return float64(v)
}</span>

func (setterFloat64ReadOnly[T]) JawsSet(*Element, float64) error <span class="cov8" title="1">{
        return ErrValueNotSettable
}</span>

func (s setterFloat64ReadOnly[T]) JawsGetTag(*Request) any <span class="cov8" title="1">{
        return s.Getter
}</span>

type setterFloat64Static[T numeric] struct {
        v float64
}

func (setterFloat64Static[T]) JawsSet(*Element, float64) error <span class="cov8" title="1">{
        return ErrValueNotSettable
}</span>

func (s setterFloat64Static[T]) JawsGet(*Element) float64 <span class="cov8" title="1">{
        return s.v
}</span>

func (s setterFloat64Static[T]) JawsGetTag(*Request) any <span class="cov8" title="1">{
        return nil
}</span>

func makeSetterFloat64for[T numeric](s *Setter[float64], v any) bool <span class="cov8" title="1">{
        switch v := v.(type) </span>{
        case Setter[T]:<span class="cov8" title="1">
                *s = setterFloat64[T]{Setter: v}
                return true</span>
        case Getter[T]:<span class="cov8" title="1">
                *s = setterFloat64ReadOnly[T]{Getter: v}
                return true</span>
        case T:<span class="cov8" title="1">
                *s = setterFloat64Static[T]{float64(v)}
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

func MakeSetterFloat64(v any) (s Setter[float64]) <span class="cov8" title="1">{
        switch v := v.(type) </span>{
        case Setter[float64]:<span class="cov8" title="1">
                return v</span>
        case Getter[float64]:<span class="cov8" title="1">
                return setterReadOnly[float64]{v}</span>
        case float64:<span class="cov8" title="1">
                return setterStatic[float64]{v}</span>
        default:<span class="cov8" title="1">
                var ok bool
                ok = ok || makeSetterFloat64for[int64](&amp;s, v)
                ok = ok || makeSetterFloat64for[uint64](&amp;s, v)
                ok = ok || makeSetterFloat64for[int](&amp;s, v)
                ok = ok || makeSetterFloat64for[uint](&amp;s, v)
                ok = ok || makeSetterFloat64for[int32](&amp;s, v)
                ok = ok || makeSetterFloat64for[uint32](&amp;s, v)
                ok = ok || makeSetterFloat64for[int8](&amp;s, v)
                ok = ok || makeSetterFloat64for[int16](&amp;s, v)
                ok = ok || makeSetterFloat64for[uint8](&amp;s, v)
                ok = ok || makeSetterFloat64for[uint16](&amp;s, v)
                ok = ok || makeSetterFloat64for[float32](&amp;s, v)
                if ok </span><span class="cov8" title="1">{
                        return
                }</span>
        }
        <span class="cov8" title="1">panic(fmt.Errorf("expected jaws.Setter[float64], jaws.Getter[float64] or float64 not %T", v))</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package core

import (
        "errors"
        "fmt"
        "net/http"
        "net/url"
        "path"

        "github.com/linkdata/jaws/staticserve"
)

// HandleFunc matches the signature of http.ServeMux.Handle(), but is called without
// method or parameters for the pattern. E.g. ("/static/filename.1234567.js").
type HandleFunc = func(uri string, handler http.Handler)

// SetupFunc is called by Setup and allows setting up addons for JaWS.
//
// The urls returned will be used in a call to GenerateHeadHTML.
type SetupFunc = func(jw *Jaws, handleFn HandleFunc, prefix string) (urls []*url.URL, err error)

// makeAbsPath prepends the prefix to u's path if it is relative.
// Returns the (possibly modified) u.
func makeAbsPath(prefix string, u *url.URL) *url.URL <span class="cov8" title="1">{
        if prefix != "" &amp;&amp; u != nil </span><span class="cov8" title="1">{
                if !path.IsAbs(u.Path) </span><span class="cov8" title="1">{
                        u.Path = path.Join(prefix, u.Path)
                }</span>
        }
        <span class="cov8" title="1">return u</span>
}

// Setup configures Jaws with extra functionality and resources.
//
// The list of extras can be strings, *url.URL or *staticserve.StaticServe (URL resources)
// or a setup function matching jaws.JawsSetupFunc like jawsboot.JawsSetup.
//
// It calls GenerateHeadHTML with the final list of URLs, with any
// relative URL paths prefixed with prefix.
func (jw *Jaws) Setup(handleFn HandleFunc, prefix string, extras ...any) (err error) <span class="cov8" title="1">{
        var urls []*url.URL

        handleStaticServe := func(ss *staticserve.StaticServe) </span><span class="cov8" title="1">{
                u, uerr := url.Parse(ss.Name)
                err = errors.Join(err, uerr)
                if u != nil </span><span class="cov8" title="1">{
                        u = makeAbsPath(prefix, u)
                        urls = append(urls, u)
                        if handleFn != nil </span><span class="cov8" title="1">{
                                handleFn(u.String(), ss)
                        }</span>
                }
        }

        <span class="cov8" title="1">for _, extra := range extras </span><span class="cov8" title="1">{
                switch extra := extra.(type) </span>{
                case []*staticserve.StaticServe:<span class="cov8" title="1">
                        for _, ss := range extra </span><span class="cov8" title="1">{
                                handleStaticServe(ss)
                        }</span>
                case string:<span class="cov8" title="1">
                        u, uerr := url.Parse(extra)
                        err = errors.Join(err, uerr)
                        urls = append(urls, makeAbsPath(prefix, u))</span>
                case *url.URL:<span class="cov8" title="1">
                        urls = append(urls, makeAbsPath(prefix, extra))</span>
                case *staticserve.StaticServe:<span class="cov8" title="1">
                        handleStaticServe(extra)</span>
                case SetupFunc:<span class="cov8" title="1">
                        setupurls, setuperr := extra(jw, handleFn, prefix)
                        err = errors.Join(err, setuperr)
                        for _, u := range setupurls </span><span class="cov8" title="1">{
                                urls = append(urls, makeAbsPath(prefix, u))
                        }</span>
                default:<span class="cov8" title="1">
                        panic(fmt.Sprintf("expected a string, *url.URL, *staticserve.StaticServe or jaws.SetupFunc, not %T", extra))</span>
                }
        }
        <span class="cov8" title="1">var extraFiles []string
        for _, u := range urls </span><span class="cov8" title="1">{
                if u != nil </span><span class="cov8" title="1">{
                        extraFiles = append(extraFiles, u.String())
                }</span>
        }
        <span class="cov8" title="1">err = errors.Join(err, jw.GenerateHeadHTML(extraFiles...))
        return</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package core

type stringGetterFunc struct {
        fn   func(*Element) string
        tags []any
}

func (g *stringGetterFunc) JawsGet(e *Element) string <span class="cov8" title="1">{
        return g.fn(e)
}</span>

func (g *stringGetterFunc) JawsGetTag(e *Request) any <span class="cov8" title="1">{
        return g.tags
}</span>

// StringGetterFunc wraps a function and returns a Getter[string]
func StringGetterFunc(fn func(elem *Element) (s string), tags ...any) Getter[string] <span class="cov8" title="1">{
        return &amp;stringGetterFunc{fn: fn, tags: tags}
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package core

import (
        "fmt"
        "html/template"
        "reflect"
)

type Tag string

func TagString(tag any) string <span class="cov8" title="1">{
        if rv := reflect.ValueOf(tag); rv.IsValid() </span><span class="cov8" title="1">{
                if rv.Kind() == reflect.Pointer </span><span class="cov8" title="1">{
                        return fmt.Sprintf("%T(%p)", tag, tag)
                }</span> else<span class="cov8" title="1"> if stringer, ok := tag.(fmt.Stringer); ok </span><span class="cov8" title="1">{
                        return fmt.Sprintf("%T(%s)", tag, stringer.String())
                }</span>
        }
        <span class="cov8" title="1">return fmt.Sprintf("%#v", tag)</span>
}

type errTooManyTags struct{}

func (errTooManyTags) Error() string <span class="cov8" title="1">{
        return "too many tags"
}</span>

var ErrTooManyTags = errTooManyTags{}

func tagExpand(l int, rq *Request, tag any, result []any) ([]any, error) <span class="cov8" title="1">{
        if l &gt; 10 || len(result) &gt; 100 </span><span class="cov8" title="1">{
                return result, ErrTooManyTags
        }</span>
        <span class="cov8" title="1">switch data := tag.(type) </span>{
        case string:<span class="cov8" title="1"></span>
        case template.HTML:<span class="cov8" title="1"></span>
        case template.HTMLAttr:<span class="cov8" title="1"></span>
        case int:<span class="cov8" title="1"></span>
        case int8:<span class="cov8" title="1"></span>
        case int16:<span class="cov8" title="1"></span>
        case int32:<span class="cov8" title="1"></span>
        case int64:<span class="cov8" title="1"></span>
        case uint:<span class="cov8" title="1"></span>
        case uint8:<span class="cov8" title="1"></span>
        case uint16:<span class="cov8" title="1"></span>
        case uint32:<span class="cov8" title="1"></span>
        case uint64:<span class="cov8" title="1"></span>
        case float32:<span class="cov8" title="1"></span>
        case float64:<span class="cov8" title="1"></span>
        case bool:<span class="cov8" title="1"></span>

        case nil:<span class="cov8" title="1">
                return result, nil</span>
        case []Tag:<span class="cov8" title="1">
                for _, v := range data </span><span class="cov8" title="1">{
                        result = append(result, v)
                }</span>
                <span class="cov8" title="1">return result, nil</span>
        case TagGetter:<span class="cov8" title="1">
                newTag := data.JawsGetTag(rq)
                if reflect.TypeOf(data) == reflect.TypeOf(newTag) </span><span class="cov8" title="1">{
                        if err := newErrNotComparable(newTag); err != nil </span><span class="cov8" title="1">{
                                return result, err
                        }</span>
                        <span class="cov8" title="1">if data == newTag </span><span class="cov8" title="1">{
                                return append(result, data), nil
                        }</span>
                }
                <span class="cov8" title="1">return tagExpand(l+1, rq, newTag, result)</span>
        case []any:<span class="cov8" title="1">
                var err error
                for _, v := range data </span><span class="cov8" title="1">{
                        if result, err = tagExpand(l+1, rq, v, result); err != nil </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">return result, err</span>
        default:<span class="cov8" title="1">
                if err := newErrNotComparable(data); err != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>
                <span class="cov8" title="1">return append(result, data), nil</span>
        }
        <span class="cov8" title="1">return result, errIllegalTagType{tag: tag}</span>
}

func TagExpand(rq *Request, tag any) ([]any, error) <span class="cov8" title="1">{
        return tagExpand(0, rq, tag, nil)
}</span>

func MustTagExpand(rq *Request, tag any) []any <span class="cov8" title="1">{
        result, err := TagExpand(rq, tag)
        rq.MustLog(err)
        return result
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package core

import (
        "bytes"
        "html/template"
        "net/http"
        "net/http/httptest"
        "strings"
)

// TestRequest is a request harness intended for tests.
//
// Exposed for testing only.
type TestRequest struct {
        *Request
        *httptest.ResponseRecorder
        ReadyCh     chan struct{}
        DoneCh      chan struct{}
        InCh        chan WsMsg
        OutCh       chan WsMsg
        BcastCh     chan Message
        ExpectPanic bool
        Panicked    bool
        PanicVal    any
}

// NewTestRequest creates a TestRequest for use when testing.
// Passing nil for hr will create a "GET /" request with no body.
//
// Exposed for testing only.
func NewTestRequest(jw *Jaws, hr *http.Request) (tr *TestRequest) <span class="cov8" title="1">{
        if hr == nil </span><span class="cov8" title="1">{
                hr = httptest.NewRequest(http.MethodGet, "/", nil)
        }</span>
        <span class="cov8" title="1">rr := httptest.NewRecorder()
        rr.Body = &amp;bytes.Buffer{}
        rq := jw.NewRequest(hr)
        if rq != nil &amp;&amp; jw.UseRequest(rq.JawsKey, hr) == rq </span><span class="cov8" title="1">{
                bcastCh := jw.subscribe(rq, 64)
                for i := 0; i &lt;= cap(jw.subCh); i++ </span><span class="cov8" title="1">{
                        jw.subCh &lt;- subscription{} // ensure subscription is processed
                }</span>

                <span class="cov8" title="1">tr = &amp;TestRequest{
                        ReadyCh:          make(chan struct{}),
                        DoneCh:           make(chan struct{}),
                        InCh:             make(chan WsMsg),
                        OutCh:            make(chan WsMsg, cap(bcastCh)),
                        BcastCh:          bcastCh,
                        Request:          rq,
                        ResponseRecorder: rr,
                }

                go func() </span><span class="cov8" title="1">{
                        defer func() </span><span class="cov8" title="1">{
                                if tr.ExpectPanic </span><span class="cov8" title="1">{
                                        if tr.PanicVal = recover(); tr.PanicVal != nil </span><span class="cov8" title="1">{
                                                tr.Panicked = true
                                        }</span>
                                }
                                <span class="cov8" title="1">close(tr.DoneCh)</span>
                        }()
                        <span class="cov8" title="1">close(tr.ReadyCh)
                        tr.process(tr.BcastCh, tr.InCh, tr.OutCh) // unsubs from bcast, closes outCh
                        jw.recycle(tr.Request)</span>
                }()
        }

        <span class="cov8" title="1">return</span>
}

func (tr *TestRequest) Close() <span class="cov8" title="1">{
        close(tr.InCh)
}</span>

func (tr *TestRequest) BodyString() string <span class="cov8" title="1">{
        return strings.TrimSpace(tr.Body.String())
}</span>

func (tr *TestRequest) BodyHTML() template.HTML <span class="cov8" title="1">{
        return template.HTML(tr.BodyString()) /* #nosec G203 */
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package core

import (
        "html/template"
        "io"
        "strconv"

        "github.com/linkdata/jaws/jid"
)

var singletonTags = map[string]struct{}{
        "area":    {},
        "base":    {},
        "br":      {},
        "col":     {},
        "command": {},
        "embed":   {},
        "hr":      {},
        "img":     {},
        "input":   {},
        "keygen":  {},
        "link":    {},
        "meta":    {},
        "param":   {},
        "source":  {},
        "track":   {},
        "wbr":     {},
}

func needClosingTag(tag string) bool <span class="cov8" title="1">{
        _, ok := singletonTags[tag]
        return !ok
}</span>

func appendAttrs(b []byte, attrs []template.HTMLAttr) []byte <span class="cov8" title="1">{
        for _, s := range attrs </span><span class="cov8" title="1">{
                if s != "" </span><span class="cov8" title="1">{
                        b = append(b, ' ')
                        b = append(b, s...)
                }</span>
        }
        <span class="cov8" title="1">return b</span>
}

func WriteHTMLTag(w io.Writer, jid jid.Jid, htmlTag, typeAttr, valueAttr string, attrs []template.HTMLAttr) (err error) <span class="cov8" title="1">{
        b := jid.AppendStartTagAttr(nil, htmlTag)
        if typeAttr != "" </span><span class="cov8" title="1">{
                b = append(b, ` type=`...)
                b = strconv.AppendQuote(b, typeAttr)
        }</span>
        <span class="cov8" title="1">if valueAttr != "" </span><span class="cov8" title="1">{
                b = append(b, ` value=`...)
                b = strconv.AppendQuote(b, valueAttr)
        }</span>
        <span class="cov8" title="1">b = appendAttrs(b, attrs)
        b = append(b, '&gt;')
        _, err = w.Write(b)
        return</span>
}

func WriteHTMLInput(w io.Writer, jid jid.Jid, typeAttr, valueAttr string, attrs []template.HTMLAttr) (err error) <span class="cov8" title="1">{
        return WriteHTMLTag(w, jid, "input", typeAttr, valueAttr, attrs)
}</span>

func WriteHTMLInner(w io.Writer, jid jid.Jid, htmlTag, typeAttr string, innerHTML template.HTML, attrs ...template.HTMLAttr) (err error) <span class="cov8" title="1">{
        if err = WriteHTMLTag(w, jid, htmlTag, typeAttr, "", attrs); err == nil </span><span class="cov8" title="1">{
                if innerHTML != "" || needClosingTag(htmlTag) </span><span class="cov8" title="1">{
                        var b []byte
                        b = append(b, innerHTML...)
                        b = append(b, "&lt;/"...)
                        b = append(b, htmlTag...)
                        b = append(b, '&gt;')
                        _, err = w.Write(b)
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func WriteHTMLSelect(w io.Writer, jid jid.Jid, nba *NamedBoolArray, attrs []template.HTMLAttr) (err error) <span class="cov8" title="1">{
        if err = WriteHTMLTag(w, jid, "select", "", "", attrs); err == nil </span><span class="cov8" title="1">{
                var b []byte
                nba.ReadLocked(func(nba []*NamedBool) </span><span class="cov8" title="1">{
                        for _, nb := range nba </span><span class="cov8" title="1">{
                                b = append(b, "\n&lt;option value="...)
                                b = strconv.AppendQuote(b, nb.Name())
                                if nb.Checked() </span><span class="cov8" title="1">{
                                        b = append(b, ` selected`...)
                                }</span>
                                <span class="cov8" title="1">b = append(b, '&gt;')
                                b = append(b, nb.HTML()...)
                                b = append(b, "&lt;/option&gt;"...)</span>
                        }
                })
                <span class="cov8" title="1">b = append(b, "\n&lt;/select&gt;"...)
                _, err = w.Write(b)</span>
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package core

import (
        "context"
        "errors"
        "io"
        "net/http"
        "strings"

        "github.com/coder/websocket"
)

func (rq *Request) startServe() (ok bool) <span class="cov8" title="1">{
        return rq.claimed.Load() &amp;&amp; rq.running.CompareAndSwap(false, true)
}</span>

func (rq *Request) stopServe() <span class="cov8" title="1">{
        rq.cancel(nil)
        rq.Jaws.recycle(rq)
}</span>

// ServeHTTP implements http.HanderFunc.
//
// Requires UseRequest() have been successfully called for the Request.
func (rq *Request) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if rq.startServe() </span><span class="cov8" title="1">{
                defer rq.stopServe()
                if strings.HasSuffix(r.URL.Path, "/noscript") </span><span class="cov8" title="1">{
                        w.WriteHeader(http.StatusNoContent)
                        rq.cancel(ErrJavascriptDisabled)
                        return
                }</span>
                <span class="cov8" title="1">var err error
                if r.Header.Get("Sec-WebSocket-Key") != "" </span><span class="cov8" title="1">{
                        if err = rq.validateWebSocketOrigin(r); err != nil </span><span class="cov8" title="1">{
                                http.Error(w, http.StatusText(http.StatusForbidden), http.StatusForbidden)
                                rq.cancel(err)
                                return
                        }</span>
                }
                <span class="cov8" title="1">var ws *websocket.Conn
                ws, err = websocket.Accept(w, r, nil)
                if err == nil </span><span class="cov8" title="1">{
                        if err = rq.onConnect(); err == nil </span><span class="cov8" title="1">{
                                incomingMsgCh := make(chan WsMsg)
                                broadcastMsgCh := rq.Jaws.subscribe(rq, 4+len(rq.elems)*4)
                                outboundMsgCh := make(chan WsMsg, cap(broadcastMsgCh))
                                go wsReader(rq.ctx, rq.cancelFn, rq.Jaws.Done(), incomingMsgCh, ws) // closes incomingMsgCh
                                go wsWriter(rq.ctx, rq.cancelFn, rq.Jaws.Done(), outboundMsgCh, ws) // calls ws.Close()
                                rq.process(broadcastMsgCh, incomingMsgCh, outboundMsgCh)            // unsubscribes broadcastMsgCh, closes outboundMsgCh
                        }</span> else<span class="cov8" title="1"> {
                                defer ws.Close(websocket.StatusNormalClosure, err.Error())
                                var msg WsMsg
                                msg.FillAlert(rq.Jaws.Log(err))
                                _ = ws.Write(r.Context(), websocket.MessageText, msg.Append(nil))
                        }</span>
                }
                <span class="cov8" title="1">rq.cancel(err)</span>
        }
}

// wsReader reads websocket text messages, parses them and sends them on incomingMsgCh.
//
// Closes incomingMsgCh on exit.
func wsReader(ctx context.Context, ccf context.CancelCauseFunc, jawsDoneCh &lt;-chan struct{}, incomingMsgCh chan&lt;- WsMsg, ws *websocket.Conn) <span class="cov8" title="1">{
        var typ websocket.MessageType
        var txt []byte
        var err error
        defer close(incomingMsgCh)
        for err == nil </span><span class="cov8" title="1">{
                if typ, txt, err = ws.Read(ctx); typ == websocket.MessageText </span><span class="cov8" title="1">{
                        if msg, ok := wsParse(txt); ok </span><span class="cov8" title="1">{
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov8" title="1">
                                        return</span>
                                case &lt;-jawsDoneCh:<span class="cov8" title="1">
                                        return</span>
                                case incomingMsgCh &lt;- msg:<span class="cov8" title="1"></span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">if ccf != nil </span><span class="cov8" title="1">{
                ccf(err)
        }</span>
}

// wsWriter reads JaWS messages from outboundMsgCh, formats them and writes them to the websocket.
//
// Closes the websocket on exit.
func wsWriter(ctx context.Context, ccf context.CancelCauseFunc, jawsDoneCh &lt;-chan struct{}, outboundMsgCh &lt;-chan WsMsg, ws *websocket.Conn) <span class="cov8" title="1">{
        defer ws.Close(websocket.StatusNormalClosure, "")
        var err error
        for err == nil </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-jawsDoneCh:<span class="cov8" title="1">
                        return</span>
                case msg, ok := &lt;-outboundMsgCh:<span class="cov8" title="1">
                        if !ok </span><span class="cov8" title="1">{
                                return
                        }</span>
                        <span class="cov8" title="1">var wc io.WriteCloser
                        if wc, err = ws.Writer(ctx, websocket.MessageText); err == nil </span><span class="cov8" title="1">{
                                err = wsWriteData(wc, msg, outboundMsgCh)
                        }</span>
                }
        }
        <span class="cov8" title="1">if ccf != nil </span><span class="cov8" title="1">{
                ccf(err)
        }</span>
}

func wsWriteData(wc io.WriteCloser, firstMsg WsMsg, outboundMsgCh &lt;-chan WsMsg) (err error) <span class="cov8" title="1">{
        b := firstMsg.Append(nil)
        // accumulate data to send as long as more messages
        // are available until it exceeds 32K
batchloop:
        for len(b) &lt; 32*1024 </span><span class="cov8" title="1">{
                select </span>{
                case msg, ok := &lt;-outboundMsgCh:<span class="cov8" title="1">
                        if !ok </span><span class="cov8" title="1">{
                                break batchloop</span>
                        }
                        <span class="cov8" title="1">b = msg.Append(b)</span>
                default:<span class="cov8" title="1">
                        break batchloop</span>
                }
        }
        <span class="cov8" title="1">_, err = wc.Write(b)
        err = errors.Join(err, wc.Close())
        return</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package core

import (
        "bytes"
        "html"
        "strconv"
        "strings"

        "github.com/linkdata/jaws/jid"
        "github.com/linkdata/jaws/what"
)

// WsMsg is a message sent to or from a WebSocket.
type WsMsg struct {
        Data string    // data to send
        Jid  Jid       // Jid to send, or -1 if Data contains that already
        What what.What // command
}

func (m *WsMsg) Append(b []byte) []byte <span class="cov8" title="1">{
        b = append(b, m.What.String()...)
        b = append(b, '\t')
        if m.Jid &gt;= 0 </span><span class="cov8" title="1">{
                if m.Jid &gt; 0 </span><span class="cov8" title="1">{
                        b = m.Jid.Append(b)
                }</span>
                <span class="cov8" title="1">b = append(b, '\t')
                switch m.What </span>{
                case what.Set, what.Call:<span class="cov8" title="1">
                        b = append(b, m.Data...)</span>
                default:<span class="cov8" title="1">
                        b = strconv.AppendQuote(b, m.Data)</span>
                }
        } else<span class="cov8" title="1"> {
                b = append(b, m.Data...)
        }</span>
        <span class="cov8" title="1">b = append(b, '\n')
        return b</span>
}

func (m *WsMsg) Format() string <span class="cov8" title="1">{
        return string(m.Append(nil))
}</span>

// wsParse parses an incoming text buffer into a message.
func wsParse(txt []byte) (WsMsg, bool) <span class="cov8" title="1">{
        if len(txt) &gt; 2 &amp;&amp; txt[len(txt)-1] == '\n' </span><span class="cov8" title="1">{
                if nl1 := bytes.IndexByte(txt, '\t'); nl1 &gt;= 0 </span><span class="cov8" title="1">{
                        if nl2 := bytes.IndexByte(txt[nl1+1:], '\t'); nl2 &gt;= 0 </span><span class="cov8" title="1">{
                                nl2 += nl1 + 1
                                // What       ... Jid              ... Data                  ... EOL
                                // txt[0:nl1] ... txt[nl1+1 : nl2] ... txt[nl2+1:len(txt)-1] ... \n
                                if wht := what.Parse(string(txt[0:nl1])); wht.IsValid() </span><span class="cov8" title="1">{
                                        if id := jid.ParseString(string(txt[nl1+1 : nl2])); id.IsValid() </span><span class="cov8" title="1">{
                                                data := string(txt[nl2+1 : len(txt)-1])
                                                if txt[nl2+1] == '"' &amp;&amp; wht != what.Set &amp;&amp; wht != what.Call </span><span class="cov8" title="1">{
                                                        var err error
                                                        if data, err = strconv.Unquote(data); err != nil </span><span class="cov8" title="1">{
                                                                return WsMsg{}, false
                                                        }</span>
                                                }
                                                <span class="cov8" title="1">return WsMsg{
                                                        Data: strings.ToValidUTF8(data, ""),
                                                        Jid:  id,
                                                        What: wht,
                                                }, true</span>
                                        }
                                }
                        }
                }
        }
        <span class="cov8" title="1">return WsMsg{}, false</span>
}

func (m *WsMsg) FillAlert(err error) <span class="cov8" title="1">{
        m.Jid = 0
        m.What = what.Alert
        m.Data = "danger\n" + html.EscapeString(err.Error())
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package jaws

import (
        "sync"
        "time"

        "github.com/linkdata/jaws/core"
        "github.com/linkdata/jaws/jid"
        "github.com/linkdata/jaws/ui"
)

// The point of this is to not have a zillion files in the repository root
// while keeping the import path unchanged.
//
// Most exports use direct assignment to avoid wrapper overhead.
// Generic functions must be wrapped since they cannot be assigned without instantiation.

type (
        Jid                  = jid.Jid
        Jaws                 = core.Jaws
        Request              = core.Request
        Element              = core.Element
        UI                   = core.UI
        Updater              = core.Updater
        Renderer             = core.Renderer
        TemplateLookuper     = core.TemplateLookuper
        HandleFunc           = core.HandleFunc
        Formatter            = core.Formatter
        Auth                 = core.Auth
        InitHandler          = core.InitHandler
        ClickHandler         = core.ClickHandler
        EventHandler         = core.EventHandler
        SelectHandler        = core.SelectHandler
        Container            = core.Container
        Getter[T comparable] = core.Getter[T]
        Setter[T comparable] = core.Setter[T]
        Binder[T comparable] = core.Binder[T]
        HTMLGetter           = core.HTMLGetter
        Logger               = core.Logger
        RWLocker             = core.RWLocker
        TagGetter            = core.TagGetter
        NamedBool            = core.NamedBool
        NamedBoolArray       = core.NamedBoolArray
        Session              = core.Session
        Tag                  = core.Tag
        TestRequest          = core.TestRequest
)

var (
        ErrEventUnhandled        = core.ErrEventUnhandled
        ErrIllegalTagType        = core.ErrIllegalTagType // ErrIllegalTagType is returned when a UI tag type is disallowed
        ErrNotComparable         = core.ErrNotComparable
        ErrNoWebSocketRequest    = core.ErrNoWebSocketRequest
        ErrPendingCancelled      = core.ErrPendingCancelled
        ErrValueUnchanged        = core.ErrValueUnchanged
        ErrValueNotSettable      = core.ErrValueNotSettable
        ErrRequestAlreadyClaimed = core.ErrRequestAlreadyClaimed
        ErrJavascriptDisabled    = core.ErrJavascriptDisabled
        ErrTooManyTags           = core.ErrTooManyTags
)

const (
        ISO8601 = core.ISO8601
)

// Non-generic function assignments (no wrapper overhead)
var (
        New               = core.New
        JawsKeyString     = core.JawsKeyString
        WriteHTMLTag      = core.WriteHTMLTag
        HTMLGetterFunc    = core.HTMLGetterFunc
        StringGetterFunc  = core.StringGetterFunc
        MakeHTMLGetter    = core.MakeHTMLGetter
        NewNamedBool      = core.NewNamedBool
        NewNamedBoolArray = core.NewNamedBoolArray
        NewTestRequest    = core.NewTestRequest
)

// Generic functions must be wrapped
func Bind[T comparable](l sync.Locker, p *T) Binder[T] <span class="cov8" title="1">{
        return core.Bind(l, p)
}</span>

/*
        The following should no longer be accessed using jaws.X,
        but should instead be ui.X.

        Mark as deprecated.
*/

// Template is an alias for ui.Template.
//
// Deprecated: use ui.Template directly.
type Template = ui.Template

// RequestWriter is an alias for ui.RequestWriter.
//
// Deprecated: use ui.RequestWriter directly.
type RequestWriter = ui.RequestWriter

// PathSetter is an alias for ui.PathSetter.
//
// Deprecated: use ui.PathSetter directly.
type PathSetter = ui.PathSetter

// SetPather is an alias for ui.SetPather.
//
// Deprecated: use ui.SetPather directly.
type SetPather = ui.SetPather

// JsVar is an alias for ui.JsVar.
//
// Deprecated: use ui.JsVar directly.
type JsVar[T any] = ui.JsVar[T]

// IsJsVar is an alias for ui.IsJsVar.
//
// Deprecated: use ui.IsJsVar directly.
type IsJsVar = ui.IsJsVar

// JsVarMaker is an alias for ui.JsVarMaker.
//
// Deprecated: use ui.JsVarMaker directly.
type JsVarMaker = ui.JsVarMaker

// With is an alias for ui.With.
//
// Deprecated: use ui.With directly.
type With = ui.With

// NewTemplate creates a new ui.Template.
//
// Deprecated: use ui.NewTemplate directly.
var NewTemplate = ui.NewTemplate

// NewJsVar creates a new ui.JsVar.
//
// Deprecated: use ui.NewJsVar directly.
func NewJsVar[T any](l sync.Locker, v *T) *JsVar[T] <span class="cov8" title="1">{
        return ui.NewJsVar(l, v)
}</span>

// UiA is an alias for ui.A.
//
// Deprecated: use ui.A directly.
type UiA = ui.A

// UiButton is an alias for ui.Button.
//
// Deprecated: use ui.Button directly.
type UiButton = ui.Button

// UiCheckbox is an alias for ui.Checkbox.
//
// Deprecated: use ui.Checkbox directly.
type UiCheckbox = ui.Checkbox

// UiContainer is an alias for ui.Container.
//
// Deprecated: use ui.Container directly.
type UiContainer = ui.Container

// UiDate is an alias for ui.Date.
//
// Deprecated: use ui.Date directly.
type UiDate = ui.Date

// UiDiv is an alias for ui.Div.
//
// Deprecated: use ui.Div directly.
type UiDiv = ui.Div

// UiImg is an alias for ui.Img.
//
// Deprecated: use ui.Img directly.
type UiImg = ui.Img

// UiLabel is an alias for ui.Label.
//
// Deprecated: use ui.Label directly.
type UiLabel = ui.Label

// UiLi is an alias for ui.Li.
//
// Deprecated: use ui.Li directly.
type UiLi = ui.Li

// UiNumber is an alias for ui.Number.
//
// Deprecated: use ui.Number directly.
type UiNumber = ui.Number

// UiPassword is an alias for ui.Password.
//
// Deprecated: use ui.Password directly.
type UiPassword = ui.Password

// UiRadio is an alias for ui.Radio.
//
// Deprecated: use ui.Radio directly.
type UiRadio = ui.Radio

// UiRange is an alias for ui.Range.
//
// Deprecated: use ui.Range directly.
type UiRange = ui.Range

// UiSelect is an alias for ui.Select.
//
// Deprecated: use ui.Select directly.
type UiSelect = ui.Select

// UiSpan is an alias for ui.Span.
//
// Deprecated: use ui.Span directly.
type UiSpan = ui.Span

// UiTbody is an alias for ui.Tbody.
//
// Deprecated: use ui.Tbody directly.
type UiTbody = ui.Tbody

// UiTd is an alias for ui.Td.
//
// Deprecated: use ui.Td directly.
type UiTd = ui.Td

// UiText is an alias for ui.Text.
//
// Deprecated: use ui.Text directly.
type UiText = ui.Text

// UiTr is an alias for ui.Tr.
//
// Deprecated: use ui.Tr directly.
type UiTr = ui.Tr

// NewUiA creates a new ui.A.
//
// Deprecated: use ui.NewA directly.
var NewUiA = ui.NewA

// NewUiButton creates a new ui.Button.
//
// Deprecated: use ui.NewButton directly.
var NewUiButton = ui.NewButton

// NewUiContainer creates a new ui.Container.
//
// Deprecated: use ui.NewContainer directly.
var NewUiContainer = ui.NewContainer

// NewUiDiv creates a new ui.Div.
//
// Deprecated: use ui.NewDiv directly.
var NewUiDiv = ui.NewDiv

// NewUiLabel creates a new ui.Label.
//
// Deprecated: use ui.NewLabel directly.
var NewUiLabel = ui.NewLabel

// NewUiLi creates a new ui.Li.
//
// Deprecated: use ui.NewLi directly.
var NewUiLi = ui.NewLi

// NewUiSelect creates a new ui.Select.
//
// Deprecated: use ui.NewSelect directly.
var NewUiSelect = ui.NewSelect

// NewUiSpan creates a new ui.Span.
//
// Deprecated: use ui.NewSpan directly.
var NewUiSpan = ui.NewSpan

// NewUiTbody creates a new ui.Tbody.
//
// Deprecated: use ui.NewTbody directly.
var NewUiTbody = ui.NewTbody

// NewUiTd creates a new ui.Td.
//
// Deprecated: use ui.NewTd directly.
var NewUiTd = ui.NewTd

// NewUiTr creates a new ui.Tr.
//
// Deprecated: use ui.NewTr directly.
var NewUiTr = ui.NewTr

// NewUiCheckbox creates a new ui.Checkbox.
//
// Deprecated: use ui.NewCheckbox directly.
func NewUiCheckbox(g Setter[bool]) *UiCheckbox <span class="cov8" title="1">{
        return ui.NewCheckbox(g)
}</span>

// NewUiDate creates a new ui.Date.
//
// Deprecated: use ui.NewDate directly.
func NewUiDate(g Setter[time.Time]) *UiDate <span class="cov8" title="1">{
        return ui.NewDate(g)
}</span>

// NewUiImg creates a new ui.Img.
//
// Deprecated: use ui.NewImg directly.
func NewUiImg(g Getter[string]) *UiImg <span class="cov8" title="1">{
        return ui.NewImg(g)
}</span>

// NewUiNumber creates a new ui.Number.
//
// Deprecated: use ui.NewNumber directly.
func NewUiNumber(g Setter[float64]) *UiNumber <span class="cov8" title="1">{
        return ui.NewNumber(g)
}</span>

// NewUiPassword creates a new ui.Password.
//
// Deprecated: use ui.NewPassword directly.
func NewUiPassword(g Setter[string]) *UiPassword <span class="cov8" title="1">{
        return ui.NewPassword(g)
}</span>

// NewUiRadio creates a new ui.Radio.
//
// Deprecated: use ui.NewRadio directly.
func NewUiRadio(vp Setter[bool]) *UiRadio <span class="cov8" title="1">{
        return ui.NewRadio(vp)
}</span>

// NewUiRange creates a new ui.Range.
//
// Deprecated: use ui.NewRange directly.
func NewUiRange(g Setter[float64]) *UiRange <span class="cov8" title="1">{
        return ui.NewRange(g)
}</span>

// NewUiText creates a new ui.Text.
//
// Deprecated: use ui.NewText directly.
func NewUiText(vp Setter[string]) *UiText <span class="cov8" title="1">{
        return ui.NewText(vp)
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package jawsboot

import (
        "embed"
        "errors"
        "net/http"
        "net/url"
        "path"

        "github.com/linkdata/jaws"
        "github.com/linkdata/jaws/staticserve"
)

//go:embed assets
var assetsFS embed.FS

func Setup(jw *jaws.Jaws, handleFn jaws.HandleFunc, prefix string) (urls []*url.URL, err error) <span class="cov8" title="1">{
        var files []*staticserve.StaticServe
        if err = staticserve.WalkDir(assetsFS, "assets/static", func(filename string, ss *staticserve.StaticServe) (err error) </span><span class="cov8" title="1">{
                files = append(files, ss)
                return
        }</span>); err == nil <span class="cov8" title="1">{
                for _, ss := range files </span><span class="cov8" title="1">{
                        u, e := url.Parse(path.Join(prefix, ss.Name))
                        if e == nil </span><span class="cov8" title="1">{
                                urls = append(urls, u)
                                handleFn(u.String(), ss)
                        }</span>
                        <span class="cov8" title="1">err = errors.Join(err, e)</span>
                }
                <span class="cov8" title="1">handleFn(path.Join(prefix, "bootstrap.bundle.min.js.map"), http.NotFoundHandler())
                handleFn(path.Join(prefix, "bootstrap.min.css.map"), http.NotFoundHandler())</span>
        }
        <span class="cov8" title="1">return</span>
}

/*
// GenerateHeadHTML calls jw.GenerateHeadHTML with URL's for the staticserve files
// prefixed with the given path prefix and any extra URL's you provide.
func GenerateHeadHTML(jw *jaws.Jaws, prefix string, files []*staticserve.StaticServe, extra ...string) (err error) {
        var extraFiles []string
        for _, ss := range files {
                extraFiles = append(extraFiles, path.Join(prefix, ss.Name))
        }
        extraFiles = append(extraFiles, extra...)
        return jw.GenerateHeadHTML(extraFiles...)
}


// SetupUsing sets up Jaws to serve the Bootstrap files from the prefix path,
// calling handleFn for each URI and staticserve.StaticServe.
// If handleFn is nil, http.DefaultServeMux.Handle is used instead.
// Any extra URL's given are passed to GenerateHeadHTML.
func SetupUsing(jw *jaws.Jaws, prefix string, handleFn HandleFunc, extra ...string) (err error) {
        var files []*staticserve.StaticServe
        if handleFn == nil {
                handleFn = http.DefaultServeMux.Handle
        }
        if files, err = Files(); err == nil {
                if err = GenerateHeadHTML(jw, prefix, files, extra...); err == nil {
                        for _, ss := range files {
                                handleFn(path.Join(prefix, ss.Name), ss)
                        }
                        handleFn(path.Join(prefix, "bootstrap.bundle.min.js.map"), http.NotFoundHandler())
                        handleFn(path.Join(prefix, "bootstrap.min.css.map"), http.NotFoundHandler())
                }
        }
        return
}

// Setup calls SetupUsing with a prefix of "/static".
func Setup(jw *jaws.Jaws, handleFn HandleFunc, extra ...string) (err error) {
        return SetupUsing(jw, "/static", handleFn, extra...)
}
*/
</pre>
		
		<pre class="file" id="file38" style="display: none">package jawstest

import (
        "net/http"

        "github.com/linkdata/jaws"
        "github.com/linkdata/jaws/ui"
)

// TestRequest wraps jaws.TestRequest with ui.RequestWriter helpers.
type TestRequest struct {
        *jaws.TestRequest
        rw ui.RequestWriter
}

// NewTestRequest forwards to jaws.NewTestRequest.
func NewTestRequest(jw *jaws.Jaws, hr *http.Request) *TestRequest <span class="cov8" title="1">{
        tr := jaws.NewTestRequest(jw, hr)
        return &amp;TestRequest{
                TestRequest: tr,
                rw: ui.RequestWriter{
                        Request: tr.Request,
                        Writer:  tr.ResponseRecorder,
                },
        }
}</span>

func (tr *TestRequest) UI(widget jaws.UI, params ...any) error <span class="cov8" title="1">{
        return tr.rw.UI(widget, params...)
}</span>

func (tr *TestRequest) Template(name string, dot any, params ...any) error <span class="cov8" title="1">{
        return tr.rw.Template(name, dot, params...)
}</span>

func (tr *TestRequest) JsVar(name string, jsvar any, params ...any) error <span class="cov8" title="1">{
        return tr.rw.JsVar(name, jsvar, params...)
}</span>

func (tr *TestRequest) Register(updater jaws.Updater, params ...any) jaws.Jid <span class="cov8" title="1">{
        return tr.rw.Register(updater, params...)
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package jawstree

import (
        "encoding/json"
        "fmt"
        "slices"
        "strconv"
        "strings"

        "github.com/linkdata/jaws"
)

var _ jaws.SetPather = (*Node)(nil)

type Node struct {
        Tree     *Tree   `json:"-"`
        Parent   *Node   `json:"-"`
        Name     string  `json:"name"`
        ID       string  `json:"id,omitzero"`
        Selected bool    `json:"selected,omitzero"`
        Disabled bool    `json:"disabled,omitzero"` // !selectable
        Children []*Node `json:"children,omitzero"`
}

func (n *Node) marshalJSON(b []byte) []byte <span class="cov8" title="1">{
        b = append(b, `{"name":`...)
        b = strconv.AppendQuote(b, n.Name)
        if n.ID != "" </span><span class="cov8" title="1">{
                b = append(b, `,"id":`...)
                b = strconv.AppendQuote(b, n.ID)
        }</span>
        <span class="cov8" title="1">if n.Selected </span><span class="cov8" title="1">{
                b = append(b, `,"selected":true`...)
        }</span>
        <span class="cov8" title="1">if n.Disabled </span><span class="cov8" title="1">{
                b = append(b, `,"selectable":false`...)
        }</span>
        <span class="cov8" title="1">b = append(b, `,"children":[`...)
        for i, c := range n.Children </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        b = append(b, ',')
                }</span>
                <span class="cov8" title="1">b = c.marshalJSON(b)</span>
        }
        <span class="cov8" title="1">b = append(b, "]}"...)
        return b</span>
}

func (n *Node) MarshalJSON() (b []byte, err error) <span class="cov8" title="1">{
        b = n.marshalJSON(nil)
        return
}</span>

var _ json.Marshaler = &amp;Node{}

func (n *Node) JawsPathSet(elem *jaws.Element, jspath string, value any) <span class="cov8" title="1">{
        if jspath, ok := strings.CutSuffix(jspath, ".selected"); ok </span><span class="cov8" title="1">{
                elem.Jaws.JsCall(n.Tree.Tag, "jawstreeSetPath", fmt.Sprintf(`{"tree":%q,"id":%q,"set":%v}`, n.Tree.id, jspath, value))
        }</span>
}

func (n *Node) Walk(jspath string, fn func(jspath string, node *Node)) <span class="cov8" title="1">{
        fn(jspath, n)
        if jspath != "" </span><span class="cov8" title="1">{
                jspath += "."
        }</span>
        <span class="cov8" title="1">for i, child := range n.Children </span><span class="cov8" title="1">{
                child.Walk(jspath+"children."+strconv.Itoa(i), fn)
        }</span>
}

func (n *Node) HasNames(names []string) (yes bool) <span class="cov8" title="1">{
        if yes = (n.Parent == nil) &amp;&amp; (len(names) == 0); !yes &amp;&amp; n.Parent != nil </span><span class="cov8" title="1">{
                if len(names) &gt; 0 </span><span class="cov8" title="1">{
                        yes = n.Parent.HasNames(names[:len(names)-1])
                        yes = yes &amp;&amp; n.Name == names[len(names)-1]
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func (n *Node) GetNames() (names []string) <span class="cov8" title="1">{
        for n.Parent != nil </span><span class="cov8" title="1">{
                names = append(names, n.Name)
                n = n.Parent
        }</span>
        <span class="cov8" title="1">slices.Reverse(names)
        return</span>
}

func (n *Node) GetSelected() (nameslist [][]string) <span class="cov8" title="1">{
        n.Walk("", func(jspath string, node *Node) </span><span class="cov8" title="1">{
                if node.Selected </span><span class="cov8" title="1">{
                        nameslist = append(nameslist, node.GetNames())
                }</span>
        })
        <span class="cov8" title="1">return</span>
}

func (n *Node) SetSelected(nameslist [][]string) (changed []*Node) <span class="cov8" title="1">{
        n.Walk("", func(jspath string, node *Node) </span><span class="cov8" title="1">{
                for _, names := range nameslist </span><span class="cov8" title="1">{
                        if selected := node.HasNames(names); selected != node.Selected </span><span class="cov8" title="1">{
                                node.Selected = selected
                                changed = append(changed, node)
                        }</span>
                }
        })
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package jawstree

import (
        "errors"
        "io/fs"
        "os"
        "path"
)

// Root builds a root node from a os.Root. If filterfn is not nil, it must return true
// for a directory entry to be included in the tree.
func Root(r *os.Root, filterfn func(dirpath string, ent fs.DirEntry) (include bool)) (rootnode *Node, err error) <span class="cov8" title="1">{
        rootnode = &amp;Node{}
        err = getNodes(r.FS(), rootnode, ".", filterfn)
        return
}</span>

func getNodes(rootfs fs.FS, parent *Node, dirpath string, filterfn func(dirpath string, ent fs.DirEntry) (include bool)) (err error) <span class="cov8" title="1">{
        var ents []fs.DirEntry
        if ents, err = fs.ReadDir(rootfs, dirpath); err == nil </span><span class="cov8" title="1">{
                for _, ent := range ents </span><span class="cov8" title="1">{
                        ent.Name()
                        if filterfn == nil || filterfn(dirpath, ent) </span><span class="cov8" title="1">{
                                child := &amp;Node{
                                        Tree:   parent.Tree,
                                        Parent: parent,
                                        ID:     path.Join(parent.ID, ent.Name()),
                                        Name:   ent.Name(),
                                }
                                if ent.Type().IsRegular() </span><span class="cov8" title="1">{
                                        parent.Children = append(parent.Children, child)
                                }</span> else<span class="cov8" title="1"> if ent.IsDir() </span><span class="cov8" title="1">{
                                        if err = errors.Join(err, getNodes(rootfs, child, path.Join(dirpath, ent.Name()), filterfn)); err == nil </span><span class="cov8" title="1">{
                                                parent.Children = append(parent.Children, child)
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package jawstree

import (
        "embed"
        "errors"
        "net/http"
        "net/url"
        "path"

        "github.com/linkdata/jaws"
        "github.com/linkdata/jaws/staticserve"
)

//go:embed assets
var assetsFS embed.FS

// treeview from https://github.com/stefaneichert/quercus.js

func Setup(jw *jaws.Jaws, handleFn jaws.HandleFunc, prefix string) (urls []*url.URL, err error) <span class="cov8" title="1">{
        var files []*staticserve.StaticServe
        if err = staticserve.WalkDir(assetsFS, "assets", func(filename string, ss *staticserve.StaticServe) (err error) </span><span class="cov8" title="1">{
                files = append(files, ss)
                return
        }</span>); err == nil <span class="cov8" title="1">{
                for _, ss := range files </span><span class="cov8" title="1">{
                        u, e := url.Parse(path.Join(prefix, ss.Name))
                        if e == nil </span><span class="cov8" title="1">{
                                urls = append(urls, u)
                                handleFn(u.String(), ss)
                        }</span>
                        <span class="cov8" title="1">err = errors.Join(err, e)</span>
                }
                <span class="cov8" title="1">handleFn(path.Join(prefix, "treeview.js.map"), http.NotFoundHandler())</span>
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package jawstree

import (
        "fmt"
        "io"
        "strconv"

        "github.com/linkdata/jaws"
        "github.com/linkdata/jaws/ui"
)

var _ jaws.UI = (*Tree)(nil)

type Tree struct {
        id      string // HTML ID of the tree
        options Option
        *ui.JsVar[Node]
}

func New(id string, jsvar *ui.JsVar[Node], options ...Option) (t *Tree) <span class="cov8" title="1">{
        t = &amp;Tree{
                id:    id,
                JsVar: jsvar,
        }
        for _, opt := range options </span><span class="cov8" title="1">{
                t.options |= opt
        }</span>
        <span class="cov8" title="1">jsvar.Ptr.Walk("", func(jspath string, n *Node) </span><span class="cov8" title="1">{ n.ID = jspath; n.Tree = t }</span>)
        <span class="cov8" title="1">return</span>
}

const newtreeTemplate = `
&lt;script&gt;var jawstreeroot_%s; document.addEventListener("DOMContentLoaded",function(){window.jawstree_%s=jawstreeNew("%s",jawstreeroot_%s,%v);});&lt;/script&gt;`

func (t *Tree) JawsRender(e *jaws.Element, w io.Writer, params []any) (err error) <span class="cov8" title="1">{
        if err = t.JsVar.JawsRender(e, w, append([]any{"jawstreeroot_" + t.id}, params...)); err == nil </span><span class="cov8" title="1">{
                if _, err = fmt.Fprintf(w, newtreeTemplate, t.id, t.id, t.id, t.id, t.options); err == nil </span>{<span class="cov8" title="1">
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func (t *Tree) JawsUpdate(elem *jaws.Element) <span class="cov8" title="1">{
        var b []byte
        b = append(b, `{"tree":`...)
        b = strconv.AppendQuote(b, t.id)
        b = append(b, `,"data":`...)
        b = t.JsVar.Ptr.marshalJSON(b)
        b = append(b, `}`...)
        elem.Jaws.JsCall(t.Tag, "jawstreeSet", string(b))
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package jid

import (
        "strconv"
        "strings"
)

// Jid is the basis for the HTML `id` attribute for an UI Element within an active Request.
// It is per-Request, meaning Jid(1) in one Request is not the same as Jid(1) in another.
type Jid int64

const Prefix = "Jid." // String prefixing HTML ID's based on Jid's.
const Invalid = Jid(-1)

func (jid Jid) IsValid() bool <span class="cov8" title="1">{
        return jid &gt;= 0
}</span>

// AppendInt appends just the text format of the Jid's numerical value.
func (jid Jid) AppendInt(dst []byte) []byte <span class="cov8" title="1">{
        if jid &gt; 0 </span><span class="cov8" title="1">{
                dst = strconv.AppendInt(dst, int64(jid), 10)
        }</span>
        <span class="cov8" title="1">return dst</span>
}

// Append appends the unquoted string format of the Jid.
func (jid Jid) Append(dst []byte) []byte <span class="cov8" title="1">{
        if jid &gt; 0 </span><span class="cov8" title="1">{
                dst = append(dst, []byte(Prefix)...)
                dst = jid.AppendInt(dst)
        }</span>
        <span class="cov8" title="1">return dst</span>
}

// AppendQuote appends the string format of the Jid surrounded by double quotes.
func (jid Jid) AppendQuote(dst []byte) []byte <span class="cov8" title="1">{
        dst = append(dst, '"')
        dst = jid.Append(dst)
        dst = append(dst, '"')
        return dst
}</span>

// AppendAttr appends `&lt;startTag` followed by the quoted Jid as a HTML id attribute.
func (jid Jid) AppendStartTagAttr(dst []byte, startTag string) []byte <span class="cov8" title="1">{
        dst = append(dst, '&lt;')
        dst = append(dst, startTag...)
        if jid &gt; 0 </span><span class="cov8" title="1">{
                dst = append(dst, ` id=`...)
                dst = jid.AppendQuote(dst)
        }</span>
        <span class="cov8" title="1">return dst</span>
}

// ParseInt parses a Jid integer and returns it as a Jid.
//
// Returns jid.Invalid if it's not a valid Jid or an error occurs.
func ParseInt(s string) Jid <span class="cov8" title="1">{
        if n, err := strconv.ParseInt(s, 10, 64); err == nil &amp;&amp; n &gt;= 0 </span><span class="cov8" title="1">{
                return Jid(n)
        }</span>
        <span class="cov8" title="1">return Invalid</span>
}

// ParseString parses an unquoted Jid string (e.g. `Jid.2`) and returns the Jid value (e.g. Jid(2)).
//
// Returns jid.Invalid if it's not a valid Jid string.
func ParseString(s string) Jid <span class="cov8" title="1">{
        if s == "" </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">if strings.HasPrefix(s, Prefix) </span><span class="cov8" title="1">{
                return ParseInt(s[len(Prefix):])
        }</span>
        <span class="cov8" title="1">return Invalid</span>
}

// String returns the unquoted string representation of the Jid.
func (jid Jid) String() string <span class="cov8" title="1">{
        if jid &gt; 0 </span><span class="cov8" title="1">{
                return string(jid.Append(nil))
        }</span>
        <span class="cov8" title="1">return ""</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package staticserve

import (
        "errors"
        "io"
        "io/fs"
        "net/http"
        "path"
        "strings"
)

// HandleFunc matches the signature of http.ServeMux.Handle(), but is called without
// method or parameters for the pattern. E.g. ("/static/filename.1234567.js").
type HandleFunc = func(uri string, handler http.Handler)

func ensurePrefixSlash(s string) string <span class="cov8" title="1">{
        if !strings.HasPrefix(s, "/") </span><span class="cov8" title="1">{
                s = "/" + s
        }</span>
        <span class="cov8" title="1">return s</span>
}

// Handle creates a new StaticServe for the fpath that returns the data given.
// Returns the URI of the resource.
func Handle(fpath string, data []byte, handleFn HandleFunc) (uri string, err error) <span class="cov8" title="1">{
        var ss *StaticServe
        if ss, err = New(fpath, data); err == nil </span><span class="cov8" title="1">{
                uri = ensurePrefixSlash(ss.Name)
                handleFn(uri, ss)
        }</span>
        <span class="cov8" title="1">return</span>
}

// HandleFS creates StaticServe handlers for the filepaths given.
// Returns the URI(s) of the resources. If an error occurs, the URI
// of the failed resource will be the empty string.
func HandleFS(fsys fs.FS, handleFn HandleFunc, root string, filepaths ...string) (uris []string, err error) <span class="cov8" title="1">{
        for _, filepath := range filepaths </span><span class="cov8" title="1">{
                var uri string
                f, ferr := fsys.Open(path.Join(root, filepath))
                if ferr == nil </span><span class="cov8" title="1">{
                        var b []byte
                        if b, ferr = io.ReadAll(f); ferr == nil </span><span class="cov8" title="1">{
                                uri, ferr = Handle(filepath, b, handleFn)
                        }</span>
                        <span class="cov8" title="1">ferr = errors.Join(ferr, f.Close())</span>
                }
                <span class="cov8" title="1">uris = append(uris, uri)
                err = errors.Join(err, ferr)</span>
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package staticserve

import (
        "io"
        "io/fs"
        "path"
)

// NewFS reads the file at fpath from fsys and then calls New.
func NewFS(fsys fs.FS, root, fpath string) (ss *StaticServe, err error) <span class="cov8" title="1">{
        var f fs.File
        if f, err = fsys.Open(path.Join(root, fpath)); err == nil </span><span class="cov8" title="1">{
                defer f.Close()
                var b []byte
                if b, err = io.ReadAll(f); err == nil </span><span class="cov8" title="1">{
                        ss, err = New(fpath, b)
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func MustNewFS(fsys fs.FS, root string, fpaths ...string) (ssl []*StaticServe) <span class="cov8" title="1">{
        for _, fpath := range fpaths </span><span class="cov8" title="1">{
                ss, err := NewFS(fsys, root, fpath)
                MaybePanic(err)
                ssl = append(ssl, ss)
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package staticserve

import (
        "bytes"
        "compress/gzip"
        "io"
        "net/http"
        "strconv"
        "strings"
)

var HeaderCacheControl = []string{"public, max-age=31536000, s-maxage=31536000, immutable"}
var HeaderVary = []string{"Accept-Encoding"}
var headerContentEncoding = []string{"gzip"}

func acceptsGzip(hdr http.Header) bool <span class="cov8" title="1">{
        for _, s := range hdr["Accept-Encoding"] </span><span class="cov8" title="1">{
                if strings.Contains(s, "gzip") </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (ss *StaticServe) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var body io.Reader
        statusCode := http.StatusMethodNotAllowed
        if r.Method == http.MethodGet </span><span class="cov8" title="1">{
                hdr := w.Header()
                if acceptsGzip(r.Header) </span><span class="cov8" title="1">{
                        body = bytes.NewReader(ss.Gz)
                        hdr["Content-Encoding"] = headerContentEncoding
                        hdr["Content-Length"] = []string{strconv.Itoa(len(ss.Gz))}
                }</span> else<span class="cov8" title="1"> {
                        statusCode = http.StatusInternalServerError
                        if gzr, err := gzip.NewReader(bytes.NewReader(ss.Gz)); err == nil </span><span class="cov8" title="1">{
                                defer gzr.Close()
                                body = gzr
                        }</span>
                }
                <span class="cov8" title="1">if body != nil </span><span class="cov8" title="1">{
                        statusCode = http.StatusOK
                        hdr["Cache-Control"] = HeaderCacheControl
                        hdr["Vary"] = HeaderVary
                        if ss.ContentType != "" </span><span class="cov8" title="1">{
                                hdr["Content-Type"] = []string{ss.ContentType}
                        }</span>
                }
        }
        <span class="cov8" title="1">w.WriteHeader(statusCode)
        if body != nil </span><span class="cov8" title="1">{
                _, _ = io.Copy(w, body)
        }</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package staticserve

import (
        "bytes"
        "compress/gzip"
        "hash/fnv"
        "mime"
        "path/filepath"
        "strconv"
        "strings"
)

type StaticServe struct {
        Name        string // the cache-busting file name, e.g. "static/filename.1234567.js"
        ContentType string // Content-Type of the file, e.g. "application/javascript"
        Gz          []byte // gzipped data, will be unpacked as needed
}

// New returns a StaticServe that serves the given data with a filename like 'filename.12345678.ext'.
// The filename must have the suffix ".gz" if the data is GZip compressed. The ".gz" suffix will
// not be part of the filename presented in this case.
func New(filename string, data []byte) (ss *StaticServe, err error) <span class="cov8" title="1">{
        var gz []byte
        if strings.HasSuffix(filename, ".gz") </span><span class="cov8" title="1">{
                gz = data
                filename = strings.TrimSuffix(filename, ".gz")
        }</span> else<span class="cov8" title="1"> {
                var buf bytes.Buffer
                gzw := gzip.NewWriter(&amp;buf)
                defer gzw.Close()
                if _, err = gzw.Write(data); err == nil </span><span class="cov8" title="1">{
                        if err = gzw.Flush(); err == nil </span><span class="cov8" title="1">{
                                gz = buf.Bytes()
                        }</span>
                }
        }

        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                ext := filepath.Ext(filename)
                filename = strings.TrimSuffix(filename, ext)
                h := fnv.New64a()
                if _, err = h.Write(gz); err == nil </span><span class="cov8" title="1">{
                        ss = &amp;StaticServe{
                                Name:        filename + "." + strconv.FormatUint(h.Sum64(), 36) + ext,
                                ContentType: mime.TypeByExtension(ext),
                                Gz:          gz,
                        }
                }</span>
        }

        <span class="cov8" title="1">return</span>
}

func MaybePanic(err error) <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                panic(err)</span>
        }
}

// Must calls New and panics on error.
func Must(filename string, data []byte) (ss *StaticServe) <span class="cov8" title="1">{
        var err error
        ss, err = New(filename, data)
        MaybePanic(err)
        return
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package staticserve

import (
        "io"
        "io/fs"
        "strings"
)

// WalkDir walks the file tree rooted at root, calling fn for each file in the tree with
// the filename having root trimmed (e.g. "root/dir/file.ext" becomes "dir/file.ext").
func WalkDir(fsys fs.FS, root string, fn func(filename string, ss *StaticServe) (err error)) (err error) <span class="cov8" title="1">{
        err = fs.WalkDir(fsys, root, func(filename string, d fs.DirEntry, err error) error </span><span class="cov8" title="1">{
                if err == nil &amp;&amp; !d.IsDir() </span><span class="cov8" title="1">{
                        var f fs.File
                        if f, err = fsys.Open(filename); err == nil </span><span class="cov8" title="1">{
                                defer f.Close()
                                var b []byte
                                if b, err = io.ReadAll(f); err == nil </span><span class="cov8" title="1">{
                                        var ss *StaticServe
                                        filename = strings.TrimPrefix(strings.TrimPrefix(filename, root), "/")
                                        if ss, err = New(filename, b); err == nil </span><span class="cov8" title="1">{
                                                err = fn(filename, ss)
                                        }</span>
                                }
                        }
                }
                <span class="cov8" title="1">return err</span>
        })
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package templatereloader

import (
        "html/template"
        "io/fs"
        "path"
        "time"

        "github.com/linkdata/deadlock"
        "github.com/linkdata/jaws"
)

// A TemplateReloader reloads and reparses templates if more than one second
// has passed since the last Lookup.
type TemplateReloader struct {
        Path string // the file path we are loading from
        mu   deadlock.RWMutex
        when time.Time
        curr *template.Template
}

// New returns a jaws.TemplateLookuper.
//
// If deadlock.Debug is false, it calls template.New("").ParseFS(fsys, fpath).
//
// If deadlock.Debug is true, fsys is ignored and it returns a TemplateReloader
// that loads the templates using ParseGlob(relpath/fpath).
func New(fsys fs.FS, fpath, relpath string) (jtl jaws.TemplateLookuper, err error) <span class="cov8" title="1">{
        return create(deadlock.Debug, fsys, fpath, relpath)
}</span>

func create(debug bool, fsys fs.FS, fpath, relpath string) (tl jaws.TemplateLookuper, err error) <span class="cov8" title="1">{
        if !debug </span><span class="cov8" title="1">{
                return template.New("").ParseFS(fsys, fpath)
        }</span>
        <span class="cov8" title="1">var tmpl *template.Template
        fpath = path.Join(relpath, fpath)
        if tmpl, err = template.New("").ParseGlob(fpath); err == nil </span><span class="cov8" title="1">{
                tl = &amp;TemplateReloader{
                        Path: fpath,
                        when: time.Now(),
                        curr: tmpl,
                }
        }</span>
        <span class="cov8" title="1">return</span>
}

func (tr *TemplateReloader) Lookup(name string) *template.Template <span class="cov8" title="1">{
        tr.mu.RLock()
        tl := tr.curr
        d := time.Since(tr.when)
        tr.mu.RUnlock()
        if d &gt; time.Second </span><span class="cov8" title="1">{
                tr.mu.Lock()
                defer tr.mu.Unlock()
                tr.curr = template.Must(template.New("").ParseGlob(tr.Path))
                tr.when = tr.when.Add(d)
                tl = tr.curr
        }</span>
        <span class="cov8" title="1">return tl.Lookup(name)</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package ui

import (
        "io"

        "github.com/linkdata/jaws/core"
)

type A struct{ HTMLInner }

func NewA(innerHTML core.HTMLGetter) *A <span class="cov8" title="1">{ return &amp;A{HTMLInner{HTMLGetter: innerHTML}} }</span>
func (rw RequestWriter) A(innerHTML any, params ...any) error <span class="cov8" title="1">{
        return rw.UI(NewA(core.MakeHTMLGetter(innerHTML)), params...)
}</span>

func (ui *A) JawsRender(e *core.Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        return ui.renderInner(e, w, "a", "", params)
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package ui

import (
        "io"

        "github.com/linkdata/jaws/core"
)

type Button struct{ HTMLInner }

func NewButton(innerHTML core.HTMLGetter) *Button <span class="cov8" title="1">{ return &amp;Button{HTMLInner{HTMLGetter: innerHTML}} }</span>
func (rw RequestWriter) Button(innerHTML any, params ...any) error <span class="cov8" title="1">{
        return rw.UI(NewButton(core.MakeHTMLGetter(innerHTML)), params...)
}</span>

func (ui *Button) JawsRender(e *core.Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        return ui.renderInner(e, w, "button", "button", params)
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package ui

import (
        "io"

        "github.com/linkdata/jaws/core"
)

type Checkbox struct{ InputBool }

func NewCheckbox(g core.Setter[bool]) *Checkbox <span class="cov8" title="1">{ return &amp;Checkbox{InputBool{Setter: g}} }</span>
func (rw RequestWriter) Checkbox(value any, params ...any) error <span class="cov8" title="1">{
        return rw.UI(NewCheckbox(core.MakeSetter[bool](value)), params...)
}</span>

func (ui *Checkbox) JawsRender(e *core.Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        return ui.renderBoolInput(e, w, "checkbox", params...)
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package ui

import "github.com/linkdata/jaws/core"

func must(err error) <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                panic(err)</span>
        }
}

func applyDirty(tag any, e *core.Element, err error) (changed bool, retErr error) <span class="cov8" title="1">{
        switch err </span>{
        case nil:<span class="cov8" title="1">
                e.Dirty(tag)
                return true, nil</span>
        case core.ErrValueUnchanged:<span class="cov8" title="1">
                return false, nil</span>
        default:<span class="cov8" title="1">
                return false, err</span>
        }
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package ui

import (
        "io"

        "github.com/linkdata/jaws/core"
)

type Container struct {
        OuterHTMLTag string
        WrapContainer
}

func NewContainer(outerHTMLTag string, c core.Container) *Container <span class="cov8" title="1">{
        return &amp;Container{
                OuterHTMLTag:  outerHTMLTag,
                WrapContainer: NewWrapContainer(c),
        }
}</span>

func (rw RequestWriter) Container(outerHTMLTag string, c core.Container, params ...any) error <span class="cov8" title="1">{
        return rw.UI(NewContainer(outerHTMLTag, c), params...)
}</span>

func (ui *Container) JawsRender(e *core.Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        return ui.RenderContainer(e, w, ui.OuterHTMLTag, params)
}</span>

func (ui *Container) JawsUpdate(e *core.Element) <span class="cov8" title="1">{
        ui.UpdateContainer(e)
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package ui

import (
        "html/template"
        "io"
        "slices"
        "strings"
        "sync"

        "github.com/linkdata/jaws/core"
)

// WrapContainer is a helper for widgets that render dynamic child collections.
//
// It tracks previously rendered child elements and performs append/remove/order
// updates during JawsUpdate.
type WrapContainer struct {
        Container core.Container
        Tag       any
        mu        sync.Mutex
        contents  []*core.Element
}

func NewWrapContainer(c core.Container) WrapContainer <span class="cov8" title="1">{
        return WrapContainer{Container: c}
}</span>

func (ui *WrapContainer) RenderContainer(e *core.Element, w io.Writer, outerHTMLTag string, params []any) (err error) <span class="cov8" title="1">{
        if ui.Tag, err = e.ApplyGetter(ui.Container); err == nil </span><span class="cov8" title="1">{
                attrs := e.ApplyParams(params)
                b := e.Jid().AppendStartTagAttr(nil, outerHTMLTag)
                for _, attr := range attrs </span><span class="cov8" title="1">{
                        b = append(b, ' ')
                        b = append(b, attr...)
                }</span>
                <span class="cov8" title="1">b = append(b, '&gt;')
                _, err = w.Write(b)
                if err == nil </span><span class="cov8" title="1">{
                        var contents []*core.Element
                        for _, childUI := range ui.Container.JawsContains(e) </span><span class="cov8" title="1">{
                                elem := e.Request.NewElement(childUI)
                                if err = elem.JawsRender(w, nil); err != nil </span><span class="cov8" title="1">{
                                        break</span>
                                }
                                <span class="cov8" title="1">contents = append(contents, elem)</span>
                        }
                        <span class="cov8" title="1">ui.mu.Lock()
                        ui.contents = contents
                        ui.mu.Unlock()
                        b = b[:0]
                        b = append(b, "&lt;/"...)
                        b = append(b, outerHTMLTag...)
                        b = append(b, '&gt;')
                        if _, err2 := w.Write(b); err == nil </span><span class="cov8" title="1">{
                                err = err2
                        }</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

func (ui *WrapContainer) UpdateContainer(e *core.Element) <span class="cov8" title="1">{
        var toRemove, toAppend []*core.Element
        var orderData []core.Jid

        oldMap := make(map[core.UI]*core.Element)
        newMap := make(map[core.UI]struct{})
        newContents := ui.Container.JawsContains(e)
        for _, childUI := range newContents </span><span class="cov8" title="1">{
                newMap[childUI] = struct{}{}
        }</span>

        <span class="cov8" title="1">ui.mu.Lock()
        oldOrder := make([]core.Jid, len(ui.contents))
        for i, elem := range ui.contents </span><span class="cov8" title="1">{
                oldOrder[i] = elem.Jid()
                oldMap[elem.Ui()] = elem
                if _, ok := newMap[elem.Ui()]; !ok </span><span class="cov8" title="1">{
                        toRemove = append(toRemove, elem)
                }</span>
        }
        <span class="cov8" title="1">ui.contents = ui.contents[:0]
        for _, childUI := range newContents </span><span class="cov8" title="1">{
                elem := oldMap[childUI]
                if elem == nil </span><span class="cov8" title="1">{
                        elem = e.Request.NewElement(childUI)
                        toAppend = append(toAppend, elem)
                }</span>
                <span class="cov8" title="1">ui.contents = append(ui.contents, elem)
                orderData = append(orderData, elem.Jid())</span>
        }
        <span class="cov8" title="1">ui.mu.Unlock()

        for _, elem := range toRemove </span><span class="cov8" title="1">{
                e.Remove(elem.Jid().String())
                e.Request.DeleteElement(elem)
        }</span>

        <span class="cov8" title="1">for _, elem := range toAppend </span><span class="cov8" title="1">{
                var sb strings.Builder
                must(elem.JawsRender(&amp;sb, nil))
                e.Append(template.HTML(sb.String())) // #nosec G203
        }</span>

        <span class="cov8" title="1">if !slices.Equal(oldOrder, orderData) </span><span class="cov8" title="1">{
                e.Order(orderData)
        }</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package ui

import (
        "io"
        "time"

        "github.com/linkdata/jaws/core"
)

type Date struct{ InputDate }

func NewDate(g core.Setter[time.Time]) *Date <span class="cov8" title="1">{ return &amp;Date{InputDate{Setter: g}} }</span>
func (rw RequestWriter) Date(value any, params ...any) error <span class="cov8" title="1">{
        return rw.UI(NewDate(core.MakeSetter[time.Time](value)), params...)
}</span>

func (ui *Date) JawsRender(e *core.Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        return ui.renderDateInput(e, w, "date", params...)
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package ui

import (
        "io"

        "github.com/linkdata/jaws/core"
)

type Div struct{ HTMLInner }

func NewDiv(innerHTML core.HTMLGetter) *Div <span class="cov8" title="1">{ return &amp;Div{HTMLInner{HTMLGetter: innerHTML}} }</span>
func (rw RequestWriter) Div(innerHTML any, params ...any) error <span class="cov8" title="1">{
        return rw.UI(NewDiv(core.MakeHTMLGetter(innerHTML)), params...)
}</span>

func (ui *Div) JawsRender(e *core.Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        return ui.renderInner(e, w, "div", "", params)
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package ui

import (
        "strconv"
)

// ErrMissingTemplate is returned when trying to render an undefined template by name.
var ErrMissingTemplate errMissingTemplate

type errMissingTemplate string

func (e errMissingTemplate) Error() string <span class="cov8" title="1">{
        return "missing template " + strconv.Quote(string(e))
}</span>

func (errMissingTemplate) Is(target error) bool <span class="cov8" title="1">{
        return target == ErrMissingTemplate
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package ui

import (
        "net/http"

        "github.com/linkdata/jaws/core"
)

// uiHandler is an http.uiHandler that renders a template for every request.
//
// It wires the incoming HTTP request through the JaWS rendering pipeline by
// creating a Request, instantiating the configured Template and streaming the
// resulting HTML to the caller. Applications typically construct handlers with
// Handler.
type uiHandler struct {
        *core.Jaws
        Template
}

func (h uiHandler) ServeHTTP(wr http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        _ = h.Log(h.NewRequest(r).NewElement(h.Template).JawsRender(wr, nil))
}</span>

// Handler returns an http.Handler that renders the named template.
//
// The returned handler can be registered directly with a router. Each request
// results in the template being looked up through the configured Template
// lookupers and rendered with dot as the template data.
func Handler(jw *core.Jaws, name string, dot any) http.Handler <span class="cov8" title="1">{
        return uiHandler{Jaws: jw, Template: Template{Name: name, Dot: dot}}
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package ui

import (
        "io"

        "github.com/linkdata/jaws/core"
)

// HTMLInner is a reusable base for widgets that render as `&lt;tag&gt;inner&lt;/tag&gt;`.
type HTMLInner struct {
        HTMLGetter core.HTMLGetter
}

func (ui *HTMLInner) renderInner(e *core.Element, w io.Writer, htmlTag, htmlType string, params []any) (err error) <span class="cov8" title="1">{
        if _, err = e.ApplyGetter(ui.HTMLGetter); err == nil </span><span class="cov8" title="1">{
                err = core.WriteHTMLInner(w, e.Jid(), htmlTag, htmlType, ui.HTMLGetter.JawsGetHTML(e), e.ApplyParams(params)...)
        }</span>
        <span class="cov8" title="1">return</span>
}

func (ui *HTMLInner) JawsUpdate(e *core.Element) <span class="cov8" title="1">{
        e.SetInner(ui.HTMLGetter.JawsGetHTML(e))
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package ui

import (
        "html/template"
        "io"
        "strconv"

        "github.com/linkdata/jaws/core"
)

type Img struct{ core.Getter[string] }

func NewImg(g core.Getter[string]) *Img <span class="cov8" title="1">{ return &amp;Img{Getter: g} }</span>
func (rw RequestWriter) Img(imageSrc any, params ...any) error <span class="cov8" title="1">{
        return rw.UI(NewImg(core.MakeGetter[string](imageSrc)), params...)
}</span>

func (ui *Img) JawsRender(e *core.Element, w io.Writer, params []any) (err error) <span class="cov8" title="1">{
        if _, err = e.ApplyGetter(ui.Getter); err == nil </span><span class="cov8" title="1">{
                srcAttr := template.HTMLAttr("src=" + strconv.Quote(ui.JawsGet(e))) // #nosec G203
                attrs := append(e.ApplyParams(params), srcAttr)
                err = core.WriteHTMLInner(w, e.Jid(), "img", "", "", attrs...)
        }</span>
        <span class="cov8" title="1">return</span>
}
func (ui *Img) JawsUpdate(e *core.Element) <span class="cov8" title="1">{ e.SetAttr("src", ui.JawsGet(e)) }</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package ui

import (
        "io"
        "strconv"
        "sync/atomic"
        "time"

        "github.com/linkdata/jaws/core"
        "github.com/linkdata/jaws/what"
)

// Input stores common state for interactive input widgets.
type Input struct {
        Tag  any
        Last atomic.Value
}

func (ui *Input) applyGetter(e *core.Element, getter any) (err error) <span class="cov8" title="1">{
        ui.Tag, err = e.ApplyGetter(getter)
        return
}</span>

func (ui *Input) maybeDirty(val any, e *core.Element, err error) error <span class="cov8" title="1">{
        if changed, err := applyDirty(ui.Tag, e, err); err != nil </span><span class="cov8" title="1">{
                return err
        }</span> else<span class="cov8" title="1"> if changed </span><span class="cov8" title="1">{
                ui.Last.Store(val)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

type InputText struct {
        Input
        core.Setter[string]
}

func (ui *InputText) renderStringInput(e *core.Element, w io.Writer, htmlType string, params ...any) (err error) <span class="cov8" title="1">{
        if err = ui.applyGetter(e, ui.Setter); err == nil </span><span class="cov8" title="1">{
                attrs := e.ApplyParams(params)
                v := ui.JawsGet(e)
                ui.Last.Store(v)
                err = core.WriteHTMLInput(w, e.Jid(), htmlType, v, attrs)
        }</span>
        <span class="cov8" title="1">return</span>
}

func (ui *InputText) JawsUpdate(e *core.Element) <span class="cov8" title="1">{
        if v := ui.JawsGet(e); ui.Last.Swap(v) != v </span><span class="cov8" title="1">{
                e.SetValue(v)
        }</span>
}

func (ui *InputText) JawsEvent(e *core.Element, wht what.What, val string) (err error) <span class="cov8" title="1">{
        err = core.ErrEventUnhandled
        if wht == what.Input </span><span class="cov8" title="1">{
                err = ui.maybeDirty(val, e, ui.Setter.JawsSet(e, val))
        }</span>
        <span class="cov8" title="1">return</span>
}

type InputBool struct {
        Input
        core.Setter[bool]
}

func (ui *InputBool) renderBoolInput(e *core.Element, w io.Writer, htmlType string, params ...any) (err error) <span class="cov8" title="1">{
        if err = ui.applyGetter(e, ui.Setter); err == nil </span><span class="cov8" title="1">{
                attrs := e.ApplyParams(params)
                v := ui.JawsGet(e)
                ui.Last.Store(v)
                if v </span><span class="cov8" title="1">{
                        attrs = append(attrs, "checked")
                }</span>
                <span class="cov8" title="1">err = core.WriteHTMLInput(w, e.Jid(), htmlType, "", attrs)</span>
        }
        <span class="cov8" title="1">return</span>
}

func (ui *InputBool) JawsUpdate(e *core.Element) <span class="cov8" title="1">{
        v := ui.JawsGet(e)
        if ui.Last.Swap(v) != v </span><span class="cov8" title="1">{
                txt := "false"
                if v </span><span class="cov8" title="1">{
                        txt = "true"
                }</span>
                <span class="cov8" title="1">e.SetValue(txt)</span>
        }
}

func (ui *InputBool) JawsEvent(e *core.Element, wht what.What, val string) (err error) <span class="cov8" title="1">{
        err = core.ErrEventUnhandled
        if wht == what.Input </span><span class="cov8" title="1">{
                var v bool
                if val != "" </span><span class="cov8" title="1">{
                        if v, err = strconv.ParseBool(val); err != nil </span><span class="cov8" title="1">{
                                return
                        }</span>
                }
                <span class="cov8" title="1">err = ui.maybeDirty(v, e, ui.Setter.JawsSet(e, v))</span>
        }
        <span class="cov8" title="1">return</span>
}

type InputFloat struct {
        Input
        core.Setter[float64]
}

func (ui *InputFloat) str() string <span class="cov8" title="1">{
        return strconv.FormatFloat(ui.Last.Load().(float64), 'f', -1, 64)
}</span>

func (ui *InputFloat) renderFloatInput(e *core.Element, w io.Writer, htmlType string, params ...any) (err error) <span class="cov8" title="1">{
        if err = ui.applyGetter(e, ui.Setter); err == nil </span><span class="cov8" title="1">{
                attrs := e.ApplyParams(params)
                ui.Last.Store(ui.JawsGet(e))
                err = core.WriteHTMLInput(w, e.Jid(), htmlType, ui.str(), attrs)
        }</span>
        <span class="cov8" title="1">return</span>
}

func (ui *InputFloat) JawsUpdate(e *core.Element) <span class="cov8" title="1">{
        if f := ui.JawsGet(e); ui.Last.Swap(f) != f </span><span class="cov8" title="1">{
                e.SetValue(ui.str())
        }</span>
}

func (ui *InputFloat) JawsEvent(e *core.Element, wht what.What, val string) (err error) <span class="cov8" title="1">{
        err = core.ErrEventUnhandled
        if wht == what.Input </span><span class="cov8" title="1">{
                var v float64
                if val != "" </span><span class="cov8" title="1">{
                        if v, err = strconv.ParseFloat(val, 64); err != nil </span><span class="cov8" title="1">{
                                return
                        }</span>
                }
                <span class="cov8" title="1">err = ui.maybeDirty(v, e, ui.Setter.JawsSet(e, v))</span>
        }
        <span class="cov8" title="1">return</span>
}

type InputDate struct {
        Input
        core.Setter[time.Time]
}

func (ui *InputDate) str() string <span class="cov8" title="1">{
        return ui.Last.Load().(time.Time).Format(core.ISO8601)
}</span>

func (ui *InputDate) renderDateInput(e *core.Element, w io.Writer, htmlType string, params ...any) (err error) <span class="cov8" title="1">{
        if err = ui.applyGetter(e, ui.Setter); err == nil </span><span class="cov8" title="1">{
                attrs := e.ApplyParams(params)
                ui.Last.Store(ui.JawsGet(e))
                err = core.WriteHTMLInput(w, e.Jid(), htmlType, ui.str(), attrs)
        }</span>
        <span class="cov8" title="1">return</span>
}

func (ui *InputDate) JawsUpdate(e *core.Element) <span class="cov8" title="1">{
        if t := ui.JawsGet(e); ui.Last.Swap(t) != t </span><span class="cov8" title="1">{
                e.SetValue(ui.str())
        }</span>
}

func (ui *InputDate) JawsEvent(e *core.Element, wht what.What, val string) (err error) <span class="cov8" title="1">{
        err = core.ErrEventUnhandled
        if wht == what.Input </span><span class="cov8" title="1">{
                var v time.Time
                if val != "" </span><span class="cov8" title="1">{
                        if v, err = time.Parse(core.ISO8601, val); err != nil </span><span class="cov8" title="1">{
                                return
                        }</span>
                }
                <span class="cov8" title="1">err = ui.maybeDirty(v, e, ui.Setter.JawsSet(e, v))</span>
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package ui

import (
        "bytes"
        "encoding/json"
        "html/template"
        "io"
        "reflect"
        "strconv"
        "strings"
        "sync"

        "github.com/linkdata/jaws/core"
        "github.com/linkdata/jaws/what"
        "github.com/linkdata/jq"
)

type PathSetter interface {
        // JawsSetPath should set the JSON object member identified by jspath to the given value.
        //
        // If the member is already the given value, it should return ErrValueUnchanged.
        JawsSetPath(elem *core.Element, jspath string, value any) (err error)
}

type SetPather interface {
        // JawsPathSet notifies that a JSON object member identified by jspath has been set
        // to the given value and the change has been queued for broadcast.
        JawsPathSet(elem *core.Element, jspath string, value any)
}

type IsJsVar interface {
        core.RWLocker
        core.UI
        core.EventHandler
        PathSetter
}

type JsVarMaker interface {
        JawsMakeJsVar(rq *core.Request) (v IsJsVar, err error)
}

var (
        _ IsJsVar          = &amp;JsVar[int]{}
        _ core.Setter[int] = &amp;JsVar[int]{}
)

type JsVar[T any] struct {
        core.RWLocker
        Ptr *T
        Tag any
}

func (ui *JsVar[T]) JawsGetPath(elem *core.Element, jspath string) (value any) <span class="cov8" title="1">{
        ui.RLock()
        defer ui.RUnlock()
        var err error
        value, err = jq.Get(ui.Ptr, jspath)
        if elem != nil </span><span class="cov8" title="1">{
                _ = elem.Jaws.Log(err)
        }</span>
        <span class="cov8" title="1">return</span>
}

func (ui *JsVar[T]) JawsGet(elem *core.Element) (value T) <span class="cov8" title="1">{
        anyval := ui.JawsGetPath(elem, "")
        value = *((anyval).(*T))
        return
}</span>

func (ui *JsVar[T]) setPathLocked(elem *core.Element, jspath string, value any) (err error) <span class="cov8" title="1">{
        if ps, ok := ((any)(ui.Ptr).(PathSetter)); ok </span><span class="cov8" title="1">{
                err = ps.JawsSetPath(elem, jspath, value)
        }</span> else<span class="cov8" title="1"> {
                var changed bool
                if changed, err = jq.Set(ui.Ptr, jspath, value); err == nil &amp;&amp; !changed </span><span class="cov8" title="1">{
                        err = core.ErrValueUnchanged
                }</span>
        }
        <span class="cov8" title="1">if err == nil &amp;&amp; elem != nil </span><span class="cov8" title="1">{
                var data []byte
                if data, err = json.Marshal(value); err == nil </span><span class="cov8" title="1">{
                        elem.Jaws.Broadcast(core.Message{
                                Dest: ui.Tag,
                                What: what.Set,
                                Data: jspath + "=" + string(data),
                        })
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func (ui *JsVar[T]) setPathLock(elem *core.Element, jspath string, value any) (err error) <span class="cov8" title="1">{
        ui.Lock()
        defer ui.Unlock()
        err = ui.setPathLocked(elem, jspath, value)
        return
}</span>

func (ui *JsVar[T]) setPath(elem *core.Element, jspath string, value any) (err error) <span class="cov8" title="1">{
        if err = ui.setPathLock(elem, jspath, value); err == nil </span><span class="cov8" title="1">{
                if sp, ok := ((any)(ui.Ptr).(SetPather)); ok </span><span class="cov8" title="1">{
                        sp.JawsPathSet(elem, jspath, value)
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func (ui *JsVar[T]) JawsSetPath(elem *core.Element, jspath string, value any) (err error) <span class="cov8" title="1">{
        return ui.setPath(elem, jspath, value)
}</span>

func (ui *JsVar[T]) JawsSet(elem *core.Element, value T) (err error) <span class="cov8" title="1">{
        return ui.JawsSetPath(elem, "", value)
}</span>

func appendAttrs(b []byte, attrs []template.HTMLAttr) []byte <span class="cov8" title="1">{
        for _, s := range attrs </span><span class="cov8" title="1">{
                if s != "" </span><span class="cov8" title="1">{
                        b = append(b, ' ')
                        b = append(b, s...)
                }</span>
        }
        <span class="cov8" title="1">return b</span>
}

func (ui *JsVar[T]) JawsRender(e *core.Element, w io.Writer, params []any) (err error) <span class="cov8" title="1">{
        ui.Lock()
        defer ui.Unlock()
        if ui.Tag, err = e.ApplyGetter(ui.Ptr); err == nil </span><span class="cov8" title="1">{
                var data []byte
                if ui.Ptr != nil </span><span class="cov8" title="1">{
                        if !reflect.ValueOf(*ui.Ptr).IsZero() </span><span class="cov8" title="1">{
                                data, err = json.Marshal(ui.Ptr)
                        }</span>
                }
                <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                        jsvarname := params[0].(string)
                        attrs := e.ApplyParams(params[1:])
                        var b []byte
                        b = append(b, "\n&lt;div id="...)
                        b = e.Jid().AppendQuote(b)
                        b = append(b, ` data-jawsname=`...)
                        b = strconv.AppendQuote(b, jsvarname)
                        if data != nil </span><span class="cov8" title="1">{
                                b = append(b, ` data-jawsdata='`...)
                                b = append(b, bytes.ReplaceAll(data, []byte(`'`), []byte(`\u0027`))...)
                                b = append(b, "'"...)
                        }</span>
                        <span class="cov8" title="1">b = appendAttrs(b, attrs)
                        b = append(b, " hidden&gt;&lt;/div&gt;"...)
                        _, err = w.Write(b)</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

func (ui *JsVar[T]) JawsGetTag(rq *core.Request) any <span class="cov8" title="1">{
        return ui.Tag
}</span>

func (ui *JsVar[T]) JawsUpdate(e *core.Element) {<span class="cov8" title="1">}</span> // no-op for JsVar[T]

func elideErrValueUnchanged(err error) error <span class="cov8" title="1">{
        if err == core.ErrValueUnchanged </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return err</span>
}

func (ui *JsVar[T]) JawsEvent(e *core.Element, wht what.What, val string) (err error) <span class="cov8" title="1">{
        err = core.ErrEventUnhandled
        if wht == what.Set </span><span class="cov8" title="1">{
                if jspath, jsval, found := strings.Cut(val, "="); found </span><span class="cov8" title="1">{
                        var v any
                        if err = json.Unmarshal([]byte(jsval), &amp;v); err == nil </span><span class="cov8" title="1">{
                                err = elideErrValueUnchanged(ui.setPath(e, jspath, v))
                        }</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

func NewJsVar[T any](l sync.Locker, v *T) *JsVar[T] <span class="cov8" title="1">{
        if rl, ok := l.(core.RWLocker); ok </span><span class="cov8" title="1">{
                return &amp;JsVar[T]{RWLocker: rl, Ptr: v}
        }</span>
        <span class="cov8" title="1">return &amp;JsVar[T]{RWLocker: rwlocker{l}, Ptr: v}</span>
}

// JsVar binds a JsVar[T] to a named Javascript variable.
//
// You can also pass a JsVarMaker instead of a JsVar[T].
func (rqw RequestWriter) JsVar(jsvarname string, jsvar any, params ...any) (err error) <span class="cov8" title="1">{
        if jvm, ok := jsvar.(JsVarMaker); ok </span><span class="cov8" title="1">{
                jsvar, err = jvm.JawsMakeJsVar(rqw.Request)
        }</span>
        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                var newparams []any
                newparams = append(newparams, jsvarname)
                newparams = append(newparams, params...)
                err = rqw.UI(jsvar.(core.UI), newparams...)
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package ui

import (
        "io"

        "github.com/linkdata/jaws/core"
)

type Label struct{ HTMLInner }

func NewLabel(innerHTML core.HTMLGetter) *Label <span class="cov8" title="1">{ return &amp;Label{HTMLInner{HTMLGetter: innerHTML}} }</span>
func (rw RequestWriter) Label(innerHTML any, params ...any) error <span class="cov8" title="1">{
        return rw.UI(NewLabel(core.MakeHTMLGetter(innerHTML)), params...)
}</span>

func (ui *Label) JawsRender(e *core.Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        return ui.renderInner(e, w, "label", "", params)
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">package ui

import (
        "io"

        "github.com/linkdata/jaws/core"
)

type Li struct{ HTMLInner }

func NewLi(innerHTML core.HTMLGetter) *Li <span class="cov8" title="1">{ return &amp;Li{HTMLInner{HTMLGetter: innerHTML}} }</span>
func (rw RequestWriter) Li(innerHTML any, params ...any) error <span class="cov8" title="1">{
        return rw.UI(NewLi(core.MakeHTMLGetter(innerHTML)), params...)
}</span>

func (ui *Li) JawsRender(e *core.Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        return ui.renderInner(e, w, "li", "", params)
}</span>
</pre>
		
		<pre class="file" id="file66" style="display: none">package ui

import (
        "io"

        "github.com/linkdata/jaws/core"
)

type Number struct{ InputFloat }

func NewNumber(g core.Setter[float64]) *Number <span class="cov8" title="1">{ return &amp;Number{InputFloat{Setter: g}} }</span>
func (rw RequestWriter) Number(value any, params ...any) error <span class="cov8" title="1">{
        return rw.UI(NewNumber(core.MakeSetterFloat64(value)), params...)
}</span>

func (ui *Number) JawsRender(e *core.Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        return ui.renderFloatInput(e, w, "number", params...)
}</span>
</pre>
		
		<pre class="file" id="file67" style="display: none">package ui

import (
        "html"
        "html/template"
        "io"

        "github.com/linkdata/jaws/core"
)

type Option struct{ *core.NamedBool }

func NewOption(nb *core.NamedBool) Option <span class="cov8" title="1">{ return Option{NamedBool: nb} }</span>
func (ui Option) JawsRender(e *core.Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        e.Tag(ui.NamedBool)
        attrs := e.ApplyParams(params)
        valAttr := template.HTMLAttr(`value="` + html.EscapeString(ui.Name()) + `"`) // #nosec G203
        attrs = append(attrs, valAttr)
        if ui.Checked() </span><span class="cov8" title="1">{
                attrs = append(attrs, "selected")
        }</span>
        <span class="cov8" title="1">return core.WriteHTMLInner(w, e.Jid(), "option", "", ui.JawsGetHTML(e), attrs...)</span>
}
func (ui Option) JawsUpdate(e *core.Element) <span class="cov8" title="1">{
        if ui.Checked() </span><span class="cov8" title="1">{
                e.SetAttr("selected", "")
        }</span> else<span class="cov8" title="1"> {
                e.RemoveAttr("selected")
        }</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package ui

import (
        "io"

        "github.com/linkdata/jaws/core"
)

type Password struct{ InputText }

func NewPassword(g core.Setter[string]) *Password <span class="cov8" title="1">{ return &amp;Password{InputText{Setter: g}} }</span>
func (rw RequestWriter) Password(value any, params ...any) error <span class="cov8" title="1">{
        return rw.UI(NewPassword(core.MakeSetter[string](value)), params...)
}</span>

func (ui *Password) JawsRender(e *core.Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        return ui.renderStringInput(e, w, "password", params...)
}</span>
</pre>
		
		<pre class="file" id="file69" style="display: none">package ui

import (
        "io"

        "github.com/linkdata/jaws/core"
)

type Radio struct{ InputBool }

func NewRadio(vp core.Setter[bool]) *Radio <span class="cov8" title="1">{ return &amp;Radio{InputBool{Setter: vp}} }</span>
func (rw RequestWriter) Radio(value any, params ...any) error <span class="cov8" title="1">{
        return rw.UI(NewRadio(core.MakeSetter[bool](value)), params...)
}</span>

func (ui *Radio) JawsRender(e *core.Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        return ui.renderBoolInput(e, w, "radio", params...)
}</span>
</pre>
		
		<pre class="file" id="file70" style="display: none">package ui

import (
        "io"

        "github.com/linkdata/jaws/core"
)

type Range struct{ InputFloat }

func NewRange(g core.Setter[float64]) *Range <span class="cov8" title="1">{ return &amp;Range{InputFloat{Setter: g}} }</span>
func (rw RequestWriter) Range(value any, params ...any) error <span class="cov8" title="1">{
        return rw.UI(NewRange(core.MakeSetterFloat64(value)), params...)
}</span>

func (ui *Range) JawsRender(e *core.Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        return ui.renderFloatInput(e, w, "range", params...)
}</span>
</pre>
		
		<pre class="file" id="file71" style="display: none">package ui

import (
        "io"

        "github.com/linkdata/jaws/core"
        "github.com/linkdata/jaws/jid"
)

// Register creates an element used for update-only registration.
type Register struct{ core.Updater }

func NewRegister(updater core.Updater) Register <span class="cov8" title="1">{ return Register{Updater: updater} }</span>
func (ui Register) JawsRender(*core.Element, io.Writer, []any) error <span class="cov8" title="1">{
        return nil
}</span>

// Register creates a new Element with the given Updater as a tag
// for dynamic updates. Additional tags may be provided in params.
// The updaters JawsUpdate method will be called immediately to
// ensure the initial rendering is correct.
//
// Returns a Jid, suitable for including as a HTML "id" attribute:
//
//        &lt;div id="{{$.Register .MyUpdater}}"&gt;...&lt;/div&gt;
func (rqw RequestWriter) Register(updater core.Updater, params ...any) jid.Jid <span class="cov8" title="1">{
        elem := rqw.NewElement(Register{Updater: updater})
        elem.Tag(updater)
        elem.ApplyParams(params)
        updater.JawsUpdate(elem)
        return elem.Jid()
}</span>
</pre>
		
		<pre class="file" id="file72" style="display: none">package ui

import (
        "io"
        "net/http"

        "github.com/linkdata/jaws/core"
)

type RequestWriter struct {
        *core.Request
        io.Writer
}

func (rqw RequestWriter) UI(ui core.UI, params ...any) error <span class="cov8" title="1">{
        return rqw.NewElement(ui).JawsRender(rqw, params)
}</span>

func (rqw RequestWriter) Write(p []byte) (n int, err error) <span class="cov8" title="1">{
        rqw.Rendering.Store(true)
        return rqw.Writer.Write(p)
}</span>

// Initial returns the initial http.Request.
func (rqw RequestWriter) Initial() *http.Request <span class="cov8" title="1">{
        return rqw.Request.Initial()
}</span>

// Session returns the Requests's Session, or nil.
func (rqw RequestWriter) Session() *core.Session <span class="cov8" title="1">{
        return rqw.Request.Session()
}</span>

// Get calls Request().Get()
func (rqw RequestWriter) Get(key string) (val any) <span class="cov8" title="1">{
        return rqw.Request.Get(key)
}</span>

// Set calls Request().Set()
func (rqw RequestWriter) Set(key string, val any) <span class="cov8" title="1">{
        rqw.Request.Set(key, val)
}</span>

// HeadHTML outputs the HTML code needed in the HEAD section.
func (rqw RequestWriter) HeadHTML() error <span class="cov8" title="1">{
        return rqw.Request.HeadHTML(rqw)
}</span>

// TailHTML writes optional HTML code at the end of the page's BODY section that
// will immediately apply updates made during initial rendering.
func (rqw RequestWriter) TailHTML() error <span class="cov8" title="1">{
        return rqw.Request.TailHTML(rqw)
}</span>
</pre>
		
		<pre class="file" id="file73" style="display: none">package ui

import "sync"

type rwlocker struct {
        sync.Locker
}

func (l rwlocker) RLock() <span class="cov8" title="1">{
        l.Lock()
}</span>

func (l rwlocker) RUnlock() <span class="cov8" title="1">{
        l.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file74" style="display: none">package ui

import (
        "io"

        "github.com/linkdata/jaws/core"
        "github.com/linkdata/jaws/what"
)

type Select struct {
        WrapContainer
}

func NewSelect(sh core.SelectHandler) *Select <span class="cov8" title="1">{
        return &amp;Select{WrapContainer: NewWrapContainer(sh)}
}</span>

func (rw RequestWriter) Select(sh core.SelectHandler, params ...any) error <span class="cov8" title="1">{
        return rw.UI(NewSelect(sh), params...)
}</span>

func (ui *Select) JawsRender(e *core.Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        return ui.RenderContainer(e, w, "select", params)
}</span>

func (ui *Select) JawsUpdate(e *core.Element) <span class="cov8" title="1">{
        e.SetValue(ui.WrapContainer.Container.(core.Getter[string]).JawsGet(e))
        ui.UpdateContainer(e)
}</span>

func (ui *Select) JawsEvent(e *core.Element, wht what.What, val string) (err error) <span class="cov8" title="1">{
        err = core.ErrEventUnhandled
        if wht == what.Input </span><span class="cov8" title="1">{
                _, err = applyDirty(ui.Tag, e, ui.WrapContainer.Container.(core.Setter[string]).JawsSet(e, val))
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package ui

import (
        "io"

        "github.com/linkdata/jaws/core"
)

type Span struct{ HTMLInner }

func NewSpan(innerHTML core.HTMLGetter) *Span <span class="cov8" title="1">{ return &amp;Span{HTMLInner{HTMLGetter: innerHTML}} }</span>
func (rw RequestWriter) Span(innerHTML any, params ...any) error <span class="cov8" title="1">{
        return rw.UI(NewSpan(core.MakeHTMLGetter(innerHTML)), params...)
}</span>

func (ui *Span) JawsRender(e *core.Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        return ui.renderInner(e, w, "span", "", params)
}</span>
</pre>
		
		<pre class="file" id="file76" style="display: none">package ui

import (
        "io"

        "github.com/linkdata/jaws/core"
)

type Tbody struct {
        WrapContainer
}

func NewTbody(c core.Container) *Tbody <span class="cov8" title="1">{
        return &amp;Tbody{WrapContainer: NewWrapContainer(c)}
}</span>

func (rw RequestWriter) Tbody(c core.Container, params ...any) error <span class="cov8" title="1">{
        return rw.UI(NewTbody(c), params...)
}</span>

func (ui *Tbody) JawsRender(e *core.Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        return ui.RenderContainer(e, w, "tbody", params)
}</span>

func (ui *Tbody) JawsUpdate(e *core.Element) <span class="cov8" title="1">{
        ui.UpdateContainer(e)
}</span>
</pre>
		
		<pre class="file" id="file77" style="display: none">package ui

import (
        "io"

        "github.com/linkdata/jaws/core"
)

type Td struct{ HTMLInner }

func NewTd(innerHTML core.HTMLGetter) *Td <span class="cov8" title="1">{ return &amp;Td{HTMLInner{HTMLGetter: innerHTML}} }</span>
func (rw RequestWriter) Td(innerHTML any, params ...any) error <span class="cov8" title="1">{
        return rw.UI(NewTd(core.MakeHTMLGetter(innerHTML)), params...)
}</span>

func (ui *Td) JawsRender(e *core.Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        return ui.renderInner(e, w, "td", "", params)
}</span>
</pre>
		
		<pre class="file" id="file78" style="display: none">package ui

import (
        "bytes"
        "fmt"
        "html/template"
        "io"
        "strings"
        "text/template/parse"

        "github.com/linkdata/deadlock"
        "github.com/linkdata/jaws/core"
        "github.com/linkdata/jaws/what"
)

// Template references a Go html/template to be rendered through JaWS.
//
// The Name field identifies the template to execute and Dot contains the data
// that will be exposed to the template through the With structure constructed
// during rendering. Additional tag bindings and event handlers can be supplied
// at render time through the RequestWriter.Template helper.
type Template struct {
        Name string // Template name to be looked up using Jaws.LookupTemplate()
        Dot  any    // Dot value to place in With structure
}

var _ core.UI = Template{}           // statically ensure interface is defined
var _ core.EventHandler = Template{} // statically ensure interface is defined

func (t Template) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("{%q, %s}", t.Name, core.TagString(t.Dot))
}</span>

func findJidOrJsOrHTMLNode(node parse.Node) (found bool) <span class="cov8" title="1">{
        switch node := node.(type) </span>{
        case *parse.TextNode:<span class="cov8" title="1">
                if node != nil </span><span class="cov8" title="1">{
                        found = found || bytes.Contains(node.Text, []byte("&lt;/html&gt;"))
                }</span>
        case *parse.ListNode:<span class="cov8" title="1">
                if node != nil </span><span class="cov8" title="1">{
                        for _, n := range node.Nodes </span><span class="cov8" title="1">{
                                found = found || findJidOrJsOrHTMLNode(n)
                        }</span>
                }
        case *parse.ActionNode:<span class="cov8" title="1">
                if node != nil </span><span class="cov8" title="1">{
                        found = findJidOrJsOrHTMLNode(node.Pipe)
                }</span>
        case *parse.WithNode:<span class="cov8" title="1">
                if node != nil </span><span class="cov8" title="1">{
                        found = findJidOrJsOrHTMLNode(&amp;node.BranchNode)
                }</span>
        case *parse.BranchNode:<span class="cov8" title="1">
                if node != nil </span><span class="cov8" title="1">{
                        found = findJidOrJsOrHTMLNode(node.Pipe)
                        found = found || findJidOrJsOrHTMLNode(node.List)
                        found = found || findJidOrJsOrHTMLNode(node.ElseList)
                }</span>
        case *parse.IfNode:<span class="cov8" title="1">
                if node != nil </span><span class="cov8" title="1">{
                        found = findJidOrJsOrHTMLNode(node.Pipe)
                        found = found || findJidOrJsOrHTMLNode(node.List)
                        found = found || findJidOrJsOrHTMLNode(node.ElseList)
                }</span>
        case *parse.PipeNode:<span class="cov8" title="1">
                if node != nil </span><span class="cov8" title="1">{
                        for _, n := range node.Cmds </span><span class="cov8" title="1">{
                                found = found || findJidOrJsOrHTMLNode(n)
                        }</span>
                }
        case *parse.CommandNode:<span class="cov8" title="1">
                if node != nil </span><span class="cov8" title="1">{
                        for _, n := range node.Args </span><span class="cov8" title="1">{
                                found = found || findJidOrJsOrHTMLNode(n)
                        }</span>
                }
        case *parse.VariableNode:<span class="cov8" title="1">
                if node != nil </span><span class="cov8" title="1">{
                        for _, s := range node.Ident </span><span class="cov8" title="1">{
                                found = found || (s == "Jid") || (s == "JsFunc") || (s == "JsVar")
                        }</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

func (t Template) JawsRender(e *core.Element, wr io.Writer, params []any) (err error) <span class="cov8" title="1">{
        var expandedtags []any
        if expandedtags, err = core.TagExpand(e.Request, t.Dot); err == nil </span><span class="cov8" title="1">{
                e.Request.TagExpanded(e, expandedtags)
                tags, handlers, attrs := core.ParseParams(params)
                e.Tag(tags...)
                e.AddHandlers(handlers...)
                attrstr := template.HTMLAttr(strings.Join(attrs, " ")) // #nosec G203
                var auth core.Auth
                auth = core.DefaultAuth{}
                if f := e.Request.Jaws.MakeAuth; f != nil </span><span class="cov8" title="1">{
                        auth = f(e.Request)
                }</span>
                <span class="cov8" title="1">err = errMissingTemplate(t.Name)
                if tmpl := e.Request.Jaws.LookupTemplate(t.Name); tmpl != nil </span><span class="cov8" title="1">{
                        err = tmpl.Execute(wr, With{
                                Element:       e,
                                RequestWriter: RequestWriter{Request: e.Request, Writer: wr},
                                Dot:           t.Dot,
                                Attrs:         attrstr,
                                Auth:          auth,
                        })
                        if deadlock.Debug &amp;&amp; e.Jaws.Logger != nil </span><span class="cov8" title="1">{
                                if !findJidOrJsOrHTMLNode(tmpl.Tree.Root) </span><span class="cov8" title="1">{
                                        e.Jaws.Logger.Warn("jaws: template has no Jid reference", "template", t.Name)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return</span>
}

func (t Template) JawsUpdate(e *core.Element) <span class="cov8" title="1">{
        if dot, ok := t.Dot.(core.Updater); ok </span><span class="cov8" title="1">{
                dot.JawsUpdate(e)
        }</span>
}

func (t Template) JawsEvent(e *core.Element, wht what.What, val string) error <span class="cov8" title="1">{
        return core.CallEventHandlers(t.Dot, e, wht, val)
}</span>

// NewTemplate constructs a Template with the provided name and data value.
//
// It is a small helper that makes it convenient to use Template values with
// other JaWS helpers without having to fill the struct fields manually.
func NewTemplate(name string, dot any) Template <span class="cov8" title="1">{
        return Template{Name: name, Dot: dot}
}</span>

// Template renders the given template using ui.With as data.
//
// The Dot field in ui.With is set to dot, and name is resolved to a
// *template.Template using Jaws.LookupTemplate().
func (rqw RequestWriter) Template(name string, dot any, params ...any) error <span class="cov8" title="1">{
        return rqw.UI(NewTemplate(name, dot), params...)
}</span>
</pre>
		
		<pre class="file" id="file79" style="display: none">package ui

import (
        "io"

        "github.com/linkdata/jaws/core"
)

type Text struct{ InputText }

func NewText(vp core.Setter[string]) *Text <span class="cov8" title="1">{ return &amp;Text{InputText{Setter: vp}} }</span>
func (rw RequestWriter) Text(value any, params ...any) error <span class="cov8" title="1">{
        return rw.UI(NewText(core.MakeSetter[string](value)), params...)
}</span>

func (ui *Text) JawsRender(e *core.Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        return ui.renderStringInput(e, w, "text", params...)
}</span>
</pre>
		
		<pre class="file" id="file80" style="display: none">package ui

import (
        "html/template"
        "io"

        "github.com/linkdata/jaws/core"
)

type Textarea struct{ InputText }

func NewTextarea(g core.Setter[string]) *Textarea <span class="cov8" title="1">{ return &amp;Textarea{InputText{Setter: g}} }</span>
func (rw RequestWriter) Textarea(value any, params ...any) error <span class="cov8" title="1">{
        return rw.UI(NewTextarea(core.MakeSetter[string](value)), params...)
}</span>

func (ui *Textarea) JawsRender(e *core.Element, w io.Writer, params []any) (err error) <span class="cov8" title="1">{
        if err = ui.applyGetter(e, ui.Setter); err == nil </span><span class="cov8" title="1">{
                attrs := e.ApplyParams(params)
                err = core.WriteHTMLInner(w, e.Jid(), "textarea", "", template.HTML(ui.JawsGet(e)), attrs...) // #nosec G203
        }</span>
        <span class="cov8" title="1">return</span>
}
func (ui *Textarea) JawsUpdate(e *core.Element) <span class="cov8" title="1">{ e.SetValue(ui.JawsGet(e)) }</span>
</pre>
		
		<pre class="file" id="file81" style="display: none">package ui

import (
        "io"

        "github.com/linkdata/jaws/core"
)

type Tr struct{ HTMLInner }

func NewTr(innerHTML core.HTMLGetter) *Tr <span class="cov8" title="1">{ return &amp;Tr{HTMLInner{HTMLGetter: innerHTML}} }</span>
func (rw RequestWriter) Tr(innerHTML any, params ...any) error <span class="cov8" title="1">{
        return rw.UI(NewTr(core.MakeHTMLGetter(innerHTML)), params...)
}</span>

func (ui *Tr) JawsRender(e *core.Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        return ui.renderInner(e, w, "tr", "", params)
}</span>
</pre>
		
		<pre class="file" id="file82" style="display: none">package what

import "strings"

//go:generate go run golang.org/x/tools/cmd/stringer@latest -type=What
type What uint8

const (
        invalid What = iota

        // Commands not associated with an Element
        Update   // Used for update scheduling
        Reload   // Tells browser to reload the current URL
        Redirect // Tells browser to load another URL
        Alert    // Display (if using Bootstrap) an alert message
        Order    // Re-order a set of elements
        Call     // Call javascript function
        Set      // Set javascript variable (JSON path + tab char + JSON data)

        separator

        // Element manipulation
        Inner   // Set the elements inner HTML
        Delete  // Delete the element
        Replace // Replace the element with new HTML
        Remove  // Remove child element
        Insert  // Insert child element
        Append  // Append child element
        SAttr   // Set element attribute
        RAttr   // Remove element attribute
        SClass  // Set element class
        RClass  // Remove element class
        Value   // Set element value
        // Element input events
        Input
        Click
        // Testing
        Hook // Calls event handler synchronously
)

func (w What) IsCommand() bool <span class="cov8" title="1">{
        return w &lt; separator &amp;&amp; w.IsValid()
}</span>

func (w What) IsValid() bool <span class="cov8" title="1">{
        return w != invalid &amp;&amp; w != separator
}</span>

func Parse(s string) What <span class="cov8" title="1">{
        if s == "" </span><span class="cov8" title="1">{
                return Update
        }</span>
        <span class="cov8" title="1">for i := 0; i &lt; len(_What_index)-1; i++ </span><span class="cov8" title="1">{
                if s == _What_name[_What_index[i]:_What_index[i+1]] </span><span class="cov8" title="1">{
                        return What(i) // #nosec G115
                }</span>
        }
        <span class="cov8" title="1">for i := 0; i &lt; len(_What_index)-1; i++ </span><span class="cov8" title="1">{
                if strings.EqualFold(s, _What_name[_What_index[i]:_What_index[i+1]]) </span><span class="cov8" title="1">{
                        return What(i) // #nosec G115
                }</span>
        }
        <span class="cov8" title="1">return invalid</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">// Code generated by "stringer -type=What"; DO NOT EDIT.

package what

import "strconv"

func _() {
        // An "invalid array index" compiler error signifies that the constant values have changed.
        // Re-run the stringer command to generate them again.
        var x [1]struct{}
        _ = x[invalid-0]
        _ = x[Update-1]
        _ = x[Reload-2]
        _ = x[Redirect-3]
        _ = x[Alert-4]
        _ = x[Order-5]
        _ = x[Call-6]
        _ = x[Set-7]
        _ = x[separator-8]
        _ = x[Inner-9]
        _ = x[Delete-10]
        _ = x[Replace-11]
        _ = x[Remove-12]
        _ = x[Insert-13]
        _ = x[Append-14]
        _ = x[SAttr-15]
        _ = x[RAttr-16]
        _ = x[SClass-17]
        _ = x[RClass-18]
        _ = x[Value-19]
        _ = x[Input-20]
        _ = x[Click-21]
        _ = x[Hook-22]
}

const _What_name = "invalidUpdateReloadRedirectAlertOrderCallSetseparatorInnerDeleteReplaceRemoveInsertAppendSAttrRAttrSClassRClassValueInputClickHook"

var _What_index = [...]uint8{0, 7, 13, 19, 27, 32, 37, 41, 44, 53, 58, 64, 71, 77, 83, 89, 94, 99, 105, 111, 116, 121, 126, 130}

func (i What) String() string <span class="cov8" title="1">{
        idx := int(i) - 0
        if i &lt; 0 || idx &gt;= len(_What_index)-1 </span><span class="cov8" title="1">{
                return "What(" + strconv.FormatInt(int64(i), 10) + ")"
        }</span>
        <span class="cov8" title="1">return _What_name[_What_index[idx]:_What_index[idx+1]]</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
