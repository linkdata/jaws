
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>jaws: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/linkdata/jaws/jaws.go (100.0%)</option>
				
				<option value="file1">github.com/linkdata/jaws/jaws/auth.go (100.0%)</option>
				
				<option value="file2">github.com/linkdata/jaws/jaws/bind.go (100.0%)</option>
				
				<option value="file3">github.com/linkdata/jaws/jaws/binding.go (100.0%)</option>
				
				<option value="file4">github.com/linkdata/jaws/jaws/bindinghook.go (100.0%)</option>
				
				<option value="file5">github.com/linkdata/jaws/jaws/clickhandler.go (100.0%)</option>
				
				<option value="file6">github.com/linkdata/jaws/jaws/defaultcookiename.go (100.0%)</option>
				
				<option value="file7">github.com/linkdata/jaws/jaws/element.go (100.0%)</option>
				
				<option value="file8">github.com/linkdata/jaws/jaws/errillegaltagtype.go (100.0%)</option>
				
				<option value="file9">github.com/linkdata/jaws/jaws/errmissingtemplate.go (100.0%)</option>
				
				<option value="file10">github.com/linkdata/jaws/jaws/errnotcomparable.go (100.0%)</option>
				
				<option value="file11">github.com/linkdata/jaws/jaws/errnowebsocketrequest.go (100.0%)</option>
				
				<option value="file12">github.com/linkdata/jaws/jaws/errpendingcancelled.go (100.0%)</option>
				
				<option value="file13">github.com/linkdata/jaws/jaws/eventhandler.go (100.0%)</option>
				
				<option value="file14">github.com/linkdata/jaws/jaws/getter.go (100.0%)</option>
				
				<option value="file15">github.com/linkdata/jaws/jaws/handler.go (100.0%)</option>
				
				<option value="file16">github.com/linkdata/jaws/jaws/htmlgetterfunc.go (100.0%)</option>
				
				<option value="file17">github.com/linkdata/jaws/jaws/jaws.go (100.0%)</option>
				
				<option value="file18">github.com/linkdata/jaws/jaws/js.go (100.0%)</option>
				
				<option value="file19">github.com/linkdata/jaws/jaws/jsvar.go (100.0%)</option>
				
				<option value="file20">github.com/linkdata/jaws/jaws/makehtmlgetter.go (100.0%)</option>
				
				<option value="file21">github.com/linkdata/jaws/jaws/message.go (100.0%)</option>
				
				<option value="file22">github.com/linkdata/jaws/jaws/namedbool.go (100.0%)</option>
				
				<option value="file23">github.com/linkdata/jaws/jaws/namedboolarray.go (100.0%)</option>
				
				<option value="file24">github.com/linkdata/jaws/jaws/parseparams.go (100.0%)</option>
				
				<option value="file25">github.com/linkdata/jaws/jaws/request.go (100.0%)</option>
				
				<option value="file26">github.com/linkdata/jaws/jaws/requestwriter.go (100.0%)</option>
				
				<option value="file27">github.com/linkdata/jaws/jaws/rwlocker.go (100.0%)</option>
				
				<option value="file28">github.com/linkdata/jaws/jaws/servehttp.go (100.0%)</option>
				
				<option value="file29">github.com/linkdata/jaws/jaws/session.go (100.0%)</option>
				
				<option value="file30">github.com/linkdata/jaws/jaws/sessioner.go (100.0%)</option>
				
				<option value="file31">github.com/linkdata/jaws/jaws/setter.go (100.0%)</option>
				
				<option value="file32">github.com/linkdata/jaws/jaws/setterfloat64.go (100.0%)</option>
				
				<option value="file33">github.com/linkdata/jaws/jaws/setup.go (100.0%)</option>
				
				<option value="file34">github.com/linkdata/jaws/jaws/stringgetterfunc.go (100.0%)</option>
				
				<option value="file35">github.com/linkdata/jaws/jaws/tag.go (100.0%)</option>
				
				<option value="file36">github.com/linkdata/jaws/jaws/template.go (100.0%)</option>
				
				<option value="file37">github.com/linkdata/jaws/jaws/uia.go (100.0%)</option>
				
				<option value="file38">github.com/linkdata/jaws/jaws/uibutton.go (100.0%)</option>
				
				<option value="file39">github.com/linkdata/jaws/jaws/uicheckbox.go (100.0%)</option>
				
				<option value="file40">github.com/linkdata/jaws/jaws/uicontainer.go (100.0%)</option>
				
				<option value="file41">github.com/linkdata/jaws/jaws/uidate.go (100.0%)</option>
				
				<option value="file42">github.com/linkdata/jaws/jaws/uidiv.go (100.0%)</option>
				
				<option value="file43">github.com/linkdata/jaws/jaws/uihtmlinner.go (100.0%)</option>
				
				<option value="file44">github.com/linkdata/jaws/jaws/uiimg.go (100.0%)</option>
				
				<option value="file45">github.com/linkdata/jaws/jaws/uiinput.go (100.0%)</option>
				
				<option value="file46">github.com/linkdata/jaws/jaws/uiinputbool.go (100.0%)</option>
				
				<option value="file47">github.com/linkdata/jaws/jaws/uiinputdate.go (100.0%)</option>
				
				<option value="file48">github.com/linkdata/jaws/jaws/uiinputfloat.go (100.0%)</option>
				
				<option value="file49">github.com/linkdata/jaws/jaws/uiinputtext.go (100.0%)</option>
				
				<option value="file50">github.com/linkdata/jaws/jaws/uilabel.go (100.0%)</option>
				
				<option value="file51">github.com/linkdata/jaws/jaws/uili.go (100.0%)</option>
				
				<option value="file52">github.com/linkdata/jaws/jaws/uinumber.go (100.0%)</option>
				
				<option value="file53">github.com/linkdata/jaws/jaws/uioption.go (100.0%)</option>
				
				<option value="file54">github.com/linkdata/jaws/jaws/uipassword.go (100.0%)</option>
				
				<option value="file55">github.com/linkdata/jaws/jaws/uiradio.go (100.0%)</option>
				
				<option value="file56">github.com/linkdata/jaws/jaws/uiradiogroup.go (100.0%)</option>
				
				<option value="file57">github.com/linkdata/jaws/jaws/uirange.go (100.0%)</option>
				
				<option value="file58">github.com/linkdata/jaws/jaws/uiregister.go (100.0%)</option>
				
				<option value="file59">github.com/linkdata/jaws/jaws/uiselect.go (100.0%)</option>
				
				<option value="file60">github.com/linkdata/jaws/jaws/uispan.go (100.0%)</option>
				
				<option value="file61">github.com/linkdata/jaws/jaws/uitbody.go (100.0%)</option>
				
				<option value="file62">github.com/linkdata/jaws/jaws/uitd.go (100.0%)</option>
				
				<option value="file63">github.com/linkdata/jaws/jaws/uitext.go (100.0%)</option>
				
				<option value="file64">github.com/linkdata/jaws/jaws/uitextarea.go (100.0%)</option>
				
				<option value="file65">github.com/linkdata/jaws/jaws/uitr.go (100.0%)</option>
				
				<option value="file66">github.com/linkdata/jaws/jaws/uiwrapcontainer.go (100.0%)</option>
				
				<option value="file67">github.com/linkdata/jaws/jaws/writehtml.go (100.0%)</option>
				
				<option value="file68">github.com/linkdata/jaws/jaws/ws.go (100.0%)</option>
				
				<option value="file69">github.com/linkdata/jaws/jaws/wsmsg.go (100.0%)</option>
				
				<option value="file70">github.com/linkdata/jaws/jawsboot/jawsboot.go (100.0%)</option>
				
				<option value="file71">github.com/linkdata/jaws/jawstree/node.go (100.0%)</option>
				
				<option value="file72">github.com/linkdata/jaws/jawstree/root.go (100.0%)</option>
				
				<option value="file73">github.com/linkdata/jaws/jawstree/setup.go (100.0%)</option>
				
				<option value="file74">github.com/linkdata/jaws/jawstree/tree.go (100.0%)</option>
				
				<option value="file75">github.com/linkdata/jaws/jid/jid.go (100.0%)</option>
				
				<option value="file76">github.com/linkdata/jaws/staticserve/handle.go (100.0%)</option>
				
				<option value="file77">github.com/linkdata/jaws/staticserve/newfs.go (100.0%)</option>
				
				<option value="file78">github.com/linkdata/jaws/staticserve/servehttp.go (100.0%)</option>
				
				<option value="file79">github.com/linkdata/jaws/staticserve/staticserve.go (100.0%)</option>
				
				<option value="file80">github.com/linkdata/jaws/staticserve/walkdir.go (100.0%)</option>
				
				<option value="file81">github.com/linkdata/jaws/templatereloader/templatereloader.go (100.0%)</option>
				
				<option value="file82">github.com/linkdata/jaws/what/what.go (100.0%)</option>
				
				<option value="file83">github.com/linkdata/jaws/what/what_string.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package jaws

import (
        "html/template"
        "io"
        "sync"
        "time"

        pkg "github.com/linkdata/jaws/jaws"
        "github.com/linkdata/jaws/jid"
)

// The point of this is to not have a zillion files in the repository root
// while keeping the import path unchanged.

type (
        Jid                  = jid.Jid
        Jaws                 = pkg.Jaws
        Request              = pkg.Request
        Element              = pkg.Element
        UI                   = pkg.UI
        Updater              = pkg.Updater
        Renderer             = pkg.Renderer
        TemplateLookuper     = pkg.TemplateLookuper
        HandleFunc           = pkg.HandleFunc
        PathSetter           = pkg.PathSetter
        SetPather            = pkg.SetPather
        Formatter            = pkg.Formatter
        Auth                 = pkg.Auth
        InitHandler          = pkg.InitHandler
        ClickHandler         = pkg.ClickHandler
        EventHandler         = pkg.EventHandler
        SelectHandler        = pkg.SelectHandler
        Container            = pkg.Container
        Getter[T comparable] = pkg.Getter[T]
        Setter[T comparable] = pkg.Setter[T]
        Binder[T comparable] = pkg.Binder[T]
        HTMLGetter           = pkg.HTMLGetter
        JsVar[T any]         = pkg.JsVar[T]
        IsJsVar              = pkg.IsJsVar
        JsVarMaker           = pkg.JsVarMaker
        Logger               = pkg.Logger
        RWLocker             = pkg.RWLocker
        TagGetter            = pkg.TagGetter
        NamedBool            = pkg.NamedBool
        NamedBoolArray       = pkg.NamedBoolArray
        Template             = pkg.Template
        RequestWriter        = pkg.RequestWriter
        With                 = pkg.With
        Session              = pkg.Session
        Tag                  = pkg.Tag
)

var (
        ErrEventUnhandled        = pkg.ErrEventUnhandled
        ErrIllegalTagType        = pkg.ErrIllegalTagType // ErrIllegalTagType is returned when a UI tag type is disallowed
        ErrMissingTemplate       = pkg.ErrMissingTemplate
        ErrNotComparable         = pkg.ErrNotComparable
        ErrNoWebSocketRequest    = pkg.ErrNoWebSocketRequest
        ErrPendingCancelled      = pkg.ErrPendingCancelled
        ErrValueUnchanged        = pkg.ErrValueUnchanged
        ErrValueNotSettable      = pkg.ErrValueNotSettable
        ErrRequestAlreadyClaimed = pkg.ErrRequestAlreadyClaimed
        ErrJavascriptDisabled    = pkg.ErrJavascriptDisabled
        ErrTooManyTags           = pkg.ErrTooManyTags
)

const (
        ISO8601 = pkg.ISO8601
)

// New returns a new JaWS object.
// This is expected to be created once per HTTP server and handles
// publishing HTML changes across all connections.
func New() (jw *Jaws, err error) <span class="cov8" title="1">{
        return pkg.New()
}</span>

// JawsKeyString returns the string to be used for the given JaWS key.
func JawsKeyString(jawsKey uint64) string <span class="cov8" title="1">{
        return pkg.JawsKeyString(jawsKey)
}</span>

func WriteHTMLTag(w io.Writer, jid jid.Jid, htmlTag string, typeAttr string, valueAttr string, attrs []template.HTMLAttr) (err error) <span class="cov8" title="1">{
        return pkg.WriteHTMLTag(w, jid, htmlTag, typeAttr, valueAttr, attrs)
}</span>

// Bind returns a Binder[T] with the given sync.Locker (or RWLocker) and a pointer to the underlying value of type T.
//
// The pointer will be used as the UI tag.
func Bind[T comparable](l sync.Locker, p *T) Binder[T] <span class="cov8" title="1">{
        return pkg.Bind(l, p)
}</span>

// NewJsVar creates a binding with a Locker (or RWLocker) and
// pointer to underlying data.
//
// JsVar's use JawsRender, and that rendering will contain the
// JSON representation of the underlying data unless it is the
// zero value. If so, it will be used to initialize the named
// Javascript variable before "DOMContentLoaded" fires.
// Note that we don't render the Javascript variable declaration,
// you'll have to do that yourself.
//
// JsVar's do *NOT* use JawsUpdate, so changing the underlying data and
// calling JawsUpdate will have no effect. Instead, JsVar's are
// synchronized across browsers using immediate broadcasts.
//
// Changes to JsVar's should be made using their [JawsSet] or
// [JawsSetPath] methods. If *T implements [PathSetter],
// that will be used instead of jq.Set().
func NewJsVar[T any](l sync.Locker, v *T) *JsVar[T] <span class="cov8" title="1">{
        return pkg.NewJsVar(l, v)
}</span>

// NewTemplate simply returns a Template{} with the members set.
//
// Provided as convenience so as to not have to name the structure members.
func NewTemplate(name string, dot any) Template <span class="cov8" title="1">{
        return pkg.NewTemplate(name, dot)
}</span>

// HTMLGetterFunc wraps a function and returns a HTMLGetter.
func HTMLGetterFunc(fn func(elem *Element) (tmpl template.HTML), tags ...any) HTMLGetter <span class="cov8" title="1">{
        return pkg.HTMLGetterFunc(fn)
}</span>

// MakeHTMLGetter returns a HTMLGetter for v.
//
// Depending on the type of v, we return:
//
//   - jaws.HTMLGetter: `JawsGetHTML(e *Element) template.HTML` to be used as-is.
//   - jaws.Getter[string]: `JawsGet(elem *Element) string` that will be escaped using `html.EscapeString`.
//   - jaws.AnyGetter: `JawsGetAny(elem *Element) any` that will be rendered using `fmt.Sprint()` and escaped using `html.EscapeString`.
//   - fmt.Stringer: `String() string` that will be escaped using `html.EscapeString`.
//   - a static `template.HTML` or `string` to be used as-is with no HTML escaping.
//   - everything else is rendered using `fmt.Sprint()` and escaped using `html.EscapeString`.
func MakeHTMLGetter(v any) HTMLGetter <span class="cov8" title="1">{
        return pkg.MakeHTMLGetter(v)
}</span>

func NewNamedBool(nba *NamedBoolArray, name string, html template.HTML, checked bool) *NamedBool <span class="cov8" title="1">{
        return pkg.NewNamedBool(nba, name, html, checked)
}</span>

// NewNamedBoolArray creates a new object to track a related set of named booleans.
//
// The JaWS ID string 'jid' is used as the ID for &lt;select&gt; elements and the
// value for the 'name' attribute for radio buttons. If left empty, MakeID() will
// be used to assign a unique ID.
func NewNamedBoolArray() *NamedBoolArray <span class="cov8" title="1">{
        return pkg.NewNamedBoolArray()
}</span>

type (
        UiA         = pkg.UiA
        UiButton    = pkg.UiButton
        UiCheckbox  = pkg.UiCheckbox
        UiContainer = pkg.UiContainer
        UiDate      = pkg.UiDate
        UiDiv       = pkg.UiDiv
        UiImg       = pkg.UiImg
        UiLabel     = pkg.UiLabel
        UiLi        = pkg.UiLi
        UiNumber    = pkg.UiNumber
        UiPassword  = pkg.UiPassword
        UiRadio     = pkg.UiRadio
        UiRange     = pkg.UiRange
        UiSelect    = pkg.UiSelect
        UiSpan      = pkg.UiSpan
        UiTbody     = pkg.UiTbody
        UiTd        = pkg.UiTd
        UiText      = pkg.UiText
        UiTr        = pkg.UiTr
)

func NewUiA(innerHTML HTMLGetter) *UiA <span class="cov8" title="1">{
        return pkg.NewUiA(innerHTML)
}</span>
func NewUiButton(innerHTML HTMLGetter) *UiButton <span class="cov8" title="1">{
        return pkg.NewUiButton(innerHTML)
}</span>
func NewUiCheckbox(g Setter[bool]) *UiCheckbox <span class="cov8" title="1">{
        return pkg.NewUiCheckbox(g)
}</span>
func NewUiContainer(outerHTMLTag string, c Container) *UiContainer <span class="cov8" title="1">{
        return pkg.NewUiContainer(outerHTMLTag, c)
}</span>
func NewUiDate(g Setter[time.Time]) *UiDate <span class="cov8" title="1">{
        return pkg.NewUiDate(g)
}</span>
func NewUiDiv(innerHTML HTMLGetter) *UiDiv <span class="cov8" title="1">{
        return pkg.NewUiDiv(innerHTML)
}</span>
func NewUiImg(g Getter[string]) *UiImg <span class="cov8" title="1">{
        return pkg.NewUiImg(g)
}</span>
func NewUiLabel(innerHTML HTMLGetter) *UiLabel <span class="cov8" title="1">{
        return pkg.NewUiLabel(innerHTML)
}</span>
func NewUiLi(innerHTML HTMLGetter) *UiLi <span class="cov8" title="1">{
        return pkg.NewUiLi(innerHTML)
}</span>
func NewUiNumber(g Setter[float64]) *UiNumber <span class="cov8" title="1">{
        return pkg.NewUiNumber(g)
}</span>
func NewUiPassword(g Setter[string]) *UiPassword <span class="cov8" title="1">{
        return pkg.NewUiPassword(g)
}</span>
func NewUiRadio(vp Setter[bool]) *UiRadio <span class="cov8" title="1">{
        return pkg.NewUiRadio(vp)
}</span>
func NewUiRange(g Setter[float64]) *UiRange <span class="cov8" title="1">{
        return pkg.NewUiRange(g)
}</span>
func NewUiSelect(sh SelectHandler) *UiSelect <span class="cov8" title="1">{
        return pkg.NewUiSelect(sh)
}</span>
func NewUiSpan(innerHTML HTMLGetter) *UiSpan <span class="cov8" title="1">{
        return pkg.NewUiSpan(innerHTML)
}</span>
func NewUiTbody(c Container) *UiTbody <span class="cov8" title="1">{
        return pkg.NewUiTbody(c)
}</span>
func NewUiTd(innerHTML HTMLGetter) *UiTd <span class="cov8" title="1">{
        return pkg.NewUiTd(innerHTML)
}</span>
func NewUiText(vp Setter[string]) *UiText <span class="cov8" title="1">{
        return pkg.NewUiText(vp)
}</span>
func NewUiTr(innerHTML HTMLGetter) *UiTr <span class="cov8" title="1">{
        return pkg.NewUiTr(innerHTML)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package jaws

type Auth interface {
        Data() map[string]any // returns authenticated user data, or nil
        Email() string        // returns authenticated user email, or an empty string
        IsAdmin() bool        // return true if admins are defined and current user is one, or if no admins are defined
}

type MakeAuthFn func(*Request) Auth

type defaultAuth struct{}

func (defaultAuth) Data() map[string]any <span class="cov8" title="1">{ return nil }</span>
func (defaultAuth) Email() string        <span class="cov8" title="1">{ return "" }</span>
func (defaultAuth) IsAdmin() bool        <span class="cov8" title="1">{ return true }</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package jaws

import (
        "sync"
)

// Bind returns a Binder[T] with the given sync.Locker (or RWLocker) and a pointer to the underlying value of type T.
//
// The pointer will be used as the UI tag.
func Bind[T comparable](l sync.Locker, p *T) Binder[T] <span class="cov8" title="1">{
        if rl, ok := l.(RWLocker); ok </span><span class="cov8" title="1">{
                return binding[T]{RWLocker: rl, ptr: p}
        }</span>
        <span class="cov8" title="1">return binding[T]{RWLocker: rwlocker{l}, ptr: p}</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package jaws

import (
        "fmt"
        "html/template"
)

type binding[T comparable] struct {
        RWLocker
        ptr *T
}

func (bind binding[T]) JawsBinderPrev() Binder[T] <span class="cov8" title="1">{
        return nil
}</span>

func (bind binding[T]) JawsGetLocked(*Element) T <span class="cov8" title="1">{
        return *bind.ptr
}</span>

func (bind binding[T]) JawsGet(elem *Element) (value T) <span class="cov8" title="1">{
        bind.RWLocker.RLock()
        value = bind.JawsGetLocked(elem)
        bind.RWLocker.RUnlock()
        return
}</span>

func (bind binding[T]) JawsSetLocked(elem *Element, value T) (err error) <span class="cov8" title="1">{
        if value != *bind.ptr </span><span class="cov8" title="1">{
                *bind.ptr = value
                return nil
        }</span>
        <span class="cov8" title="1">return ErrValueUnchanged</span>
}

func (bind binding[T]) JawsSet(elem *Element, value T) (err error) <span class="cov8" title="1">{
        bind.RWLocker.Lock()
        err = bind.JawsSetLocked(elem, value)
        bind.RWLocker.Unlock()
        return
}</span>

func (bind binding[T]) JawsGetTag(*Request) any <span class="cov8" title="1">{
        return bind.ptr
}</span>

// SetLocked returns a Binder[T] that will call fn instead of JawsSetLocked.
//
// The lock will be held at this point.
// Do not lock or unlock the Binder within fn. Do not call JawsSet.
//
// The bind argument to the function is the previous Binder in the chain,
// and you probably want to call it's JawsSetLocked first.
func (bind binding[T]) SetLocked(fn BindSetHook[T]) Binder[T] <span class="cov8" title="1">{
        return bindingHook[T]{
                Binder: bind,
                hook:   fn,
        }
}</span>

// GetLocked returns a Binder[T] that will call fn instead of JawsGetLocked.
//
// The lock will be held at this point, preferring RLock over Lock, if available.
// Do not lock or unlock the Binder within fn. Do not call JawsGet.
//
// The bind argument to the function is the previous Binder in the chain,
// and you probably want to call it's JawsGetLocked first.
func (bind binding[T]) GetLocked(fn BindGetHook[T]) Binder[T] <span class="cov8" title="1">{
        return bindingHook[T]{
                Binder: bind,
                hook:   fn,
        }
}</span>

// Success returns a Binder[T] that will call fn after the value has been set
// with no errors. No locks are held when the function is called.
// If the function returns an error, that will be returned from JawsSet.
//
// The function must have one of the following signatures:
//   - func()
//   - func() error
//   - func(*Element)
//   - func(*Element) error
func (bind binding[T]) Success(fn any) Binder[T] <span class="cov8" title="1">{
        return bindingHook[T]{
                Binder: bind,
                hook:   wrapSuccessHook(fn),
        }
}</span>

// Format returns a Getter[string] using fmt.Sprintf(f, JawsGet[T](elem))
func (bind binding[T]) Format(f string) (getter Getter[string]) <span class="cov8" title="1">{
        return StringGetterFunc(func(elem *Element) (s string) </span><span class="cov8" title="1">{ return fmt.Sprintf(f, bind.JawsGet(elem)) }</span>, bind)
}

// FormatHTML returns a HTMLGetter using fmt.Sprintf(f, JawsGet[T](elem)).
// Ensure that the generated string is valid HTML.
func (bind binding[T]) FormatHTML(f string) (getter HTMLGetter) <span class="cov8" title="1">{
        return HTMLGetterFunc(func(elem *Element) (tmpl template.HTML) </span><span class="cov8" title="1">{
                return template.HTML( /*#nosec G203*/ fmt.Sprintf(f, bind.JawsGet(elem)))
        }</span>, bind)
}

func wrapSuccessHook(fn any) (hook BindSuccessHook) <span class="cov8" title="1">{
        switch fn := fn.(type) </span>{
        case func():<span class="cov8" title="1">
                return func(*Element) error </span><span class="cov8" title="1">{
                        fn()
                        return nil
                }</span>
        case func() error:<span class="cov8" title="1">
                return func(*Element) error </span><span class="cov8" title="1">{
                        return fn()
                }</span>
        case func(*Element):<span class="cov8" title="1">
                return func(elem *Element) error </span><span class="cov8" title="1">{
                        fn(elem)
                        return nil
                }</span>
        case func(*Element) error:<span class="cov8" title="1">
                return fn</span>
        }
        <span class="cov8" title="1">panic("Binding[T].Success(): function has wrong signature")</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package jaws

import (
        "fmt"
        "html/template"
)

type bindingHook[T comparable] struct {
        Binder[T]
        hook any // one of: BindGetHook[T] BindSetHook[T] BindSuccessHook
}

func (bind bindingHook[T]) JawsBinderPrev() Binder[T] <span class="cov8" title="1">{
        return bind.Binder
}</span>

func (bind bindingHook[T]) JawsGetLocked(elem *Element) T <span class="cov8" title="1">{
        if fn, ok := bind.hook.(BindGetHook[T]); ok </span><span class="cov8" title="1">{
                return fn(bind.Binder, elem)
        }</span>
        <span class="cov8" title="1">return bind.Binder.JawsGetLocked(elem)</span>
}

func (bind bindingHook[T]) JawsGet(elem *Element) T <span class="cov8" title="1">{
        bind.RLock()
        defer bind.RUnlock()
        return bind.JawsGetLocked(elem)
}</span>

func (bind bindingHook[T]) JawsSetLocked(elem *Element, value T) error <span class="cov8" title="1">{
        if fn, ok := bind.hook.(BindSetHook[T]); ok </span><span class="cov8" title="1">{
                return fn(bind.Binder, elem, value)
        }</span>
        <span class="cov8" title="1">return bind.Binder.JawsSetLocked(elem, value)</span>
}

func (bind bindingHook[T]) jawsSetLocking(elem *Element, value T) (err error) <span class="cov8" title="1">{
        bind.Lock()
        defer bind.Unlock()
        return bind.JawsSetLocked(elem, value)
}</span>

func callSuccess[T comparable](binder Binder[T], elem *Element) (err error) <span class="cov8" title="1">{
        if prev := binder.JawsBinderPrev(); prev != nil </span><span class="cov8" title="1">{
                err = callSuccess(prev, elem)
        }</span>
        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                if bind, ok := binder.(bindingHook[T]); ok </span><span class="cov8" title="1">{
                        if fn, ok := bind.hook.(BindSuccessHook); ok </span><span class="cov8" title="1">{
                                return fn(elem)
                        }</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

func (bind bindingHook[T]) JawsSet(elem *Element, value T) (err error) <span class="cov8" title="1">{
        if err = bind.jawsSetLocking(elem, value); err == nil </span><span class="cov8" title="1">{
                err = callSuccess(bind, elem)
        }</span>
        <span class="cov8" title="1">return</span>
}

// SetLocked returns a Binder[T] that will call fn instead of JawsSetLocked.
//
// The lock will be held at this point.
// Do not lock or unlock the Binder within fn. Do not call JawsSet.
//
// The bind argument to the function is the previous Binder in the chain,
// and you probably want to call it's JawsSetLocked first.
func (bind bindingHook[T]) SetLocked(setFn BindSetHook[T]) Binder[T] <span class="cov8" title="1">{
        return bindingHook[T]{
                Binder: bind,
                hook:   setFn,
        }
}</span>

// GetLocked returns a Binder[T] that will call fn instead of JawsGetLocked.
//
// The lock will be held at this point, preferring RLock over Lock, if available.
// Do not lock or unlock the Binder within fn. Do not call JawsGet.
//
// The bind argument to the function is the previous Binder in the chain,
// and you probably want to call it's JawsGetLocked first.
func (bind bindingHook[T]) GetLocked(setFn BindGetHook[T]) Binder[T] <span class="cov8" title="1">{
        return bindingHook[T]{
                Binder: bind,
                hook:   setFn,
        }
}</span>

// Success returns a Binder[T] that will call fn after the value has been set
// with no errors. No locks are held when the function is called.
// If the function returns an error, that will be returned from JawsSet.
//
// The function must have one of the following signatures:
//   - func()
//   - func() error
//   - func(*Element)
//   - func(*Element) error
func (bind bindingHook[T]) Success(fn any) Binder[T] <span class="cov8" title="1">{
        return bindingHook[T]{
                Binder: bind,
                hook:   wrapSuccessHook(fn),
        }
}</span>

// Format returns a Getter[string] using fmt.Sprintf(f, JawsGet[T](elem))
func (bind bindingHook[T]) Format(f string) (getter Getter[string]) <span class="cov8" title="1">{
        return StringGetterFunc(func(elem *Element) (s string) </span><span class="cov8" title="1">{ return fmt.Sprintf(f, bind.JawsGet(elem)) }</span>, bind)
}

// FormatHTML returns a HTMLGetter using fmt.Sprintf(f, JawsGet[T](elem)).
// Ensure that the generated string is valid HTML.
func (bind bindingHook[T]) FormatHTML(f string) (getter HTMLGetter) <span class="cov8" title="1">{
        return HTMLGetterFunc(func(elem *Element) (tmpl template.HTML) </span><span class="cov8" title="1">{
                return template.HTML( /*#nosec G203*/ fmt.Sprintf(f, bind.JawsGet(elem)))
        }</span>, bind)
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package jaws

import "github.com/linkdata/jaws/what"

type ClickHandler interface {
        // JawsClick is called when an Element's HTML element or something within it
        // is clicked in the browser.
        //
        // The name parameter is taken from the first 'name' HTML attribute or HTML
        // 'button' textContent found when traversing the DOM. It may be empty.
        JawsClick(e *Element, name string) (err error)
}

type clickHandlerWapper struct{ ClickHandler }

func (chw clickHandlerWapper) JawsEvent(e *Element, w what.What, v string) error <span class="cov8" title="1">{
        if w == what.Click </span><span class="cov8" title="1">{
                return chw.JawsClick(e, v)
        }</span>
        <span class="cov8" title="1">return ErrEventUnhandled</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package jaws

import (
        "os"
        "path/filepath"
        "strings"
)

// DefaultCookieName holds the default JaWS cookie name.
// It will be generated from the executable name, or "jaws" if that fails.
var DefaultCookieName string

func init() <span class="cov8" title="1">{
        exename, _ := os.Executable()
        DefaultCookieName = makeCookieName(exename)
}</span>

func makeCookieName(exename string) (cookie string) <span class="cov8" title="1">{
        cookie = "jaws"
        exename = filepath.Base(exename)
        exename = strings.TrimSuffix(exename, filepath.Ext(exename))
        var b []byte
        for _, ch := range exename </span><span class="cov8" title="1">{
                if ('a' &lt;= ch &amp;&amp; ch &lt;= 'z') || ('A' &lt;= ch &amp;&amp; ch &lt;= 'Z') || ('0' &lt;= ch &amp;&amp; ch &lt;= '9') </span><span class="cov8" title="1">{
                        b = append(b, byte(ch))
                }</span>
        }
        <span class="cov8" title="1">if len(b) &gt; 0 </span><span class="cov8" title="1">{
                cookie = string(b)
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package jaws

import (
        "bytes"
        "errors"
        "fmt"
        "html/template"
        "io"
        "strings"

        "github.com/linkdata/jaws/jid"
        "github.com/linkdata/jaws/what"
)

// An Element is an instance of a *Request, an UI object and a Jid.
type Element struct {
        *Request // (read-only) the Request the Element belongs to
        // internals
        ui       UI             // the UI object
        handlers []EventHandler // custom event handlers registered, if any
        jid      jid.Jid        // JaWS ID, unique to this Element within it's Request
        deleted  bool           // true if deleteElement() has been called for this Element
}

func (e *Element) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("Element{%T, id=%q, Tags: %v}", e.Ui(), e.Jid(), e.Request.TagsOf(e))
}</span>

// Tag adds the given tags to the Element.
func (e *Element) Tag(tags ...any) <span class="cov8" title="1">{
        if !e.deleted </span><span class="cov8" title="1">{
                e.Request.Tag(e, tags...)
        }</span>
}

// HasTag returns true if this Element has the given tag.
func (e *Element) HasTag(tag any) bool <span class="cov8" title="1">{
        return !e.deleted &amp;&amp; e.Request.HasTag(e, tag)
}</span>

// Jid returns the JaWS ID for this Element, unique within it's Request.
func (e *Element) Jid() jid.Jid <span class="cov8" title="1">{
        return e.jid
}</span>

// Ui returns the UI object.
func (e *Element) Ui() UI <span class="cov8" title="1">{
        return e.ui
}</span>

func (e *Element) maybeDirty(tag any, err error) (bool, error) <span class="cov8" title="1">{
        switch err </span>{
        case nil:<span class="cov8" title="1">
                e.Dirty(tag)
                return true, nil</span>
        case ErrValueUnchanged:<span class="cov8" title="1">
                return false, nil</span>
        }
        <span class="cov8" title="1">return false, err</span>
}

func (e *Element) renderDebug(w io.Writer) <span class="cov8" title="1">{
        var sb strings.Builder
        _, _ = fmt.Fprintf(&amp;sb, "&lt;!-- id=%q %T tags=[", e.Jid(), e.Ui())
        if e.mu.TryRLock() </span><span class="cov8" title="1">{
                defer e.mu.RUnlock()
                for i, tag := range e.tagsOfLocked(e) </span><span class="cov8" title="1">{
                        if i &gt; 0 </span><span class="cov8" title="1">{
                                sb.WriteString(", ")
                        }</span>
                        <span class="cov8" title="1">sb.WriteString(TagString(tag))</span>
                }
        } else<span class="cov8" title="1"> {
                sb.WriteString("n/a")
        }</span>
        <span class="cov8" title="1">sb.WriteByte(']')
        _, _ = w.Write([]byte(strings.ReplaceAll(sb.String(), "--&gt;", "==&gt;") + " --&gt;"))</span>
}

// JawsRender calls Ui().JawsRender() for this Element.
//
// Do not call this yourself unless it's from within another JawsRender implementation.
func (e *Element) JawsRender(w io.Writer, params []any) (err error) <span class="cov8" title="1">{
        if !e.deleted </span><span class="cov8" title="1">{
                if err = e.Ui().JawsRender(e, w, params); err == nil </span><span class="cov8" title="1">{
                        if e.Jaws.Debug </span><span class="cov8" title="1">{
                                e.renderDebug(w)
                        }</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

// JawsUpdate calls Ui().JawsUpdate() for this Element.
//
// Do not call this yourself unless it's from within another JawsUpdate implementation.
func (e *Element) JawsUpdate() <span class="cov8" title="1">{
        if !e.deleted </span><span class="cov8" title="1">{
                e.Ui().JawsUpdate(e)
        }</span>
}

func (e *Element) queue(wht what.What, data string) <span class="cov8" title="1">{
        if !e.deleted </span><span class="cov8" title="1">{
                e.Request.queue(wsMsg{
                        Data: data,
                        Jid:  e.jid,
                        What: wht,
                })
        }</span>
}

// SetAttr queues sending a new attribute value
// to the browser for the Element with the given JaWS ID in this Request.
//
// Call this only during JawsRender() or JawsUpdate() processing.
func (e *Element) SetAttr(attr, val string) <span class="cov8" title="1">{
        e.queue(what.SAttr, attr+"\n"+val)
}</span>

// RemoveAttr queues sending a request to remove an attribute
// to the browser for the Element with the given JaWS ID in this Request.
//
// Call this only during JawsRender() or JawsUpdate() processing.
func (e *Element) RemoveAttr(attr string) <span class="cov8" title="1">{
        e.queue(what.RAttr, attr)
}</span>

// SetClass a queues sending a class
// to the browser for the Element with the given JaWS ID in this Request.
//
// Call this only during JawsRender() or JawsUpdate() processing.
func (e *Element) SetClass(cls string) <span class="cov8" title="1">{
        e.queue(what.SClass, cls)
}</span>

// RemoveClass queues sending a request to remove a class
// to the browser for the Element with the given JaWS ID in this Request.
//
// Call this only during JawsRender() or JawsUpdate() processing.
func (e *Element) RemoveClass(cls string) <span class="cov8" title="1">{
        e.queue(what.RClass, cls)
}</span>

// SetInner queues sending a new inner HTML content
// to the browser for the Element.
//
// Call this only during JawsRender() or JawsUpdate() processing.
func (e *Element) SetInner(innerHTML template.HTML) <span class="cov8" title="1">{
        e.queue(what.Inner, string(innerHTML))
}</span>

// SetValue queues sending a new current input value in textual form
// to the browser for the Element with the given JaWS ID in this Request.
//
// Call this only during JawsRender() or JawsUpdate() processing.
func (e *Element) SetValue(val string) <span class="cov8" title="1">{
        e.queue(what.Value, val)
}</span>

// Replace replaces the elements entire HTML DOM node with new HTML code.
// If the HTML code doesn't seem to contain correct HTML ID, it panics.
//
// Call this only during JawsRender() or JawsUpdate() processing.
func (e *Element) Replace(htmlCode template.HTML) <span class="cov8" title="1">{
        if !e.deleted </span><span class="cov8" title="1">{
                var b []byte
                b = append(b, "id="...)
                b = e.Jid().AppendQuote(b)
                if !bytes.Contains([]byte(htmlCode), b) </span><span class="cov8" title="1">{
                        panic(errors.New("jaws: Element.Replace(): expected HTML " + string(b)))</span>
                }
                <span class="cov8" title="1">e.queue(what.Replace, string(htmlCode))</span>
        }
}

// Append appends a new HTML element as a child to the current one.
//
// Call this only during JawsRender() or JawsUpdate() processing.
func (e *Element) Append(htmlCode template.HTML) <span class="cov8" title="1">{
        e.queue(what.Append, string(htmlCode))
}</span>

// Order reorders the HTML elements.
//
// Call this only during JawsRender() or JawsUpdate() processing.
func (e *Element) Order(jidList []jid.Jid) <span class="cov8" title="1">{
        if !e.deleted &amp;&amp; len(jidList) &gt; 0 </span><span class="cov8" title="1">{
                var b []byte
                for i, jid := range jidList </span><span class="cov8" title="1">{
                        if i &gt; 0 </span><span class="cov8" title="1">{
                                b = append(b, ' ')
                        }</span>
                        <span class="cov8" title="1">b = jid.Append(b)</span>
                }
                <span class="cov8" title="1">e.queue(what.Order, string(b))</span>
        }
}

// Remove requests that the HTML child with the given HTML ID of this Element
// is removed from the Request and it's HTML element from the browser.
//
// Call this only during JawsRender() or JawsUpdate() processing.
func (e *Element) Remove(htmlId string) <span class="cov8" title="1">{
        e.queue(what.Remove, htmlId)
}</span>

// ApplyParams parses the parameters passed to UI() when creating a new Element,
// adding UI tags, adding any additional event handlers found.
//
// Returns the list of HTML attributes found, if any.
func (e *Element) ApplyParams(params []any) (retv []template.HTMLAttr) <span class="cov8" title="1">{
        tags, handlers, attrs := ParseParams(params)
        if !e.deleted </span><span class="cov8" title="1">{
                e.handlers = append(e.handlers, handlers...)
                e.Tag(tags...)
                for _, s := range attrs </span><span class="cov8" title="1">{
                        attr := template.HTMLAttr(s) // #nosec G203
                        retv = append(retv, attr)
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// ApplyGetter examines getter, and if it's not nil, either adds it
// as a Tag, or, if it is a TagGetter, adds the result of that as a Tag.
//
// If getter is a ClickHandler or an EventHandler, it's added to the
// list of handlers for the Element.
//
// Finally, if getter is an InitHandler, it's JawsInit()
// function is called.
//
// Returns the Tag added, or nil if getter was nil, along with
// any error returned from JawsInit() if it was called.
func (e *Element) ApplyGetter(getter any) (tag any, err error) <span class="cov8" title="1">{
        if getter != nil </span><span class="cov8" title="1">{
                tag = getter
                if tagger, ok := getter.(TagGetter); ok </span><span class="cov8" title="1">{
                        tag = tagger.JawsGetTag(e.Request)
                }</span>
                <span class="cov8" title="1">e.Tag(tag)
                if ch, ok := getter.(ClickHandler); ok </span><span class="cov8" title="1">{
                        e.handlers = append(e.handlers, clickHandlerWapper{ch})
                }</span>
                <span class="cov8" title="1">if eh, ok := getter.(EventHandler); ok </span><span class="cov8" title="1">{
                        e.handlers = append(e.handlers, eh)
                }</span>
                <span class="cov8" title="1">if initer, ok := getter.(InitHandler); ok </span><span class="cov8" title="1">{
                        err = initer.JawsInit(e)
                }</span>
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package jaws

import "fmt"

// ErrIllegalTagType is returned when a UI tag type is disallowed
var ErrIllegalTagType errIllegalTagType

type errIllegalTagType struct {
        tag any
}

func (e errIllegalTagType) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("illegal tag type %T", e.tag)
}</span>

func (errIllegalTagType) Is(other error) bool <span class="cov8" title="1">{
        return other == ErrIllegalTagType
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package jaws

import (
        "strconv"
)

// ErrMissingTemplate is returned when trying to render an undefined template by name.
var ErrMissingTemplate errMissingTemplate

type errMissingTemplate string

func (e errMissingTemplate) Error() string <span class="cov8" title="1">{
        return "missing template " + strconv.Quote(string(e))
}</span>

func (errMissingTemplate) Is(target error) bool <span class="cov8" title="1">{
        return target == ErrMissingTemplate
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package jaws

import (
        "reflect"
)

// ErrNotComparable is returned when a UI object or tag is not comparable.
var ErrNotComparable errNotComparable

type errNotComparable struct {
        t reflect.Type
}

func (e errNotComparable) Error() string <span class="cov8" title="1">{
        return e.t.String() + " is not comparable"
}</span>

func (errNotComparable) Is(target error) bool <span class="cov8" title="1">{
        return target == ErrNotComparable
}</span>

func newErrNotComparable(x any) error <span class="cov8" title="1">{
        if t := reflect.TypeOf(x); !t.Comparable() </span><span class="cov8" title="1">{
                return errNotComparable{t: t}
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package jaws

import (
        "fmt"
        "net/netip"
)

// ErrNoWebSocketRequest is returned when the WebSocket callback was not received
// within the timeout period. Most common reason is that client is not using
// Javascript.
var ErrNoWebSocketRequest errNoWebSocketRequest

type errNoWebSocketRequest struct {
        netip.Addr
}

func (e errNoWebSocketRequest) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("no WebSocket request received from %v", e.Addr)
}</span>

func (e errNoWebSocketRequest) Is(target error) bool <span class="cov8" title="1">{
        return target == ErrNoWebSocketRequest
}</span>

func newErrNoWebSocketRequest(rq *Request) error <span class="cov8" title="1">{
        return errNoWebSocketRequest{Addr: rq.remoteIP}
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package jaws

import (
        "fmt"
)

// ErrPendingCancelled indicates a pending Request was cancelled. Use Unwrap() to see the underlying cause.
var ErrPendingCancelled errPendingCancelled

type errPendingCancelled struct {
        JawsKey uint64
        Cause   error
        Initial string
}

func (e errPendingCancelled) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("Request&lt;%s&gt;:%s %v", JawsKeyString(e.JawsKey), e.Initial, e.Cause)
}</span>

func (e errPendingCancelled) Is(target error) (yes bool) <span class="cov8" title="1">{
        return target == ErrPendingCancelled
}</span>

func (e errPendingCancelled) Unwrap() error <span class="cov8" title="1">{
        return e.Cause
}</span>

func newErrPendingCancelledLocked(rq *Request, cause error) (err error) <span class="cov8" title="1">{
        var initial string
        if rq.initial != nil </span><span class="cov8" title="1">{
                initial = fmt.Sprintf(" %s %q:", rq.initial.Method, rq.initial.RequestURI)
        }</span>
        <span class="cov8" title="1">return errPendingCancelled{
                JawsKey: rq.JawsKey,
                Cause:   cause,
                Initial: initial,
        }</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package jaws

import (
        "github.com/linkdata/jaws/what"
)

type EventHandler interface {
        JawsEvent(e *Element, wht what.What, val string) (err error)
}

type errEventUnhandled struct{}

func (errEventUnhandled) Error() string <span class="cov8" title="1">{
        return "event unhandled"
}</span>

// ErrEventUnhandled returned by JawsEvent() or JawsClick() causes the next
// available handler to be invoked.
var ErrEventUnhandled = errEventUnhandled{}

// EventFn is the signature of a event handling function to be called when JaWS receives
// an event message from the Javascript via the WebSocket connection.
type EventFn = func(e *Element, wht what.What, val string) (err error)

type eventFnWrapper struct{ EventFn }

func (ehf eventFnWrapper) JawsEvent(e *Element, w what.What, v string) (err error) <span class="cov8" title="1">{
        return ehf.EventFn(e, w, v)
}</span>

var _ EventFn = eventFnWrapper{}.JawsEvent // statically ensure JawsEvent and EventFn are compatible

func callEventHandler(obj any, e *Element, wht what.What, val string) (err error) <span class="cov8" title="1">{
        if wht == what.Click </span><span class="cov8" title="1">{
                if h, ok := obj.(ClickHandler); ok </span><span class="cov8" title="1">{
                        if err = h.JawsClick(e, val); err != ErrEventUnhandled </span><span class="cov8" title="1">{
                                return
                        }</span>
                }
        }
        <span class="cov8" title="1">if h, ok := obj.(EventHandler); ok </span><span class="cov8" title="1">{
                return h.JawsEvent(e, wht, val)
        }</span>
        <span class="cov8" title="1">return ErrEventUnhandled</span>
}

func callEventHandlers(ui any, e *Element, wht what.What, val string) (err error) <span class="cov8" title="1">{
        if err = callEventHandler(ui, e, wht, val); err == ErrEventUnhandled </span><span class="cov8" title="1">{
                for _, h := range e.handlers </span><span class="cov8" title="1">{
                        if err = callEventHandler(h, e, wht, val); err != ErrEventUnhandled </span><span class="cov8" title="1">{
                                return
                        }</span>
                }
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package jaws

import (
        "errors"
        "fmt"
)

var ErrValueNotSettable = errors.New("value not settable")

type Getter[T comparable] interface {
        JawsGet(elem *Element) (value T)
}

type getterStatic[T comparable] struct {
        v T
}

func (getterStatic[T]) JawsSet(*Element, T) error <span class="cov8" title="1">{
        return ErrValueNotSettable
}</span>

func (s getterStatic[T]) JawsGet(*Element) T <span class="cov8" title="1">{
        return s.v
}</span>

func (s getterStatic[T]) JawsGetTag(*Request) any <span class="cov8" title="1">{
        return nil
}</span>

func makeStaticGetter[T comparable](v T) Getter[T] <span class="cov8" title="1">{
        return getterStatic[T]{v}
}</span>

func makeGetter[T comparable](v any) Getter[T] <span class="cov8" title="1">{
        switch v := v.(type) </span>{
        case Getter[T]:<span class="cov8" title="1">
                return v</span>
        case T:<span class="cov8" title="1">
                return makeStaticGetter(v)</span>
        }
        <span class="cov8" title="1">var blank T
        panic(fmt.Errorf("expected jaws.Getter[%T] or %T not %T", blank, blank, v))</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package jaws

import "net/http"

// Handler implements ServeHTTP with a jaws.Template
type Handler struct {
        *Jaws
        Template
}

func (h Handler) ServeHTTP(wr http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        _ = h.Log(h.NewRequest(r).NewElement(h.Template).JawsRender(wr, nil))
}</span>

// Handler returns a http.Handler using a jaws.Template
func (jw *Jaws) Handler(name string, dot any) http.Handler <span class="cov8" title="1">{
        return Handler{Jaws: jw, Template: Template{Name: name, Dot: dot}}
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package jaws

import "html/template"

type htmlGetterFunc struct {
        fn   func(*Element) template.HTML
        tags []any
}

var _ TagGetter = &amp;htmlGetterFunc{}

func (g *htmlGetterFunc) JawsGetHTML(e *Element) template.HTML <span class="cov8" title="1">{
        return g.fn(e)
}</span>

func (g *htmlGetterFunc) JawsGetTag(e *Request) any <span class="cov8" title="1">{
        return g.tags
}</span>

// HTMLGetterFunc wraps a function and returns a HTMLGetter.
func HTMLGetterFunc(fn func(elem *Element) (tmpl template.HTML), tags ...any) HTMLGetter <span class="cov8" title="1">{
        return &amp;htmlGetterFunc{fn: fn, tags: tags}
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">// package jaws provides a mechanism to create dynamic
// webpages using Javascript and WebSockets.
//
// It integrates well with Go's html/template package,
// but can be used without it. It can be used with any
// router that supports the standard ServeHTTP interface.
package jaws

import (
        "bufio"
        "context"
        "crypto/rand"
        "encoding/binary"
        "errors"
        "fmt"
        "html/template"
        "io"
        "net"
        "net/http"
        "net/netip"
        "net/textproto"
        "net/url"
        "slices"
        "sort"
        "strconv"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/linkdata/deadlock"
        "github.com/linkdata/jaws/jid"
        "github.com/linkdata/jaws/staticserve"
        "github.com/linkdata/jaws/what"
)

const (
        DefaultUpdateInterval = time.Millisecond * 100 // Default browser update interval
)

type Jid = jid.Jid // convenience alias

type Jaws struct {
        CookieName   string          // Name for session cookies, defaults to "jaws"
        Logger       Logger          // Optional logger to use
        Debug        bool            // Set to true to enable debug info in generated HTML code
        MakeAuth     MakeAuthFn      // Optional function to create With.Auth for Templates
        BaseContext  context.Context // Base context for Requests, default is context.Background()
        bcastCh      chan Message
        subCh        chan subscription
        unsubCh      chan chan Message
        updateTicker *time.Ticker
        headPrefix   string
        faviconURL   string
        reqPool      sync.Pool
        serveJS      *staticserve.StaticServe
        serveCSS     *staticserve.StaticServe
        mu           deadlock.RWMutex // protects following
        tmplookers   []TemplateLookuper
        kg           *bufio.Reader
        closeCh      chan struct{} // closed when Close() has been called
        requests     map[uint64]*Request
        sessions     map[uint64]*Session
        dirty        map[any]int
        dirtOrder    int
}

func New() (jw *Jaws, err error) <span class="cov8" title="1">{
        var serveJS, serveCSS *staticserve.StaticServe
        if serveJS, err = staticserve.New("/jaws/.jaws.js", JavascriptText); err == nil </span><span class="cov8" title="1">{
                if serveCSS, err = staticserve.New("/jaws/.jaws.css", JawsCSS); err == nil </span><span class="cov8" title="1">{
                        tmp := &amp;Jaws{
                                CookieName:   DefaultCookieName,
                                BaseContext:  context.Background(),
                                serveJS:      serveJS,
                                serveCSS:     serveCSS,
                                bcastCh:      make(chan Message, 1),
                                subCh:        make(chan subscription, 1),
                                unsubCh:      make(chan chan Message, 1),
                                updateTicker: time.NewTicker(DefaultUpdateInterval),
                                kg:           bufio.NewReader(rand.Reader),
                                requests:     make(map[uint64]*Request),
                                sessions:     make(map[uint64]*Session),
                                dirty:        make(map[any]int),
                                closeCh:      make(chan struct{}),
                        }
                        if err = tmp.GenerateHeadHTML(); err == nil </span><span class="cov8" title="1">{
                                jw = tmp
                                jw.reqPool.New = func() any </span><span class="cov8" title="1">{
                                        return (&amp;Request{
                                                Jaws:   jw,
                                                tagMap: make(map[any][]*Element),
                                        }).clearLocked()
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return</span>
}

// Close frees resources associated with the JaWS object, and
// closes the completion channel if the JaWS was created with New().
// Once the completion channel is closed, broadcasts and sends may be discarded.
// Subsequent calls to Close() have no effect.
func (jw *Jaws) Close() <span class="cov8" title="1">{
        jw.mu.Lock()
        select </span>{
        case &lt;-jw.closeCh:<span class="cov8" title="1"></span>
                // already closed
        default:<span class="cov8" title="1">
                close(jw.closeCh)</span>
        }
        <span class="cov8" title="1">jw.updateTicker.Stop()
        jw.mu.Unlock()</span>
}

// Done returns the channel that is closed when Close has been called.
func (jw *Jaws) Done() &lt;-chan struct{} <span class="cov8" title="1">{
        return jw.closeCh
}</span>

// AddTemplateLookuper adds an object that can resolve
// strings to *template.Template.
func (jw *Jaws) AddTemplateLookuper(tl TemplateLookuper) <span class="cov8" title="1">{
        if tl != nil </span><span class="cov8" title="1">{
                jw.mu.Lock()
                if !slices.Contains(jw.tmplookers, tl) </span><span class="cov8" title="1">{
                        jw.tmplookers = append(jw.tmplookers, tl)
                }</span>
                <span class="cov8" title="1">jw.mu.Unlock()</span>
        }
}

// RemoveTemplateLookuper removes the given object from
// the list of TemplateLookupers.
func (jw *Jaws) RemoveTemplateLookuper(tl TemplateLookuper) <span class="cov8" title="1">{
        if tl != nil </span><span class="cov8" title="1">{
                jw.mu.Lock()
                jw.tmplookers = slices.DeleteFunc(jw.tmplookers, func(x TemplateLookuper) bool </span><span class="cov8" title="1">{ return x == tl }</span>)
                <span class="cov8" title="1">jw.mu.Unlock()</span>
        }
}

// LookupTemplate queries the known TemplateLookupers in the order
// they were added and returns the first found.
func (jw *Jaws) LookupTemplate(name string) *template.Template <span class="cov8" title="1">{
        jw.mu.RLock()
        defer jw.mu.RUnlock()
        for _, tl := range jw.tmplookers </span><span class="cov8" title="1">{
                if t := tl.Lookup(name); t != nil </span><span class="cov8" title="1">{
                        return t
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// RequestCount returns the number of Requests.
//
// The count includes all Requests, including those being rendered,
// those waiting for the WebSocket callback and those active.
func (jw *Jaws) RequestCount() (n int) <span class="cov8" title="1">{
        jw.mu.RLock()
        n = len(jw.requests)
        jw.mu.RUnlock()
        return
}</span>

// Log sends an error to the Logger set in the Jaws.
// Has no effect if the err is nil or the Logger is nil.
// Returns err.
func (jw *Jaws) Log(err error) error <span class="cov8" title="1">{
        if err != nil &amp;&amp; jw != nil &amp;&amp; jw.Logger != nil </span><span class="cov8" title="1">{
                jw.Logger.Error("jaws", "err", err)
        }</span>
        <span class="cov8" title="1">return err</span>
}

// MustLog sends an error to the Logger set in the Jaws or
// panics with the given error if no Logger is set.
// Has no effect if the err is nil.
func (jw *Jaws) MustLog(err error) <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                if jw != nil &amp;&amp; jw.Logger != nil </span><span class="cov8" title="1">{
                        jw.Logger.Error("jaws", "err", err)
                }</span> else<span class="cov8" title="1"> {
                        panic(err)</span>
                }
        }
}

// NextID returns a uint64 unique within lifetime of the program.
func NextID() int64 <span class="cov8" title="1">{
        return atomic.AddInt64((*int64)(&amp;nextJid), 1)
}</span>

// AppendID appends the result of NextID() in text form to the given slice.
func AppendID(b []byte) []byte <span class="cov8" title="1">{
        return strconv.AppendInt(b, NextID(), 32)
}</span>

// MakeID returns a string in the form 'jaws.X' where X is a unique string within lifetime of the program.
func MakeID() string <span class="cov8" title="1">{
        return string(AppendID([]byte("jaws.")))
}</span>

// NewRequest returns a new pending JaWS request that times out after 10 seconds.
//
// Call this as soon as you start processing a HTML request, and store the
// returned Request pointer so it can be used while constructing the HTML
// response in order to register the JaWS id's you use in the response, and
// use it's Key attribute when sending the Javascript portion of the reply.
func (jw *Jaws) NewRequest(hr *http.Request) (rq *Request) <span class="cov8" title="1">{
        jw.mu.Lock()
        defer jw.mu.Unlock()
        for rq == nil </span><span class="cov8" title="1">{
                jawsKey := jw.nonZeroRandomLocked()
                if _, ok := jw.requests[jawsKey]; !ok </span><span class="cov8" title="1">{
                        rq = jw.getRequestLocked(jawsKey, hr)
                        jw.requests[jawsKey] = rq
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func (jw *Jaws) nonZeroRandomLocked() (val uint64) <span class="cov8" title="1">{
        random := make([]byte, 8)
        for val == 0 </span><span class="cov8" title="1">{
                if _, err := io.ReadFull(jw.kg, random); err != nil </span><span class="cov8" title="1">{
                        panic(err)</span>
                }
                <span class="cov8" title="1">val = binary.LittleEndian.Uint64(random)</span>
        }
        <span class="cov8" title="1">return</span>
}

// UseRequest extracts the JaWS request with the given key from the request
// map if it exists and the HTTP request remote IP matches.
//
// Call it when receiving the WebSocket connection on '/jaws/:key' to get the
// associated Request, and then call it's ServeHTTP method to process the
// WebSocket messages.
//
// Returns nil if the key was not found or the IP doesn't match, in which
// case you should return a HTTP "404 Not Found" status.
func (jw *Jaws) UseRequest(jawsKey uint64, hr *http.Request) (rq *Request) <span class="cov8" title="1">{
        if jawsKey != 0 </span><span class="cov8" title="1">{
                var err error
                jw.mu.Lock()
                if waitingRq, ok := jw.requests[jawsKey]; ok </span><span class="cov8" title="1">{
                        if err = waitingRq.claim(hr); err == nil </span><span class="cov8" title="1">{
                                rq = waitingRq
                        }</span>
                }
                <span class="cov8" title="1">jw.mu.Unlock()
                _ = jw.Log(err)</span>
        }
        <span class="cov8" title="1">return</span>
}

// SessionCount returns the number of active sessions.
func (jw *Jaws) SessionCount() (n int) <span class="cov8" title="1">{
        jw.mu.RLock()
        n = len(jw.sessions)
        jw.mu.RUnlock()
        return
}</span>

// Sessions returns a list of all active sessions, which may be nil.
func (jw *Jaws) Sessions() (sl []*Session) <span class="cov8" title="1">{
        jw.mu.RLock()
        if n := len(jw.sessions); n &gt; 0 </span><span class="cov8" title="1">{
                sl = make([]*Session, 0, n)
                for _, sess := range jw.sessions </span><span class="cov8" title="1">{
                        sl = append(sl, sess)
                }</span>
        }
        <span class="cov8" title="1">jw.mu.RUnlock()
        return</span>
}

func (jw *Jaws) getSessionLocked(sessIds []uint64, remoteIP netip.Addr) *Session <span class="cov8" title="1">{
        for _, sessId := range sessIds </span><span class="cov8" title="1">{
                if sess, ok := jw.sessions[sessId]; ok &amp;&amp; equalIP(remoteIP, sess.remoteIP) </span><span class="cov8" title="1">{
                        return sess
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func cutString(s string, sep byte) (before, after string) <span class="cov8" title="1">{
        if i := strings.IndexByte(s, sep); i &gt;= 0 </span><span class="cov8" title="1">{
                return s[:i], s[i+1:]
        }</span>
        <span class="cov8" title="1">return s, ""</span>
}

func getCookieSessionsIds(h http.Header, wanted string) (cookies []uint64) <span class="cov8" title="1">{
        for _, line := range h["Cookie"] </span><span class="cov8" title="1">{
                if strings.Contains(line, wanted) </span><span class="cov8" title="1">{
                        var part string
                        line = textproto.TrimString(line)
                        for len(line) &gt; 0 </span><span class="cov8" title="1">{
                                part, line = cutString(line, ';')
                                if part = textproto.TrimString(part); part != "" </span><span class="cov8" title="1">{
                                        name, val := cutString(part, '=')
                                        name = textproto.TrimString(name)
                                        if name == wanted </span><span class="cov8" title="1">{
                                                if len(val) &gt; 1 &amp;&amp; val[0] == '"' &amp;&amp; val[len(val)-1] == '"' </span><span class="cov8" title="1">{
                                                        val = val[1 : len(val)-1]
                                                }</span>
                                                <span class="cov8" title="1">if sessId := JawsKeyValue(val); sessId != 0 </span><span class="cov8" title="1">{
                                                        cookies = append(cookies, sessId)
                                                }</span>
                                        }
                                }
                        }
                }
        }
        <span class="cov8" title="1">return</span>
}

// GetSession returns the Session associated with the given *http.Request, or nil.
func (jw *Jaws) GetSession(hr *http.Request) (sess *Session) <span class="cov8" title="1">{
        if sessIds := getCookieSessionsIds(hr.Header, jw.CookieName); len(sessIds) &gt; 0 </span><span class="cov8" title="1">{
                remoteIP := parseIP(hr.RemoteAddr)
                jw.mu.RLock()
                sess = jw.getSessionLocked(sessIds, remoteIP)
                jw.mu.RUnlock()
        }</span>
        <span class="cov8" title="1">return</span>
}

// NewSession creates a new Session.
//
// Any pre-existing Session will be cleared and closed.
//
// Subsequent Requests created with `NewRequest()` that have the cookie set and
// originates from the same IP will be able to access the Session.
func (jw *Jaws) NewSession(w http.ResponseWriter, hr *http.Request) (sess *Session) <span class="cov8" title="1">{
        if oldSess := jw.GetSession(hr); oldSess != nil </span><span class="cov8" title="1">{
                oldSess.Clear()
                oldSess.Close()
        }</span>
        <span class="cov8" title="1">return jw.newSession(w, hr)</span>
}

func (jw *Jaws) newSession(w http.ResponseWriter, hr *http.Request) (sess *Session) <span class="cov8" title="1">{
        jw.mu.Lock()
        defer jw.mu.Unlock()
        for sess == nil </span><span class="cov8" title="1">{
                sessionID := jw.nonZeroRandomLocked()
                if _, ok := jw.sessions[sessionID]; !ok </span><span class="cov8" title="1">{
                        sess = newSession(jw, sessionID, parseIP(hr.RemoteAddr))
                        jw.sessions[sessionID] = sess
                        if w != nil </span><span class="cov8" title="1">{
                                http.SetCookie(w, &amp;sess.cookie)
                        }</span>
                        <span class="cov8" title="1">hr.AddCookie(&amp;sess.cookie)</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

func (jw *Jaws) deleteSession(sessionID uint64) <span class="cov8" title="1">{
        jw.mu.Lock()
        delete(jw.sessions, sessionID)
        jw.mu.Unlock()
}</span>

func (jw *Jaws) FaviconURL() string <span class="cov8" title="1">{
        return jw.faviconURL
}</span>

// GenerateHeadHTML (re-)generates the HTML code that goes in the HEAD section, ensuring
// that the provided URL resources in `extra` are loaded, along with the JaWS javascript.
// If one of the resources is named "favicon", it's URL will be stored and can
// be retrieved using FaviconURL().
//
// You only need to call this if you add your own images, scripts and stylesheets.
func (jw *Jaws) GenerateHeadHTML(extra ...string) (err error) <span class="cov8" title="1">{
        var jawsurl *url.URL
        if jawsurl, err = url.Parse(jw.serveJS.Name); err == nil </span><span class="cov8" title="1">{
                var cssurl *url.URL
                if cssurl, err = url.Parse(jw.serveCSS.Name); err == nil </span><span class="cov8" title="1">{
                        var urls []*url.URL
                        urls = append(urls, cssurl)
                        urls = append(urls, jawsurl)
                        for _, urlstr := range extra </span><span class="cov8" title="1">{
                                if u, e := url.Parse(urlstr); e == nil </span><span class="cov8" title="1">{
                                        if !strings.HasSuffix(u.Path, jawsurl.Path) </span><span class="cov8" title="1">{
                                                urls = append(urls, u)
                                        }</span>
                                } else<span class="cov8" title="1"> {
                                        err = errors.Join(e)
                                }</span>
                        }
                        <span class="cov8" title="1">jw.headPrefix, jw.faviconURL = PreloadHTML(urls...)
                        jw.headPrefix += `&lt;meta name="jawsKey" content="`</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

// Broadcast sends a message to all Requests.
func (jw *Jaws) Broadcast(msg Message) <span class="cov8" title="1">{
        select </span>{
        case &lt;-jw.Done():<span class="cov8" title="1"></span>
        case jw.bcastCh &lt;- msg:<span class="cov8" title="1"></span>
        }
}

// setDirty marks all Elements that have one or more of the given tags as dirty.
func (jw *Jaws) setDirty(tags []any) <span class="cov8" title="1">{
        jw.mu.Lock()
        defer jw.mu.Unlock()
        for _, tag := range tags </span><span class="cov8" title="1">{
                jw.dirtOrder++
                jw.dirty[tag] = jw.dirtOrder
        }</span>
}

// Dirty marks all Elements that have one or more of the given tags as dirty.
//
// Note that if any of the tags are a TagGetter, it will be called with a nil Request.
// Prefer using Request.Dirty() which avoids this.
func (jw *Jaws) Dirty(tags ...any) <span class="cov8" title="1">{
        jw.setDirty(MustTagExpand(nil, tags))
}</span>

func (jw *Jaws) distributeDirt() int <span class="cov8" title="1">{
        type orderedDirt struct {
                tag   any
                order int
        }

        jw.mu.Lock()
        dirt := make([]orderedDirt, 0, len(jw.dirty))
        for k, v := range jw.dirty </span><span class="cov8" title="1">{
                dirt = append(dirt, orderedDirt{tag: k, order: v})
                delete(jw.dirty, k)
        }</span>
        <span class="cov8" title="1">jw.dirtOrder = 0

        var reqs []*Request
        if len(dirt) &gt; 0 </span><span class="cov8" title="1">{
                reqs = make([]*Request, 0, len(jw.requests))
                for _, rq := range jw.requests </span><span class="cov8" title="1">{
                        reqs = append(reqs, rq)
                }</span>
        }
        <span class="cov8" title="1">jw.mu.Unlock()

        if len(dirt) &gt; 0 </span><span class="cov8" title="1">{
                sort.Slice(dirt, func(i, j int) bool </span><span class="cov8" title="1">{ return dirt[i].order &lt; dirt[j].order }</span>)
                <span class="cov8" title="1">tags := make([]any, len(dirt))
                for i := range dirt </span><span class="cov8" title="1">{
                        tags[i] = dirt[i].tag
                }</span>
                <span class="cov8" title="1">for _, rq := range reqs </span><span class="cov8" title="1">{
                        rq.appendDirtyTags(tags)
                }</span>
        }
        <span class="cov8" title="1">return len(dirt)</span>
}

// Reload requests all Requests to reload their current page.
func (jw *Jaws) Reload() <span class="cov8" title="1">{
        jw.Broadcast(Message{
                What: what.Reload,
        })
}</span>

// Redirect requests all Requests to navigate to the given URL.
func (jw *Jaws) Redirect(url string) <span class="cov8" title="1">{
        jw.Broadcast(Message{
                What: what.Redirect,
                Data: url,
        })
}</span>

// Alert sends an alert to all Requests. The lvl argument should be one of Bootstraps alert levels:
// primary, secondary, success, danger, warning, info, light or dark.
func (jw *Jaws) Alert(lvl, msg string) <span class="cov8" title="1">{
        jw.Broadcast(Message{
                What: what.Alert,
                Data: lvl + "\n" + msg,
        })
}</span>

// Count returns the number of requests waiting for their WebSocket callbacks.
func (jw *Jaws) Pending() (n int) <span class="cov8" title="1">{
        jw.mu.RLock()
        defer jw.mu.RUnlock()
        for _, rq := range jw.requests </span><span class="cov8" title="1">{
                if !rq.claimed.Load() </span><span class="cov8" title="1">{
                        n++
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// ServeWithTimeout begins processing requests with the given timeout.
// It is intended to run on it's own goroutine.
// It returns when Close is called.
func (jw *Jaws) ServeWithTimeout(requestTimeout time.Duration) <span class="cov8" title="1">{
        const minInterval = time.Millisecond * 10
        const maxInterval = time.Second
        maintenanceInterval := requestTimeout / 2
        if maintenanceInterval &gt; maxInterval </span><span class="cov8" title="1">{
                maintenanceInterval = maxInterval
        }</span>
        <span class="cov8" title="1">if maintenanceInterval &lt; minInterval </span><span class="cov8" title="1">{
                maintenanceInterval = minInterval
        }</span>

        <span class="cov8" title="1">subs := map[chan Message]*Request{}
        t := time.NewTicker(maintenanceInterval)

        defer func() </span><span class="cov8" title="1">{
                t.Stop()
                for ch, rq := range subs </span><span class="cov8" title="1">{
                        rq.cancel(nil)
                        close(ch)
                }</span>
        }()

        <span class="cov8" title="1">killSub := func(msgCh chan Message) </span><span class="cov8" title="1">{
                if _, ok := subs[msgCh]; ok </span><span class="cov8" title="1">{
                        delete(subs, msgCh)
                        close(msgCh)
                }</span>
        }

        // it's critical that we keep the broadcast
        // distribution loop running, so any Request
        // that fails to process it's messages quickly
        // enough must be terminated. the alternative
        // would be to drop some messages, but that
        // could mean nonreproducible and seemingly
        // random failures in processing logic.
        <span class="cov8" title="1">mustBroadcast := func(msg Message) </span><span class="cov8" title="1">{
                for msgCh, rq := range subs </span><span class="cov8" title="1">{
                        if msg.Dest == nil || rq.wantMessage(&amp;msg) </span><span class="cov8" title="1">{
                                select </span>{
                                case msgCh &lt;- msg:<span class="cov8" title="1"></span>
                                default:<span class="cov8" title="1">
                                        // the exception is Update messages, more will follow eventually
                                        if msg.What != what.Update </span><span class="cov8" title="1">{
                                                killSub(msgCh)
                                                rq.cancel(fmt.Errorf("%v: broadcast channel full sending %s", rq, msg.String()))
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-jw.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-jw.updateTicker.C:<span class="cov8" title="1">
                        if jw.distributeDirt() &gt; 0 </span><span class="cov8" title="1">{
                                mustBroadcast(Message{What: what.Update})
                        }</span>
                case &lt;-t.C:<span class="cov8" title="1">
                        jw.maintenance(requestTimeout)</span>
                case sub := &lt;-jw.subCh:<span class="cov8" title="1">
                        if sub.msgCh != nil </span><span class="cov8" title="1">{
                                subs[sub.msgCh] = sub.rq
                        }</span>
                case msgCh := &lt;-jw.unsubCh:<span class="cov8" title="1">
                        killSub(msgCh)</span>
                case msg, ok := &lt;-jw.bcastCh:<span class="cov8" title="1">
                        if ok </span><span class="cov8" title="1">{
                                mustBroadcast(msg)
                        }</span>
                }
        }
}

// Serve calls ServeWithTimeout(ctx, time.Second*10).
// It is intended to run on it's own goroutine.
// It returns when Close is called.
func (jw *Jaws) Serve() <span class="cov8" title="1">{
        jw.ServeWithTimeout(time.Second * 10)
}</span>

func (jw *Jaws) subscribe(rq *Request, size int) chan Message <span class="cov8" title="1">{
        msgCh := make(chan Message, size)
        select </span>{
        case &lt;-jw.Done():<span class="cov8" title="1">
                close(msgCh)
                return nil</span>
        case jw.subCh &lt;- subscription{msgCh: msgCh, rq: rq}:<span class="cov8" title="1"></span>
        }
        <span class="cov8" title="1">return msgCh</span>
}

func (jw *Jaws) unsubscribe(msgCh chan Message) <span class="cov8" title="1">{
        select </span>{
        case &lt;-jw.Done():<span class="cov8" title="1"></span>
        case jw.unsubCh &lt;- msgCh:<span class="cov8" title="1"></span>
        }
}

func (jw *Jaws) maintenance(requestTimeout time.Duration) <span class="cov8" title="1">{
        jw.mu.Lock()
        defer jw.mu.Unlock()
        now := time.Now()
        for _, rq := range jw.requests </span><span class="cov8" title="1">{
                if rq.maintenance(now, requestTimeout) </span><span class="cov8" title="1">{
                        jw.recycleLocked(rq)
                }</span>
        }
        <span class="cov8" title="1">for k, sess := range jw.sessions </span><span class="cov8" title="1">{
                if sess.isDead() </span><span class="cov8" title="1">{
                        delete(jw.sessions, k)
                }</span>
        }
}

func equalIP(a, b netip.Addr) bool <span class="cov8" title="1">{
        return a.Compare(b) == 0 || (a.IsLoopback() &amp;&amp; b.IsLoopback())
}</span>

func parseIP(remoteAddr string) (ip netip.Addr) <span class="cov8" title="1">{
        if remoteAddr != "" </span><span class="cov8" title="1">{
                if host, _, err := net.SplitHostPort(remoteAddr); err == nil </span><span class="cov8" title="1">{
                        ip, _ = netip.ParseAddr(host)
                }</span> else<span class="cov8" title="1"> {
                        ip, _ = netip.ParseAddr(remoteAddr)
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func maybePanic(err error) <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                panic(err)</span>
        }
}

// SetInner sends a request to replace the inner HTML of
// all HTML elements matching target.
func (jw *Jaws) SetInner(target any, innerHTML template.HTML) <span class="cov8" title="1">{
        jw.Broadcast(Message{
                Dest: target,
                What: what.Inner,
                Data: string(innerHTML),
        })
}</span>

// SetAttr sends a request to replace the given attribute value in
// all HTML elements matching target.
func (jw *Jaws) SetAttr(target any, attr, val string) <span class="cov8" title="1">{
        jw.Broadcast(Message{
                Dest: target,
                What: what.SAttr,
                Data: attr + "\n" + val,
        })
}</span>

// RemoveAttr sends a request to remove the given attribute from
// all HTML elements matching target.
func (jw *Jaws) RemoveAttr(target any, attr string) <span class="cov8" title="1">{
        jw.Broadcast(Message{
                Dest: target,
                What: what.RAttr,
                Data: attr,
        })
}</span>

// SetClass sends a request to set the given class in
// all HTML elements matching target.
func (jw *Jaws) SetClass(target any, cls string) <span class="cov8" title="1">{
        jw.Broadcast(Message{
                Dest: target,
                What: what.SClass,
                Data: cls,
        })
}</span>

// RemoveClass sends a request to remove the given class from
// all HTML elements matching target.
func (jw *Jaws) RemoveClass(target any, cls string) <span class="cov8" title="1">{
        jw.Broadcast(Message{
                Dest: target,
                What: what.RClass,
                Data: cls,
        })
}</span>

// SetValue sends a request to set the HTML "value" attribute of
// all HTML elements matching target.
func (jw *Jaws) SetValue(target any, val string) <span class="cov8" title="1">{
        jw.Broadcast(Message{
                Dest: target,
                What: what.Value,
                Data: val,
        })
}</span>

// Insert calls the Javascript 'insertBefore()' method on
// all HTML elements matching target.
//
// The position parameter 'where' may be either a HTML ID, an child index or the text 'null'.
func (jw *Jaws) Insert(target any, where, html string) <span class="cov8" title="1">{
        jw.Broadcast(Message{
                Dest: target,
                What: what.Insert,
                Data: where + "\n" + html,
        })
}</span>

// Replace replaces the HTML content on
// all HTML elements matching target.
//
// The position parameter 'where' may be either a HTML ID or an index.
func (jw *Jaws) Replace(target any, where, html string) <span class="cov8" title="1">{
        jw.Broadcast(Message{
                Dest: target,
                What: what.Replace,
                Data: where + "\n" + html,
        })
}</span>

// Delete removes the HTML element(s) matching target.
func (jw *Jaws) Delete(target any) <span class="cov8" title="1">{
        jw.Broadcast(Message{
                Dest: target,
                What: what.Delete,
        })
}</span>

// Append calls the Javascript 'appendChild()' method on all HTML elements matching target.
func (jw *Jaws) Append(target any, html template.HTML) <span class="cov8" title="1">{
        jw.Broadcast(Message{
                Dest: target,
                What: what.Append,
                Data: string(html),
        })
}</span>

// JsCall calls the Javascript function 'jsfunc' with the argument 'jsonstr'
// on all Requests that have the target UI tag.
// The jsonstr argument must a valid JSON object in string format.
func (jw *Jaws) JsCall(tag any, jsfunc, jsonstr string) <span class="cov8" title="1">{
        jw.Broadcast(Message{
                Dest: tag,
                What: what.Call,
                Data: jsfunc + "=" + jsonstr,
        })
}</span>

func (jw *Jaws) getRequestLocked(jawsKey uint64, hr *http.Request) (rq *Request) <span class="cov8" title="1">{
        rq = jw.reqPool.Get().(*Request)
        rq.JawsKey = jawsKey
        rq.lastWrite = time.Now()
        rq.initial = hr
        rq.ctx, rq.cancelFn = context.WithCancelCause(jw.BaseContext)
        if hr != nil </span><span class="cov8" title="1">{
                rq.remoteIP = parseIP(hr.RemoteAddr)
                if sess := jw.getSessionLocked(getCookieSessionsIds(hr.Header, jw.CookieName), rq.remoteIP); sess != nil </span><span class="cov8" title="1">{
                        sess.addRequest(rq)
                        rq.session = sess
                }</span>
        }
        <span class="cov8" title="1">return rq</span>
}

func (jw *Jaws) recycleLocked(rq *Request) <span class="cov8" title="1">{
        rq.mu.Lock()
        defer rq.mu.Unlock()
        if rq.JawsKey != 0 </span><span class="cov8" title="1">{
                delete(jw.requests, rq.JawsKey)
                rq.clearLocked()
                jw.reqPool.Put(rq)
        }</span>
}

func (jw *Jaws) recycle(rq *Request) <span class="cov8" title="1">{
        jw.mu.Lock()
        defer jw.mu.Unlock()
        jw.recycleLocked(rq)
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package jaws

import (
        _ "embed"
        "mime"
        "net/url"
        "path/filepath"
        "strconv"
        "strings"
)

// JavascriptText is the source code for the client-side JaWS Javascript library.
//
//go:embed jaws.js
var JavascriptText []byte

//go:embed jaws.css
var JawsCSS []byte

// JawsKeyAppend appends the JaWS key as a string to the buffer.
func JawsKeyAppend(b []byte, jawsKey uint64) []byte <span class="cov8" title="1">{
        if jawsKey != 0 </span><span class="cov8" title="1">{
                b = strconv.AppendUint(b, jawsKey, 32)
        }</span>
        <span class="cov8" title="1">return b</span>
}

// JawsKeyString returns the string to be used for the given JaWS key.
func JawsKeyString(jawsKey uint64) string <span class="cov8" title="1">{
        return string(JawsKeyAppend(nil, jawsKey))
}</span>

// JawsKeyValue parses a key string (as returned JawsKeyString) into a uint64.
func JawsKeyValue(jawsKey string) uint64 <span class="cov8" title="1">{
        slashIdx := strings.IndexByte(jawsKey, '/')
        if slashIdx &lt; 0 </span><span class="cov8" title="1">{
                slashIdx = len(jawsKey)
        }</span>
        <span class="cov8" title="1">if val, err := strconv.ParseUint(jawsKey[:slashIdx], 32, 64); err == nil </span><span class="cov8" title="1">{
                return val
        }</span>
        <span class="cov8" title="1">return 0</span>
}

// PreloadHTML returns HTML code to load the given resources efficiently.
func PreloadHTML(urls ...*url.URL) (htmlcode, faviconurl string) <span class="cov8" title="1">{
        var jsurls, cssurls []string
        var favicontype string
        var buf []byte
        for _, u := range urls </span><span class="cov8" title="1">{
                var asattr string
                ext := strings.ToLower(filepath.Ext(u.Path))
                mimetype := mime.TypeByExtension(ext)
                if semi := strings.IndexByte(mimetype, ';'); semi &gt; 0 </span><span class="cov8" title="1">{
                        mimetype = mimetype[:semi]
                }</span>
                <span class="cov8" title="1">urlstr := u.String()
                switch ext </span>{
                case ".js":<span class="cov8" title="1">
                        jsurls = append(jsurls, urlstr)
                        continue</span>
                case ".css":<span class="cov8" title="1">
                        cssurls = append(cssurls, urlstr)
                        continue</span>
                default:<span class="cov8" title="1">
                        if strings.HasPrefix(mimetype, "image") </span><span class="cov8" title="1">{
                                asattr = "image"
                                if strings.HasPrefix(filepath.Base(u.Path), "favicon") </span><span class="cov8" title="1">{
                                        favicontype = mimetype
                                        faviconurl = urlstr
                                        continue</span>
                                }
                        } else<span class="cov8" title="1"> if strings.HasPrefix(mimetype, "font") </span><span class="cov8" title="1">{
                                asattr = "font"
                        }</span>
                }
                <span class="cov8" title="1">buf = append(buf, `&lt;link rel="preload" href="`...)
                buf = append(buf, urlstr...)
                buf = append(buf, '"')
                if asattr != "" </span><span class="cov8" title="1">{
                        buf = append(buf, ` as="`...)
                        buf = append(buf, asattr...)
                        buf = append(buf, '"')
                }</span>
                <span class="cov8" title="1">if mimetype != "" </span><span class="cov8" title="1">{
                        buf = append(buf, ` type="`...)
                        buf = append(buf, mimetype...)
                        buf = append(buf, '"')
                }</span>
                <span class="cov8" title="1">buf = append(buf, "&gt;\n"...)</span>
        }
        <span class="cov8" title="1">for _, urlstr := range cssurls </span><span class="cov8" title="1">{
                buf = append(buf, `&lt;link rel="stylesheet" href="`...)
                buf = append(buf, urlstr...)
                buf = append(buf, "\"&gt;\n"...)
        }</span>
        <span class="cov8" title="1">if faviconurl != "" </span><span class="cov8" title="1">{
                buf = append(buf, `&lt;link rel="icon" type="`...)
                buf = append(buf, favicontype...)
                buf = append(buf, `" href="`...)
                buf = append(buf, faviconurl...)
                buf = append(buf, "\"&gt;\n"...)
        }</span>
        <span class="cov8" title="1">for _, urlstr := range jsurls </span><span class="cov8" title="1">{
                buf = append(buf, `&lt;script defer src="`...)
                buf = append(buf, []byte(urlstr)...)
                buf = append(buf, "\"&gt;&lt;/script&gt;\n"...)
        }</span>
        <span class="cov8" title="1">htmlcode = string(buf)
        return</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package jaws

import (
        "bytes"
        "encoding/json"
        "io"
        "reflect"
        "strconv"
        "strings"
        "sync"

        "github.com/linkdata/jaws/what"
        "github.com/linkdata/jq"
)

type PathSetter interface {
        // JawsSetPath should set the JSON object member identified by jspath to the given value.
        //
        // If the member is already the given value, it should return ErrValueUnchanged.
        JawsSetPath(elem *Element, jspath string, value any) (err error)
}

type SetPather interface {
        // JawsPathSet notifies that a JSON object member identified by jspath has been set
        // to the given value and the change has been queued for broadcast.
        JawsPathSet(elem *Element, jspath string, value any)
}

type IsJsVar interface {
        RWLocker
        UI
        EventHandler
        PathSetter
}

type JsVarMaker interface {
        JawsMakeJsVar(rq *Request) (v IsJsVar, err error)
}

var (
        _ IsJsVar     = &amp;JsVar[int]{}
        _ Setter[int] = &amp;JsVar[int]{}
)

type JsVar[T any] struct {
        RWLocker
        Ptr *T
        Tag any
}

func (ui *JsVar[T]) JawsGetPath(elem *Element, jspath string) (value any) <span class="cov8" title="1">{
        ui.RLock()
        defer ui.RUnlock()
        var err error
        value, err = jq.Get(ui.Ptr, jspath)
        if elem != nil </span><span class="cov8" title="1">{
                _ = elem.Jaws.Log(err)
        }</span>
        <span class="cov8" title="1">return</span>
}

func (ui *JsVar[T]) JawsGet(elem *Element) (value T) <span class="cov8" title="1">{
        anyval := ui.JawsGetPath(elem, "")
        value = *((anyval).(*T))
        return
}</span>

func (ui *JsVar[T]) setPathLocked(elem *Element, jspath string, value any) (err error) <span class="cov8" title="1">{
        if ps, ok := ((any)(ui.Ptr).(PathSetter)); ok </span><span class="cov8" title="1">{
                err = ps.JawsSetPath(elem, jspath, value)
        }</span> else<span class="cov8" title="1"> {
                var changed bool
                if changed, err = jq.Set(ui.Ptr, jspath, value); err == nil &amp;&amp; !changed </span><span class="cov8" title="1">{
                        err = ErrValueUnchanged
                }</span>
        }
        <span class="cov8" title="1">if err == nil &amp;&amp; elem != nil </span><span class="cov8" title="1">{
                var data []byte
                if data, err = json.Marshal(value); err == nil </span><span class="cov8" title="1">{
                        elem.Jaws.Broadcast(Message{
                                Dest: ui.Tag,
                                What: what.Set,
                                Data: jspath + "=" + string(data),
                        })
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func (ui *JsVar[T]) setPathLock(elem *Element, jspath string, value any) (err error) <span class="cov8" title="1">{
        ui.Lock()
        defer ui.Unlock()
        err = ui.setPathLocked(elem, jspath, value)
        return
}</span>

func (ui *JsVar[T]) setPath(elem *Element, jspath string, value any) (err error) <span class="cov8" title="1">{
        if err = ui.setPathLock(elem, jspath, value); err == nil </span><span class="cov8" title="1">{
                if sp, ok := ((any)(ui.Ptr).(SetPather)); ok </span><span class="cov8" title="1">{
                        sp.JawsPathSet(elem, jspath, value)
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func (ui *JsVar[T]) JawsSetPath(elem *Element, jspath string, value any) (err error) <span class="cov8" title="1">{
        return ui.setPath(elem, jspath, value)
}</span>

func (ui *JsVar[T]) JawsSet(elem *Element, value T) (err error) <span class="cov8" title="1">{
        return ui.JawsSetPath(elem, "", value)
}</span>

func (ui *JsVar[T]) JawsRender(e *Element, w io.Writer, params []any) (err error) <span class="cov8" title="1">{
        ui.Lock()
        defer ui.Unlock()
        if ui.Tag, err = e.ApplyGetter(ui.Ptr); err == nil </span><span class="cov8" title="1">{
                var data []byte
                if ui.Ptr != nil </span><span class="cov8" title="1">{
                        if !reflect.ValueOf(*ui.Ptr).IsZero() </span><span class="cov8" title="1">{
                                data, err = json.Marshal(ui.Ptr)
                        }</span>
                }
                <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                        jsvarname := params[0].(string)
                        attrs := e.ApplyParams(params[1:])
                        var b []byte
                        b = append(b, "\n&lt;div id="...)
                        b = e.Jid().AppendQuote(b)
                        b = append(b, ` data-jawsname=`...)
                        b = strconv.AppendQuote(b, jsvarname)
                        if data != nil </span><span class="cov8" title="1">{
                                b = append(b, ` data-jawsdata='`...)
                                b = append(b, bytes.ReplaceAll(data, []byte(`'`), []byte(`\u0027`))...)
                                b = append(b, "'"...)
                        }</span>
                        <span class="cov8" title="1">b = appendAttrs(b, attrs)
                        b = append(b, " hidden&gt;&lt;/div&gt;"...)
                        _, err = w.Write(b)</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

func (ui *JsVar[T]) JawsGetTag(rq *Request) any <span class="cov8" title="1">{
        return ui.Tag
}</span>

func (ui *JsVar[T]) JawsUpdate(e *Element) {<span class="cov8" title="1">}</span> // no-op for JsVar[T]

func elideErrValueUnchanged(err error) error <span class="cov8" title="1">{
        if err == ErrValueUnchanged </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return err</span>
}

func (ui *JsVar[T]) JawsEvent(e *Element, wht what.What, val string) (err error) <span class="cov8" title="1">{
        err = ErrEventUnhandled
        if wht == what.Set </span><span class="cov8" title="1">{
                if jspath, jsval, found := strings.Cut(val, "="); found </span><span class="cov8" title="1">{
                        var v any
                        if err = json.Unmarshal([]byte(jsval), &amp;v); err == nil </span><span class="cov8" title="1">{
                                err = elideErrValueUnchanged(ui.setPath(e, jspath, v))
                        }</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

func NewJsVar[T any](l sync.Locker, v *T) *JsVar[T] <span class="cov8" title="1">{
        if rl, ok := l.(RWLocker); ok </span><span class="cov8" title="1">{
                return &amp;JsVar[T]{RWLocker: rl, Ptr: v}
        }</span>
        <span class="cov8" title="1">return &amp;JsVar[T]{RWLocker: rwlocker{l}, Ptr: v}</span>
}

// JsVar binds a JsVar[T] to a named Javascript variable.
//
// You can also pass a JsVarMaker instead of a JsVar[T].
func (rq RequestWriter) JsVar(jsvarname string, jsvar any, params ...any) (err error) <span class="cov8" title="1">{
        if jvm, ok := jsvar.(JsVarMaker); ok </span><span class="cov8" title="1">{
                jsvar, err = jvm.JawsMakeJsVar(rq.Request())
        }</span>
        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                var newparams []any
                newparams = append(newparams, jsvarname)
                newparams = append(newparams, params...)
                err = rq.UI(jsvar.(UI), newparams...)
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package jaws

import (
        "fmt"
        "html"
        "html/template"
)

type htmlGetter struct{ v template.HTML }

func (g htmlGetter) JawsGetHTML(e *Element) template.HTML <span class="cov8" title="1">{
        return g.v
}</span>

func (g htmlGetter) JawsGetTag(rq *Request) any <span class="cov8" title="1">{
        return nil
}</span>

type htmlStringerGetter struct{ sg fmt.Stringer }

func (g htmlStringerGetter) JawsGetHTML(e *Element) template.HTML <span class="cov8" title="1">{
        return template.HTML(html.EscapeString(g.sg.String())) // #nosec G203
}</span>

func (g htmlStringerGetter) JawsGetTag(rq *Request) any <span class="cov8" title="1">{
        return g.sg
}</span>

type htmlGetterString struct{ sg Getter[string] }

func (g htmlGetterString) JawsGetHTML(e *Element) template.HTML <span class="cov8" title="1">{
        return template.HTML(html.EscapeString(g.sg.JawsGet(e))) // #nosec G203
}</span>

func (g htmlGetterString) JawsGetTag(rq *Request) any <span class="cov8" title="1">{
        return g.sg
}</span>

// MakeHTMLGetter returns a HTMLGetter for v.
//
// Depending on the type of v, we return:
//
//   - jaws.HTMLGetter: `JawsGetHTML(e *Element) template.HTML` to be used as-is.
//   - jaws.Getter[string]: `JawsGet(elem *Element) string` that will be escaped using `html.EscapeString`.
//   - jaws.AnyGetter: `JawsGetAny(elem *Element) any` that will be rendered using `fmt.Sprint()` and escaped using `html.EscapeString`.
//   - fmt.Stringer: `String() string` that will be escaped using `html.EscapeString`.
//   - a static `template.HTML` or `string` to be used as-is with no HTML escaping.
//   - everything else is rendered using `fmt.Sprint()` and escaped using `html.EscapeString`.
func MakeHTMLGetter(v any) HTMLGetter <span class="cov8" title="1">{
        switch v := v.(type) </span>{
        case HTMLGetter:<span class="cov8" title="1">
                return v</span>
        case template.HTML:<span class="cov8" title="1">
                return htmlGetter{v}</span>
        case Getter[string]:<span class="cov8" title="1">
                return htmlGetterString{v}</span>
        case fmt.Stringer:<span class="cov8" title="1">
                return htmlStringerGetter{v}</span>
        case string:<span class="cov8" title="1">
                return htmlGetter{template.HTML(v)}</span> // #nosec G203
        case Formatter:<span class="cov8" title="1">
                return htmlGetterString{v.Format("%v")}</span>
        default:<span class="cov8" title="1">
                return htmlGetter{template.HTML(html.EscapeString(fmt.Sprint(v)))}</span> // #nosec G203
        }
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package jaws

import (
        "fmt"

        "github.com/linkdata/jaws/what"
)

// Message contains the elements of a message to be sent to Requests.
type Message struct {
        Dest any       // destination (tag, html ID or *Element)
        What what.What // what to change or do
        Data string    // data (e.g. inner HTML content or slice of tags)
}

// String returns the Message in a form suitable for debug output.
func (msg *Message) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("{%v, %v, %q}",
                msg.Dest,
                msg.What,
                msg.Data,
        )
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package jaws

import (
        "fmt"
        "html/template"

        "github.com/linkdata/deadlock"
)

// NamedBool stores a named boolen value with a HTML representation.
type NamedBool struct {
        nba     *NamedBoolArray  // (read-only) NamedBoolArray that this is part of (may be nil)
        name    string           // (read-only) name within the named bool set
        html    template.HTML    // (read-only) HTML code used in select lists or labels
        mu      deadlock.RWMutex // protects following
        checked bool             // it's state
}

func NewNamedBool(nba *NamedBoolArray, name string, html template.HTML, checked bool) *NamedBool <span class="cov8" title="1">{
        return &amp;NamedBool{
                nba:     nba,
                name:    name,
                html:    html,
                checked: checked,
        }
}</span>

func (nb *NamedBool) Array() *NamedBoolArray <span class="cov8" title="1">{
        return nb.nba
}</span>

func (nb *NamedBool) Name() (s string) <span class="cov8" title="1">{
        s = nb.name
        return
}</span>

func (nb *NamedBool) HTML() (h template.HTML) <span class="cov8" title="1">{
        h = nb.html
        return
}</span>

func (nb *NamedBool) JawsGetHTML(*Element) (h template.HTML) <span class="cov8" title="1">{
        return nb.HTML()
}</span>

func (nb *NamedBool) JawsGet(*Element) (v bool) <span class="cov8" title="1">{
        nb.mu.RLock()
        v = nb.checked
        nb.mu.RUnlock()
        return
}</span>

func (nb *NamedBool) JawsSet(e *Element, checked bool) (err error) <span class="cov8" title="1">{
        var nba *NamedBoolArray
        nb.mu.Lock()
        if nb.checked != checked </span><span class="cov8" title="1">{
                nb.checked = checked
                nba = nb.nba
        }</span> else<span class="cov8" title="1"> {
                err = ErrValueUnchanged
        }</span>
        <span class="cov8" title="1">nb.mu.Unlock()
        if err == nil </span><span class="cov8" title="1">{
                e.Dirty(nb)
                if nba != nil </span><span class="cov8" title="1">{
                        e.Dirty(nba)
                        nb.nba.Set(nb.name, checked)
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func (nb *NamedBool) Checked() (checked bool) <span class="cov8" title="1">{
        nb.mu.RLock()
        checked = nb.checked
        nb.mu.RUnlock()
        return
}</span>

func (nb *NamedBool) Set(checked bool) (changed bool) <span class="cov8" title="1">{
        nb.mu.Lock()
        if nb.checked != checked </span><span class="cov8" title="1">{
                nb.checked = checked
                changed = true
        }</span>
        <span class="cov8" title="1">nb.mu.Unlock()
        return</span>
}

// String returns a string representation of the NamedBool suitable for debugging.
func (nb *NamedBool) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("&amp;{%q,%q,%v}", nb.Name(), nb.HTML(), nb.Checked())
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package jaws

import (
        "html/template"
        "strings"

        "github.com/linkdata/deadlock"
)

// NamedBoolArray stores the data required to support HTML 'select' elements
// and sets of HTML radio buttons. It it safe to use from multiple goroutines
// concurrently.
type NamedBoolArray struct {
        Multi bool             // allow multiple NamedBools to be true
        mu    deadlock.RWMutex // protects following
        data  []*NamedBool
}

var _ SelectHandler = (*NamedBoolArray)(nil)

func NewNamedBoolArray() *NamedBoolArray <span class="cov8" title="1">{
        return &amp;NamedBoolArray{}
}</span>

// ReadLocked calls the given function with the NamedBoolArray locked for reading.
func (nba *NamedBoolArray) ReadLocked(fn func(nbl []*NamedBool)) <span class="cov8" title="1">{
        nba.mu.RLock()
        defer nba.mu.RUnlock()
        fn(nba.data)
}</span>

// WriteLocked calls the given function with the NamedBoolArray locked for writing and
// replaces the internal []*NamedBool slice with the return value.
func (nba *NamedBoolArray) WriteLocked(fn func(nbl []*NamedBool) []*NamedBool) <span class="cov8" title="1">{
        nba.mu.Lock()
        defer nba.mu.Unlock()
        nba.data = fn(nba.data)
}</span>

func (nba *NamedBoolArray) JawsContains(e *Element) (contents []UI) <span class="cov8" title="1">{
        nba.mu.RLock()
        for _, nb := range nba.data </span><span class="cov8" title="1">{
                contents = append(contents, UiOption{nb})
        }</span>
        <span class="cov8" title="1">nba.mu.RUnlock()
        return</span>
}

// Add adds a NamedBool with the given name and the given text.
// Returns itself.
//
// Note that while it's legal to have multiple NamedBool with the same name
// since it's allowed in HTML, it's probably not a good idea.
func (nba *NamedBoolArray) Add(name string, text template.HTML) *NamedBoolArray <span class="cov8" title="1">{
        nba.mu.Lock()
        nba.data = append(nba.data, NewNamedBool(nba, name, text, false))
        nba.mu.Unlock()
        return nba
}</span>

// Set sets the Checked state for the NamedBool(s) with the given name.
func (nba *NamedBoolArray) Set(name string, state bool) (changed bool) <span class="cov8" title="1">{
        nba.mu.RLock()
        defer nba.mu.RUnlock()
        for _, nb := range nba.data </span><span class="cov8" title="1">{
                if nb.Name() == name </span><span class="cov8" title="1">{
                        changed = nb.Set(state) || changed
                }</span>
        }
        <span class="cov8" title="1">if state &amp;&amp; !nba.Multi </span><span class="cov8" title="1">{
                for _, nb := range nba.data </span><span class="cov8" title="1">{
                        if nb.Name() != name </span><span class="cov8" title="1">{
                                changed = nb.Set(false) || changed
                        }</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

// Get returns the name of first NamedBool in the group that
// has it's Checked value set to true. Returns an empty string
// if none are true.
//
// In case you can have more than one selected or you need to
// distinguish between a blank name and the fact that none are
// set to true, use ReadLocked() to inspect the data directly.
func (nba *NamedBoolArray) Get() (name string) <span class="cov8" title="1">{
        nba.mu.RLock()
        for _, nb := range nba.data </span><span class="cov8" title="1">{
                if nb.Checked() </span><span class="cov8" title="1">{
                        name = nb.Name()
                        break</span>
                }
        }
        <span class="cov8" title="1">nba.mu.RUnlock()
        return</span>
}

func (nba *NamedBoolArray) isCheckedLocked(name string) bool <span class="cov8" title="1">{
        for _, nb := range nba.data </span><span class="cov8" title="1">{
                if nb.Checked() &amp;&amp; nb.Name() == name </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// IsChecked returns true if any of the NamedBool in the set that have the
// given name are Checked. Returns false if the name is not found.
func (nba *NamedBoolArray) IsChecked(name string) (state bool) <span class="cov8" title="1">{
        nba.mu.RLock()
        state = nba.isCheckedLocked(name)
        nba.mu.RUnlock()
        return
}</span>

// String returns a string representation of the NamedBoolArray suitable for debugging.
func (nba *NamedBoolArray) String() string <span class="cov8" title="1">{
        var sb strings.Builder
        sb.WriteString("&amp;NamedBoolArray{[")
        nba.mu.RLock()
        for i, nb := range nba.data </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        sb.WriteByte(',')
                }</span>
                <span class="cov8" title="1">sb.WriteString(nb.String())</span>
        }
        <span class="cov8" title="1">nba.mu.RUnlock()
        sb.WriteString("]}")
        return sb.String()</span>
}

func (nba *NamedBoolArray) JawsGet(e *Element) string <span class="cov8" title="1">{
        return nba.Get()
}</span>

func (nba *NamedBoolArray) JawsSet(e *Element, name string) (err error) <span class="cov8" title="1">{
        if nba.Set(name, true) </span><span class="cov8" title="1">{
                e.Dirty(nba)
        }</span> else<span class="cov8" title="1"> {
                err = ErrValueUnchanged
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package jaws

import "html/template"

// ParseParams parses the parameters passed to UI() when creating a new Element,
// returning UI tags, event handlers and HTML attributes.
func ParseParams(params []any) (tags []any, handlers []EventHandler, attrs []string) <span class="cov8" title="1">{
        for i := range params </span><span class="cov8" title="1">{
                switch data := params[i].(type) </span>{
                case template.HTMLAttr:<span class="cov8" title="1">
                        attrs = append(attrs, string(data))</span>
                case []template.HTMLAttr:<span class="cov8" title="1">
                        for _, s := range data </span><span class="cov8" title="1">{
                                attrs = append(attrs, string(s))
                        }</span>
                case string:<span class="cov8" title="1">
                        attrs = append(attrs, data)</span>
                case []string:<span class="cov8" title="1">
                        attrs = append(attrs, data...)</span>
                case EventFn:<span class="cov8" title="1">
                        if data != nil </span><span class="cov8" title="1">{
                                handlers = append(handlers, eventFnWrapper{data})
                        }</span>
                default:<span class="cov8" title="1">
                        if h, ok := data.(ClickHandler); ok </span><span class="cov8" title="1">{
                                handlers = append(handlers, clickHandlerWapper{h})
                        }</span>
                        <span class="cov8" title="1">if h, ok := data.(EventHandler); ok </span><span class="cov8" title="1">{
                                handlers = append(handlers, h)
                        }</span>
                        <span class="cov8" title="1">tags = append(tags, data)</span>
                }
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package jaws

import (
        "context"
        "errors"
        "fmt"
        "html"
        "io"
        "net/http"
        "net/netip"
        "slices"
        "sort"
        "strconv"
        "strings"
        "sync/atomic"
        "time"

        "github.com/linkdata/deadlock"
        "github.com/linkdata/jaws/jid"
        "github.com/linkdata/jaws/what"
)

// ConnectFn can be used to interact with a Request before message processing starts.
// Returning an error causes the Request to abort, and the WebSocket connection to close.
type ConnectFn = func(rq *Request) error

// Request maintains the state for a JaWS WebSocket connection, and handles processing
// of events and broadcasts.
//
// Note that we have to store the context inside the struct because there is no call chain
// between the Request being created and it being used once the WebSocket is created.
type Request struct {
        Jaws       *Jaws                   // (read-only) the JaWS instance the Request belongs to
        JawsKey    uint64                  // (read-only) a random number used in the WebSocket URI to identify this Request
        remoteIP   netip.Addr              // (read-only) remote IP, or nil
        rendering  atomic.Bool             // set to true by RequestWriter.Write()
        running    atomic.Bool             // if ServeHTTP() is running
        claimed    atomic.Bool             // if UseRequest() has been called for it
        mu         deadlock.RWMutex        // protects following
        lastWrite  time.Time               // when the initial HTML was last written to, used for automatic cleanup
        initial    *http.Request           // initial HTTP request passed to Jaws.NewRequest
        session    *Session                // session, if established
        todoDirt   []any                   // dirty tags
        ctx        context.Context         // current context, derived from either Jaws or WS HTTP req
        httpDoneCh &lt;-chan struct{}         // once claimed, set to http.Request.Context().Done()
        cancelFn   context.CancelCauseFunc // cancel function
        connectFn  ConnectFn               // a ConnectFn to call before starting message processing for the Request
        elems      []*Element              // our Elements
        tagMap     map[any][]*Element      // maps tags to Elements
        muQueue    deadlock.Mutex          // protects wsQueue
        wsQueue    []wsMsg                 // queued messages to send
}

type eventFnCall struct {
        jid  Jid
        wht  what.What
        data string
}

func (rq *Request) JawsKeyString() string <span class="cov8" title="1">{
        jawsKey := uint64(0)
        if rq != nil </span><span class="cov8" title="1">{
                jawsKey = rq.JawsKey
        }</span>
        <span class="cov8" title="1">return JawsKeyString(jawsKey)</span>
}

func (rq *Request) String() string <span class="cov8" title="1">{
        return "Request&lt;" + rq.JawsKeyString() + "&gt;"
}</span>

var ErrRequestAlreadyClaimed = errors.New("request already claimed")
var ErrJavascriptDisabled = errors.New("javascript is disabled")

func (rq *Request) claim(hr *http.Request) error <span class="cov8" title="1">{
        if !rq.claimed.Load() </span><span class="cov8" title="1">{
                var actualIP netip.Addr
                var httpDoneCh &lt;-chan struct{}
                if hr != nil </span><span class="cov8" title="1">{ // can be nil in tests
                        actualIP = parseIP(hr.RemoteAddr)
                        httpDoneCh = hr.Context().Done()
                }</span>
                <span class="cov8" title="1">rq.mu.Lock()
                defer rq.mu.Unlock()
                if !equalIP(rq.remoteIP, actualIP) </span><span class="cov8" title="1">{
                        return fmt.Errorf("/jaws/%s: expected IP %q, got %q", rq.JawsKeyString(), rq.remoteIP.String(), actualIP.String())
                }</span>
                <span class="cov8" title="1">if rq.claimed.CompareAndSwap(false, true) </span><span class="cov8" title="1">{
                        rq.ctx, rq.cancelFn = context.WithCancelCause(rq.ctx)
                        rq.httpDoneCh = httpDoneCh
                        return nil
                }</span>
        }
        <span class="cov8" title="1">return ErrRequestAlreadyClaimed</span>
}

func (rq *Request) killSessionLocked() <span class="cov8" title="1">{
        if rq.session != nil </span><span class="cov8" title="1">{
                rq.session.delRequest(rq)
                rq.session = nil
        }</span>
}

func (rq *Request) killSession() <span class="cov8" title="1">{
        rq.mu.Lock()
        rq.killSessionLocked()
        rq.mu.Unlock()
}</span>

func (rq *Request) clearLocked() *Request <span class="cov8" title="1">{
        rq.JawsKey = 0
        rq.connectFn = nil
        rq.lastWrite = time.Time{}
        rq.initial = nil
        rq.running.Store(false)
        rq.claimed.Store(false)
        rq.ctx, rq.cancelFn = context.WithCancelCause(rq.Jaws.BaseContext)
        rq.httpDoneCh = nil
        rq.todoDirt = rq.todoDirt[:0]
        rq.remoteIP = netip.Addr{}
        rq.elems = rq.elems[:0]
        rq.killSessionLocked()
        clear(rq.tagMap)
        return rq
}</span>

// HeadHTML writes the HTML code needed in the HTML page's HEAD section.
func (rq *Request) HeadHTML(w io.Writer) (err error) <span class="cov8" title="1">{
        var b []byte
        b = append(b, rq.Jaws.headPrefix...)
        b = JawsKeyAppend(b, rq.JawsKey)
        b = append(b, `"&gt;`...)
        _, err = w.Write(b)
        return
}</span>

func (rq *Request) getTailActions() (b []byte) <span class="cov8" title="1">{
        rq.muQueue.Lock()
        defer rq.muQueue.Unlock()
        for _, msg := range rq.wsQueue </span><span class="cov8" title="1">{
                var fn string
                switch msg.What </span>{
                case what.SAttr:<span class="cov8" title="1">
                        fn = "setAttribute"</span>
                case what.RAttr:<span class="cov8" title="1">
                        fn = "removeAttribute"</span>
                case what.SClass:<span class="cov8" title="1">
                        fn = "classList?.add"</span>
                case what.RClass:<span class="cov8" title="1">
                        fn = "classList?.remove"</span>
                }
                <span class="cov8" title="1">if fn != "" </span><span class="cov8" title="1">{
                        if len(b) == 0 </span><span class="cov8" title="1">{
                                b = append(b, "\n&lt;script&gt;"...)
                        }</span>
                        <span class="cov8" title="1">b = append(b, "\ndocument.getElementById("...)
                        b = msg.Jid.AppendQuote(b)
                        b = append(b, ")?."...)
                        b = append(b, fn...)
                        b = append(b, "("...)
                        attr, val, ok := strings.Cut(msg.Data, "\n")
                        b = strconv.AppendQuote(b, attr)
                        if ok </span><span class="cov8" title="1">{
                                b = append(b, ',')
                                b = strconv.AppendQuote(b, val)
                        }</span>
                        <span class="cov8" title="1">b = append(b, ");"...)</span>
                }
        }
        <span class="cov8" title="1">if len(b) &gt; 0 </span><span class="cov8" title="1">{
                b = append(b, "\n&lt;/script&gt;"...)
        }</span>
        <span class="cov8" title="1">return</span>
}

// TailHTML writes optional HTML code at the end of the page's BODY section that
// will immediately apply HTML attribute and class updates made during initial
// rendering, which eliminates flicker without having to write the correct
// value in templates or during JawsRender().
//
// It also adds a &lt;noscript&gt; tag that warns of reduces functionality.
func (rq *Request) TailHTML(w io.Writer) (err error) <span class="cov8" title="1">{
        fmt.Fprintf(w, "\n"+`&lt;noscript&gt;`+
                `&lt;div class="jaws-alert"&gt;This site requires Javascript for full functionality.&lt;/div&gt;`+
                `&lt;img src="/jaws/%s/noscript" alt="noscript"&gt;&lt;/noscript&gt;`, rq.JawsKeyString())
        if actions := rq.getTailActions(); len(actions) &gt; 0 </span><span class="cov8" title="1">{
                _, err = w.Write(actions)
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetConnectFn returns the currently set ConnectFn. That function will be called before starting the WebSocket tunnel if not nil.
func (rq *Request) GetConnectFn() (fn ConnectFn) <span class="cov8" title="1">{
        rq.mu.RLock()
        fn = rq.connectFn
        rq.mu.RUnlock()
        return
}</span>

// SetConnectFn sets ConnectFn. That function will be called before starting the WebSocket tunnel if not nil.
func (rq *Request) SetConnectFn(fn ConnectFn) <span class="cov8" title="1">{
        rq.mu.Lock()
        rq.connectFn = fn
        rq.mu.Unlock()
}</span>

// Session returns the Request's Session, or nil.
func (rq *Request) Session() (sess *Session) <span class="cov8" title="1">{
        rq.mu.RLock()
        sess = rq.session
        rq.mu.RUnlock()
        return
}</span>

// Initial returns the Request's initial HTTP request, or nil.
func (rq *Request) Initial() (r *http.Request) <span class="cov8" title="1">{
        rq.mu.RLock()
        r = rq.initial
        rq.mu.RUnlock()
        return
}</span>

// Get is shorthand for `Session().Get()` and returns the session value associated with the key, or nil.
// It no session is associated with the Request, returns nil.
func (rq *Request) Get(key string) any <span class="cov8" title="1">{
        return rq.Session().Get(key)
}</span>

// Set is shorthand for `Session().Set()` and sets a session value to be associated with the key.
// If value is nil, the key is removed from the session.
// Does nothing if there is no session is associated with the Request.
func (rq *Request) Set(key string, val any) <span class="cov8" title="1">{
        rq.Session().Set(key, val)
}</span>

// Context returns the Request's Context, which is by default derived from jaws.BaseContext.
func (rq *Request) Context() (ctx context.Context) <span class="cov8" title="1">{
        rq.mu.RLock()
        ctx = rq.ctx
        rq.mu.RUnlock()
        return
}</span>

// SetContext atomically replaces the Request's context with the function return value.
// The function is given the current context and must return a non-nil context.
func (rq *Request) SetContext(fn func(oldctx context.Context) (newctx context.Context)) <span class="cov8" title="1">{
        rq.mu.Lock()
        defer rq.mu.Unlock()
        rq.ctx = fn(rq.ctx)
}</span>

func (rq *Request) maintenance(now time.Time, requestTimeout time.Duration) bool <span class="cov8" title="1">{
        if !rq.running.Load() </span><span class="cov8" title="1">{
                if rq.rendering.Swap(false) </span><span class="cov8" title="1">{
                        rq.mu.Lock()
                        rq.lastWrite = now
                        rq.mu.Unlock()
                }</span>
                <span class="cov8" title="1">rq.mu.RLock()
                err := rq.ctx.Err()
                since := now.Sub(rq.lastWrite)
                rq.mu.RUnlock()
                if err != nil </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">if since &gt; requestTimeout </span><span class="cov8" title="1">{
                        rq.cancel(newErrNoWebSocketRequest(rq))
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (rq *Request) cancelLocked(err error) <span class="cov8" title="1">{
        if rq.JawsKey != 0 &amp;&amp; rq.ctx.Err() == nil </span><span class="cov8" title="1">{
                if !rq.running.Load() </span><span class="cov8" title="1">{
                        err = newErrPendingCancelledLocked(rq, err)
                }</span>
                <span class="cov8" title="1">rq.cancelFn(rq.Jaws.Log(err))</span>
        }
}

func (rq *Request) cancel(err error) <span class="cov8" title="1">{
        rq.mu.Lock()
        defer rq.mu.Unlock()
        rq.cancelLocked(err)
}</span>

// Alert attempts to show an alert message on the current request webpage if it has an HTML element with the id 'jaws-alert'.
// The lvl argument should be one of Bootstraps alert levels: primary, secondary, success, danger, warning, info, light or dark.
//
// The default JaWS javascript only supports Bootstrap.js dismissable alerts.
func (rq *Request) Alert(lvl, msg string) <span class="cov8" title="1">{
        rq.Jaws.Broadcast(Message{
                Dest: rq,
                What: what.Alert,
                Data: lvl + "\n" + msg,
        })
}</span>

// AlertError calls Alert if the given error is not nil.
func (rq *Request) AlertError(err error) <span class="cov8" title="1">{
        if rq.Jaws.Log(err) != nil </span><span class="cov8" title="1">{
                rq.Alert("danger", html.EscapeString(err.Error()))
        }</span>
}

// Redirect requests the current Request to navigate to the given URL.
func (rq *Request) Redirect(url string) <span class="cov8" title="1">{
        rq.Jaws.Broadcast(Message{
                Dest: rq,
                What: what.Redirect,
                Data: url,
        })
}</span>

func (rq *Request) tagsOfLocked(elem *Element) (tags []any) <span class="cov8" title="1">{
        for tag, elems := range rq.tagMap </span><span class="cov8" title="1">{
                for _, e := range elems </span><span class="cov8" title="1">{
                        if e == elem </span><span class="cov8" title="1">{
                                tags = append(tags, tag)
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">return</span>
}

func (rq *Request) TagsOf(elem *Element) (tags []any) <span class="cov8" title="1">{
        if elem != nil </span><span class="cov8" title="1">{
                rq.mu.RLock()
                defer rq.mu.RUnlock()
                tags = rq.tagsOfLocked(elem)
        }</span>
        <span class="cov8" title="1">return</span>
}

// Dirty marks all Elements that have one or more of the given tags as dirty.
func (rq *Request) Dirty(tags ...any) <span class="cov8" title="1">{
        rq.Jaws.setDirty(MustTagExpand(rq, tags))
}</span>

// wantMessage returns true if the Request want the message.
func (rq *Request) wantMessage(msg *Message) (yes bool) <span class="cov8" title="1">{
        switch dest := msg.Dest.(type) </span>{
        case *Request:<span class="cov8" title="1">
                return dest == rq</span>
        case string:<span class="cov8" title="1"> // HTML id
                return true</span>
        case []any:<span class="cov8" title="1"> // more than one tag
                rq.mu.RLock()
                defer rq.mu.RUnlock()
                for i := range dest </span><span class="cov8" title="1">{
                        if _, yes = rq.tagMap[dest[i]]; yes </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
        default:<span class="cov8" title="1">
                rq.mu.RLock()
                _, yes = rq.tagMap[msg.Dest]
                rq.mu.RUnlock()</span>
        }
        <span class="cov8" title="1">return</span>
}

var nextJid Jid

func (rq *Request) newElementLocked(ui UI) (elem *Element) <span class="cov8" title="1">{
        elem = &amp;Element{
                jid:     Jid(atomic.AddInt64((*int64)(&amp;nextJid), 1)),
                ui:      ui,
                Request: rq,
        }
        rq.elems = append(rq.elems, elem)
        return
}</span>

// NewElement creates a new Element using the given UI object.
//
// Panics if the build tag "debug" is set and the UI object doesn't satisfy all requirements.
func (rq *Request) NewElement(ui UI) *Element <span class="cov8" title="1">{
        if deadlock.Debug </span><span class="cov8" title="1">{
                if err := newErrNotComparable(ui); err != nil </span><span class="cov8" title="1">{
                        panic(err)</span>
                }
        }
        <span class="cov8" title="1">rq.mu.Lock()
        defer rq.mu.Unlock()
        return rq.newElementLocked(ui)</span>
}

func (rq *Request) getElementByJidLocked(jid Jid) (elem *Element) <span class="cov8" title="1">{
        for _, e := range rq.elems </span><span class="cov8" title="1">{
                if e.Jid() == jid </span><span class="cov8" title="1">{
                        elem = e
                        break</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

func (rq *Request) hasTagLocked(elem *Element, tag any) bool <span class="cov8" title="1">{
        for _, e := range rq.tagMap[tag] </span><span class="cov8" title="1">{
                if elem == e </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (rq *Request) HasTag(elem *Element, tag any) (yes bool) <span class="cov8" title="1">{
        rq.mu.RLock()
        yes = rq.hasTagLocked(elem, tag)
        rq.mu.RUnlock()
        return
}</span>

func (rq *Request) appendDirtyTags(tags []any) <span class="cov8" title="1">{
        rq.mu.Lock()
        rq.todoDirt = append(rq.todoDirt, tags...)
        rq.mu.Unlock()
}</span>

// Tag adds the given tags to the given Element.
func (rq *Request) tagExpanded(elem *Element, expandedtags []any) <span class="cov8" title="1">{
        rq.mu.Lock()
        defer rq.mu.Unlock()
        for _, tag := range expandedtags </span><span class="cov8" title="1">{
                if !rq.hasTagLocked(elem, tag) </span><span class="cov8" title="1">{
                        rq.tagMap[tag] = append(rq.tagMap[tag], elem)
                }</span>
        }
}

// Tag adds the given tags to the given Element.
func (rq *Request) Tag(elem *Element, tags ...any) <span class="cov8" title="1">{
        if elem != nil &amp;&amp; len(tags) &gt; 0 &amp;&amp; elem.Request == rq </span><span class="cov8" title="1">{
                rq.tagExpanded(elem, MustTagExpand(elem.Request, tags))
        }</span>
}

// GetElements returns a list of the UI elements in the Request that have the given tag(s).
func (rq *Request) GetElements(tagitem any) (elems []*Element) <span class="cov8" title="1">{
        tags := MustTagExpand(rq, tagitem)
        seen := map[*Element]struct{}{}
        rq.mu.RLock()
        defer rq.mu.RUnlock()
        for _, tag := range tags </span><span class="cov8" title="1">{
                if el, ok := rq.tagMap[tag]; ok </span><span class="cov8" title="1">{
                        for _, e := range el </span><span class="cov8" title="1">{
                                if _, ok = seen[e]; !ok </span><span class="cov8" title="1">{
                                        seen[e] = struct{}{}
                                        elems = append(elems, el...)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return</span>
}

// process is the main message processing loop. Will unsubscribe broadcastMsgCh and close outboundMsgCh on exit.
func (rq *Request) process(broadcastMsgCh chan Message, incomingMsgCh &lt;-chan wsMsg, outboundMsgCh chan&lt;- wsMsg) <span class="cov8" title="1">{
        jawsDoneCh := rq.Jaws.Done()
        httpDoneCh := rq.httpDoneCh
        eventDoneCh := make(chan struct{})
        eventCallCh := make(chan eventFnCall, cap(outboundMsgCh))
        go rq.eventCaller(eventCallCh, outboundMsgCh, eventDoneCh)

        defer func() </span><span class="cov8" title="1">{
                rq.Jaws.unsubscribe(broadcastMsgCh)
                rq.killSession()
                close(eventCallCh)
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-eventCallCh:<span class="cov8" title="1"></span>
                        case &lt;-incomingMsgCh:<span class="cov8" title="1"></span>
                        case &lt;-eventDoneCh:<span class="cov8" title="1">
                                close(outboundMsgCh)
                                if x := recover(); x != nil </span><span class="cov8" title="1">{
                                        var err error
                                        var ok bool
                                        if err, ok = x.(error); !ok </span><span class="cov8" title="1">{
                                                err = fmt.Errorf("jaws: %v panic: %v", rq, x)
                                        }</span>
                                        <span class="cov8" title="1">rq.Jaws.MustLog(err)</span>
                                }
                                <span class="cov8" title="1">return</span>
                        }
                }
        }()

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                var tagmsg Message
                var wsmsg wsMsg
                var ok bool

                rq.sendQueue(outboundMsgCh)

                // Empty the dirty tags list and call JawsUpdate()
                // for identified elements. This queues up wsMsg's
                // in elem.wsQueue.
                for _, elem := range rq.makeUpdateList() </span><span class="cov8" title="1">{
                        elem.JawsUpdate()
                }</span>

                <span class="cov8" title="1">rq.sendQueue(outboundMsgCh)

                select </span>{
                case &lt;-jawsDoneCh:<span class="cov8" title="1"></span>
                case &lt;-httpDoneCh:<span class="cov8" title="1"></span>
                case &lt;-rq.Context().Done():<span class="cov8" title="1"></span>
                case tagmsg, ok = &lt;-broadcastMsgCh:<span class="cov8" title="1"></span>
                case wsmsg, ok = &lt;-incomingMsgCh:<span class="cov8" title="1">
                        if ok </span><span class="cov8" title="1">{
                                // incoming event message from the websocket
                                if wsmsg.Jid.IsValid() </span><span class="cov8" title="1">{
                                        switch wsmsg.What </span>{
                                        case what.Input, what.Click, what.Set:<span class="cov8" title="1">
                                                rq.queueEvent(eventCallCh, eventFnCall{jid: wsmsg.Jid, wht: wsmsg.What, data: wsmsg.Data})</span>
                                        case what.Remove:<span class="cov8" title="1">
                                                rq.handleRemove(wsmsg.Data)</span>
                                        }
                                }
                                <span class="cov8" title="1">continue</span>
                        }
                }

                <span class="cov8" title="1">if !ok </span><span class="cov8" title="1">{
                        // one of the channels are closed, so we're done
                        return
                }</span>

                // collect all elements marked with the tag in the message
                <span class="cov8" title="1">var todo []*Element
                switch v := tagmsg.Dest.(type) </span>{
                case nil:<span class="cov8" title="1"></span>
                        // matches no elements
                case *Request:<span class="cov8" title="1"></span>
                case string:<span class="cov8" title="1">
                        // target is a regular HTML ID
                        rq.queue(wsMsg{
                                Data: v + "\t" + strconv.Quote(tagmsg.Data),
                                What: tagmsg.What,
                                Jid:  -1,
                        })</span>
                default:<span class="cov8" title="1">
                        todo = rq.GetElements(v)</span>
                }

                <span class="cov8" title="1">switch tagmsg.What </span>{
                case what.Reload, what.Redirect, what.Order, what.Alert:<span class="cov8" title="1">
                        rq.queue(wsMsg{
                                Jid:  0,
                                Data: tagmsg.Data,
                                What: tagmsg.What,
                        })</span>
                default:<span class="cov8" title="1">
                        for _, elem := range todo </span><span class="cov8" title="1">{
                                switch tagmsg.What </span>{
                                case what.Delete:<span class="cov8" title="1">
                                        rq.queue(wsMsg{
                                                Jid:  elem.Jid(),
                                                What: what.Delete,
                                        })
                                        rq.deleteElement(elem)</span>
                                case what.Input, what.Click:<span class="cov8" title="1">
                                        // Input or Click messages received here are from Request.Send() or broadcasts.
                                        // they won't be sent out on the WebSocket, but will queue up a
                                        // call to the event function (if any).
                                        // primary usecase is tests.
                                        rq.queueEvent(eventCallCh, eventFnCall{jid: elem.Jid(), wht: tagmsg.What, data: tagmsg.Data})</span>
                                case what.Hook:<span class="cov8" title="1">
                                        // "hook" messages are used to synchronously call an event function.
                                        // the function must not send any messages itself, but may return
                                        // an error to be sent out as an alert message.
                                        // primary usecase is tests.
                                        if err := rq.Jaws.Log(rq.callAllEventHandlers(elem.Jid(), tagmsg.What, tagmsg.Data)); err != nil </span><span class="cov8" title="1">{
                                                rq.queue(wsMsg{
                                                        Data: tagmsg.Data,
                                                        Jid:  elem.Jid(),
                                                        What: what.Alert,
                                                })
                                        }</span>
                                case what.Update:<span class="cov8" title="1">
                                        elem.JawsUpdate()</span>
                                default:<span class="cov8" title="1">
                                        rq.queue(wsMsg{
                                                Data: tagmsg.Data,
                                                Jid:  elem.Jid(),
                                                What: tagmsg.What,
                                        })</span>
                                }
                        }
                }
        }
}

func (rq *Request) handleRemove(data string) <span class="cov8" title="1">{
        rq.mu.Lock()
        defer rq.mu.Unlock()
        for _, jidstr := range strings.Split(data, "\t") </span><span class="cov8" title="1">{
                if e := rq.getElementByJidLocked(jid.ParseString(jidstr)); e != nil </span><span class="cov8" title="1">{
                        rq.deleteElementLocked(e)
                }</span>
        }
}

func (rq *Request) queue(msg wsMsg) <span class="cov8" title="1">{
        rq.muQueue.Lock()
        rq.wsQueue = append(rq.wsQueue, msg)
        rq.muQueue.Unlock()
}</span>

func (rq *Request) callAllEventHandlers(id Jid, wht what.What, val string) (err error) <span class="cov8" title="1">{
        var elems []*Element
        rq.mu.RLock()
        if id == 0 </span><span class="cov8" title="1">{
                if wht == what.Click </span><span class="cov8" title="1">{
                        var after string
                        var found bool
                        val, after, found = strings.Cut(val, "\t")
                        for found </span><span class="cov8" title="1">{
                                var jidStr string
                                jidStr, after, found = strings.Cut(after, "\t")
                                if id = jid.ParseString(jidStr); id &gt; 0 </span><span class="cov8" title="1">{
                                        if e := rq.getElementByJidLocked(id); e != nil &amp;&amp; !e.deleted </span><span class="cov8" title="1">{
                                                elems = append(elems, e)
                                        }</span>
                                }
                        }
                }
        } else<span class="cov8" title="1"> {
                if e := rq.getElementByJidLocked(id); e != nil &amp;&amp; !e.deleted </span><span class="cov8" title="1">{
                        elems = append(elems, e)
                }</span>
        }
        <span class="cov8" title="1">rq.mu.RUnlock()

        for _, e := range elems </span><span class="cov8" title="1">{
                if err = callEventHandlers(e.Ui(), e, wht, val); err != ErrEventUnhandled </span><span class="cov8" title="1">{
                        return
                }</span>
        }
        <span class="cov8" title="1">if err == ErrEventUnhandled </span><span class="cov8" title="1">{
                err = nil
        }</span>
        <span class="cov8" title="1">return</span>
}

func (rq *Request) queueEvent(eventCallCh chan eventFnCall, call eventFnCall) <span class="cov8" title="1">{
        select </span>{
        case eventCallCh &lt;- call:<span class="cov8" title="1"></span>
        default:<span class="cov8" title="1">
                rq.Jaws.MustLog(fmt.Errorf("jaws: %v: eventCallCh is full sending %v", rq, call))
                return</span>
        }
}

func (rq *Request) getSendMsgs() (toSend []wsMsg) <span class="cov8" title="1">{
        rq.mu.RLock()
        defer rq.mu.RUnlock()

        validJids := map[Jid]struct{}{}
        for _, elem := range rq.elems </span><span class="cov8" title="1">{
                if !elem.deleted </span><span class="cov8" title="1">{
                        validJids[elem.Jid()] = struct{}{}
                }</span>
        }

        <span class="cov8" title="1">rq.muQueue.Lock()
        defer rq.muQueue.Unlock()
        if len(rq.wsQueue) &gt; 0 </span><span class="cov8" title="1">{
                for i := range rq.wsQueue </span><span class="cov8" title="1">{
                        ok := rq.wsQueue[i].Jid &lt; 1 || rq.wsQueue[i].What == what.Delete
                        if !ok </span><span class="cov8" title="1">{
                                _, ok = validJids[rq.wsQueue[i].Jid]
                        }</span>
                        <span class="cov8" title="1">if ok </span><span class="cov8" title="1">{
                                toSend = append(toSend, rq.wsQueue[i])
                        }</span>
                }
                <span class="cov8" title="1">rq.wsQueue = rq.wsQueue[:0]</span>
        }

        <span class="cov8" title="1">slices.SortStableFunc(toSend, func(a, b wsMsg) int </span><span class="cov8" title="1">{ return int(a.Jid - b.Jid) }</span>)
        <span class="cov8" title="1">return</span>
}

func (rq *Request) sendQueue(outboundMsgCh chan&lt;- wsMsg) <span class="cov8" title="1">{
        for _, msg := range rq.getSendMsgs() </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-rq.Context().Done():<span class="cov8" title="1"></span>
                case outboundMsgCh &lt;- msg:<span class="cov8" title="1"></span>
                }
        }
}

func deleteElement(s []*Element, e *Element) []*Element <span class="cov8" title="1">{
        for i, v := range s </span><span class="cov8" title="1">{
                if e == v </span><span class="cov8" title="1">{
                        j := i
                        for i++; i &lt; len(s); i++ </span><span class="cov8" title="1">{
                                v = s[i]
                                if e != v </span><span class="cov8" title="1">{
                                        s[j] = v
                                        j++
                                }</span>
                        }
                        <span class="cov8" title="1">for i := j; i &lt; len(s); i++ </span><span class="cov8" title="1">{
                                s[i] = nil
                        }</span>
                        <span class="cov8" title="1">return s[:j]</span>
                }
        }
        <span class="cov8" title="1">return s</span>
}

func (rq *Request) deleteElementLocked(e *Element) <span class="cov8" title="1">{
        e.deleted = true
        rq.elems = deleteElement(rq.elems, e)
        for k := range rq.tagMap </span><span class="cov8" title="1">{
                rq.tagMap[k] = deleteElement(rq.tagMap[k], e)
        }</span>
}

func (rq *Request) deleteElement(e *Element) <span class="cov8" title="1">{
        rq.mu.Lock()
        defer rq.mu.Unlock()
        rq.deleteElementLocked(e)
}</span>

func (rq *Request) makeUpdateList() (todo []*Element) <span class="cov8" title="1">{
        rq.mu.Lock()
        seen := map[*Element]struct{}{}
        for _, tag := range rq.todoDirt </span><span class="cov8" title="1">{
                for _, elem := range rq.tagMap[tag] </span><span class="cov8" title="1">{
                        if _, ok := seen[elem]; !ok </span><span class="cov8" title="1">{
                                seen[elem] = struct{}{}
                                todo = append(todo, elem)
                        }</span>
                }
        }
        <span class="cov8" title="1">clear(rq.todoDirt)
        rq.todoDirt = rq.todoDirt[:0]
        rq.mu.Unlock()
        sort.Slice(todo, func(i, j int) bool </span><span class="cov8" title="1">{ return todo[i].Jid() &lt; todo[j].Jid() }</span>)
        <span class="cov8" title="1">return</span>
}

// eventCaller calls event functions
func (rq *Request) eventCaller(eventCallCh &lt;-chan eventFnCall, outboundMsgCh chan&lt;- wsMsg, eventDoneCh chan&lt;- struct{}) <span class="cov8" title="1">{
        defer close(eventDoneCh)
        for call := range eventCallCh </span><span class="cov8" title="1">{
                if err := rq.callAllEventHandlers(call.jid, call.wht, call.data); err != nil </span><span class="cov8" title="1">{
                        var m wsMsg
                        m.FillAlert(err)
                        select </span>{
                        case outboundMsgCh &lt;- m:<span class="cov8" title="1"></span>
                        default:<span class="cov8" title="1">
                                _ = rq.Jaws.Log(fmt.Errorf("jaws: outboundMsgCh full sending event error '%s'", err.Error()))</span>
                        }
                }
        }
}

// onConnect calls the Request's ConnectFn if it's not nil, and returns the error from it.
// Returns nil if ConnectFn is nil.
func (rq *Request) onConnect() (err error) <span class="cov8" title="1">{
        rq.mu.RLock()
        connectFn := rq.connectFn
        rq.mu.RUnlock()
        if connectFn != nil </span><span class="cov8" title="1">{
                err = connectFn(rq)
        }</span>
        <span class="cov8" title="1">return</span>
}

// Writer returns a RequestWriter with this Request and the given Writer.
func (rq *Request) Writer(w io.Writer) RequestWriter <span class="cov8" title="1">{
        return RequestWriter{rq: rq, Writer: w}
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package jaws

import (
        "io"
        "net/http"
)

type RequestWriter struct {
        rq *Request
        io.Writer
}

func (rw RequestWriter) UI(ui UI, params ...any) error <span class="cov8" title="1">{
        return rw.rq.NewElement(ui).JawsRender(rw, params)
}</span>

func (rw RequestWriter) Write(p []byte) (n int, err error) <span class="cov8" title="1">{
        rw.rq.rendering.Store(true)
        return rw.Writer.Write(p)
}</span>

// Request returns the current jaws.Request.
func (rw RequestWriter) Request() *Request <span class="cov8" title="1">{
        return rw.rq
}</span>

// Initial returns the initial http.Request.
func (rw RequestWriter) Initial() *http.Request <span class="cov8" title="1">{
        return rw.Request().Initial()
}</span>

// HeadHTML outputs the HTML code needed in the HEAD section.
func (rw RequestWriter) HeadHTML() error <span class="cov8" title="1">{
        return rw.Request().HeadHTML(rw)
}</span>

// TailHTML writes optional HTML code at the end of the page's BODY section that
// will immediately apply updates made during initial rendering.
func (rw RequestWriter) TailHTML() error <span class="cov8" title="1">{
        return rw.Request().TailHTML(rw)
}</span>

// Session returns the Requests's Session, or nil.
func (rw RequestWriter) Session() *Session <span class="cov8" title="1">{
        return rw.Request().Session()
}</span>

// Get calls Request().Get()
func (rw RequestWriter) Get(key string) (val any) <span class="cov8" title="1">{
        return rw.Request().Get(key)
}</span>

// Set calls Request().Set()
func (rw RequestWriter) Set(key string, val any) <span class="cov8" title="1">{
        rw.Request().Set(key, val)
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package jaws

import "sync"

type RWLocker interface {
        sync.Locker
        RLock()
        RUnlock()
}

type rwlocker struct {
        sync.Locker
}

func (l rwlocker) RLock() <span class="cov8" title="1">{
        l.Lock()
}</span>

func (l rwlocker) RUnlock() <span class="cov8" title="1">{
        l.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package jaws

import (
        "net/http"
        "strings"
)

var headerCacheNoCache = []string{"no-cache"}

// ServeHTTP can handle the required JaWS endpoints, which all start with "/jaws/".
func (jw *Jaws) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusMethodNotAllowed)
                return
        }</span>
        <span class="cov8" title="1">if len(r.RequestURI) &gt; 6 &amp;&amp; strings.HasPrefix(r.RequestURI, "/jaws/") </span><span class="cov8" title="1">{
                if r.RequestURI[6] == '.' </span><span class="cov8" title="1">{
                        switch r.RequestURI </span>{
                        case jw.serveCSS.Name:<span class="cov8" title="1">
                                jw.serveCSS.ServeHTTP(w, r)
                                return</span>
                        case jw.serveJS.Name:<span class="cov8" title="1">
                                jw.serveJS.ServeHTTP(w, r)
                                return</span>
                        case "/jaws/.ping":<span class="cov8" title="1">
                                w.Header()["Cache-Control"] = headerCacheNoCache
                                select </span>{
                                case &lt;-jw.Done():<span class="cov8" title="1">
                                        w.WriteHeader(http.StatusServiceUnavailable)</span>
                                default:<span class="cov8" title="1">
                                        w.WriteHeader(http.StatusNoContent)</span>
                                }
                                <span class="cov8" title="1">return</span>
                        }
                } else<span class="cov8" title="1"> if rq := jw.UseRequest(JawsKeyValue(r.RequestURI[6:]), r); rq != nil </span><span class="cov8" title="1">{
                        rq.ServeHTTP(w, r)
                        return
                }</span>
        }
        <span class="cov8" title="1">w.WriteHeader(http.StatusNotFound)</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package jaws

import (
        "net/http"
        "net/netip"
        "time"

        "github.com/linkdata/deadlock"
        "github.com/linkdata/jaws/what"
)

type Session struct {
        jw        *Jaws
        sessionID uint64
        remoteIP  netip.Addr
        mu        deadlock.RWMutex // protects following
        requests  []*Request
        deadline  time.Time
        cookie    http.Cookie
        data      map[string]any
}

func newSession(jw *Jaws, sessionID uint64, remoteIP netip.Addr) *Session <span class="cov8" title="1">{
        return &amp;Session{
                jw:        jw,
                sessionID: sessionID,
                remoteIP:  remoteIP,
                deadline:  time.Now().Add(time.Minute),
                cookie: http.Cookie{
                        Name:     jw.CookieName,
                        Path:     "/",
                        Value:    JawsKeyString(sessionID),
                        Secure:   true,
                        HttpOnly: true,
                        SameSite: http.SameSiteLaxMode,
                },
                data: make(map[string]any),
        }
}</span>

func (sess *Session) isDeadLocked() bool <span class="cov8" title="1">{
        return sess.cookie.MaxAge &lt; 0 || (len(sess.requests) == 0 &amp;&amp; time.Since(sess.deadline) &gt; 0)
}</span>

func (sess *Session) isDead() (yes bool) <span class="cov8" title="1">{
        sess.mu.RLock()
        yes = sess.isDeadLocked()
        sess.mu.RUnlock()
        return
}</span>

func (sess *Session) addRequest(rq *Request) <span class="cov8" title="1">{
        sess.mu.Lock()
        sess.requests = append(sess.requests, rq)
        sess.mu.Unlock()
}</span>

func (sess *Session) delRequest(rq *Request) <span class="cov8" title="1">{
        sess.mu.Lock()
        defer sess.mu.Unlock()
        for i := range sess.requests </span><span class="cov8" title="1">{
                if sess.requests[i] == rq </span><span class="cov8" title="1">{
                        l := len(sess.requests)
                        if l &gt; 1 </span><span class="cov8" title="1">{
                                sess.requests[i] = sess.requests[l-1]
                        }</span>
                        <span class="cov8" title="1">sess.requests = sess.requests[:l-1]
                        break</span>
                }
        }
        <span class="cov8" title="1">if len(sess.requests) == 0 </span><span class="cov8" title="1">{
                sess.deadline = time.Now().Add(time.Minute)
        }</span>
}

// Jaws returns the Jaws instance of the Session, or nil.
// It is safe to call on a nil Session.
func (sess *Session) Jaws() (jw *Jaws) <span class="cov8" title="1">{
        if sess != nil </span><span class="cov8" title="1">{
                jw = sess.jw
        }</span>
        <span class="cov8" title="1">return</span>
}

// Get returns the value associated with the key, or nil.
// It is safe to call on a nil Session.
func (sess *Session) Get(key string) (val any) <span class="cov8" title="1">{
        if sess != nil </span><span class="cov8" title="1">{
                sess.mu.RLock()
                val = sess.data[key]
                sess.mu.RUnlock()
        }</span>
        <span class="cov8" title="1">return</span>
}

// Set sets a value to be associated with the key.
// If value is nil, the key is removed from the session.
// It is safe to call on a nil Session.
func (sess *Session) Set(key string, val any) <span class="cov8" title="1">{
        if sess != nil </span><span class="cov8" title="1">{
                sess.mu.Lock()
                if val == nil </span><span class="cov8" title="1">{
                        delete(sess.data, key)
                }</span> else<span class="cov8" title="1"> {
                        sess.data[key] = val
                }</span>
                <span class="cov8" title="1">sess.mu.Unlock()</span>
        }
}

// ID returns the session ID, a 64-bit random value.
// It is safe to call on a nil Session, in which case it returns zero.
func (sess *Session) ID() (id uint64) <span class="cov8" title="1">{
        if sess != nil </span><span class="cov8" title="1">{
                id = sess.sessionID
        }</span>
        <span class="cov8" title="1">return</span>
}

// CookieValue returns the session cookie value.
// It is safe to call on a nil Session, in which case it returns an empty string.
func (sess *Session) CookieValue() (s string) <span class="cov8" title="1">{
        if sess != nil </span><span class="cov8" title="1">{
                s = sess.cookie.Value
        }</span>
        <span class="cov8" title="1">return</span>
}

// IP returns the remote IP the session is bound to (which may be nil).
// It is safe to call on a nil Session, in which case it returns nil.
func (sess *Session) IP() (ip netip.Addr) <span class="cov8" title="1">{
        if sess != nil </span><span class="cov8" title="1">{
                ip = sess.remoteIP
        }</span>
        <span class="cov8" title="1">return</span>
}

// Cookie returns a cookie for the Session. Returns a delete cookie if the Session is expired.
// It is safe to call on a nil Session, in which case it returns nil.
func (sess *Session) Cookie() (cookie *http.Cookie) <span class="cov8" title="1">{
        if sess != nil </span><span class="cov8" title="1">{
                cookie = &amp;http.Cookie{}
                sess.mu.RLock()
                *cookie = sess.cookie
                if sess.isDeadLocked() </span><span class="cov8" title="1">{
                        cookie.MaxAge = -1
                }</span>
                <span class="cov8" title="1">sess.mu.RUnlock()</span>
        }
        <span class="cov8" title="1">return</span>
}

// Close invalidates and expires the Session.
// Future Requests won't be able to associate with it, and Cookie() will return a deletion cookie.
//
// Existing Requests already associated with the Session will ask the browser to reload the pages.
// Key/value pairs in the Session are left unmodified, you can use `Session.Clear()` to remove all of them.
//
// Returns a cookie to be sent to the client browser that will delete the browser cookie.
// Returns nil if the session was not found or is already closed.
// It is safe to call on a nil Session.
func (sess *Session) Close() (cookie *http.Cookie) <span class="cov8" title="1">{
        if sess != nil </span><span class="cov8" title="1">{
                sess.jw.deleteSession(sess.sessionID)
                sess.mu.Lock()
                sess.cookie.MaxAge = -1
                sess.broadcastLocked(Message{What: what.Reload})
                sess.requests = sess.requests[:0]
                cookie = &amp;sess.cookie
                sess.mu.Unlock()
        }</span>
        <span class="cov8" title="1">return</span>
}

// Reload calls Broadcast with a message asking browsers to reload the page.
func (sess *Session) Reload() <span class="cov8" title="1">{
        sess.Broadcast(Message{What: what.Reload})
}</span>

// Clear removes all key/value pairs from the session.
// It is safe to call on a nil Session.
func (sess *Session) Clear() <span class="cov8" title="1">{
        if sess != nil </span><span class="cov8" title="1">{
                sess.mu.Lock()
                for k := range sess.data </span><span class="cov8" title="1">{
                        delete(sess.data, k)
                }</span>
                <span class="cov8" title="1">sess.mu.Unlock()</span>
        }
}

// Requests returns a list of the Requests using this Session.
// It is safe to call on a nil Session.
func (sess *Session) Requests() (rl []*Request) <span class="cov8" title="1">{
        if sess != nil </span><span class="cov8" title="1">{
                sess.mu.RLock()
                rl = append(rl, sess.requests...)
                sess.mu.RUnlock()
        }</span>
        <span class="cov8" title="1">return</span>
}

func (sess *Session) broadcastLocked(msg Message) <span class="cov8" title="1">{
        for _, rq := range sess.requests </span><span class="cov8" title="1">{
                msg.Dest = rq
                sess.jw.Broadcast(msg)
        }</span>
}

// Broadcast attempts to send a message to all Requests using this session.
// It is safe to call on a nil Session.
func (sess *Session) Broadcast(msg Message) <span class="cov8" title="1">{
        if sess != nil </span><span class="cov8" title="1">{
                sess.mu.RLock()
                defer sess.mu.RUnlock()
                sess.broadcastLocked(msg)
        }</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package jaws

import "net/http"

type sessioner struct {
        jw *Jaws
        h  http.Handler
}

func (sess sessioner) ServeHTTP(wr http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if sess.jw.GetSession(r) == nil </span><span class="cov8" title="1">{
                sess.jw.newSession(wr, r)
        }</span>
        <span class="cov8" title="1">sess.h.ServeHTTP(wr, r)</span>
}

// Session returns a http.Handler that ensures a JaWS Session exists before invoking h.
func (jw *Jaws) Session(h http.Handler) http.Handler <span class="cov8" title="1">{
        return sessioner{jw: jw, h: h}
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package jaws

import (
        "fmt"
)

type Setter[T comparable] interface {
        Getter[T]
        // JawsSet may return ErrValueUnchanged to indicate value was already set.
        JawsSet(elem *Element, value T) (err error)
}

type setterReadOnly[T comparable] struct {
        Getter[T]
}

func (setterReadOnly[T]) JawsSet(*Element, T) error <span class="cov8" title="1">{
        return ErrValueNotSettable
}</span>

func (s setterReadOnly[T]) JawsGetTag(*Request) any <span class="cov8" title="1">{
        return s.Getter
}</span>

type setterStatic[T comparable] struct {
        v T
}

func (setterStatic[T]) JawsSet(*Element, T) error <span class="cov8" title="1">{
        return ErrValueNotSettable
}</span>

func (s setterStatic[T]) JawsGet(*Element) T <span class="cov8" title="1">{
        return s.v
}</span>

func (s setterStatic[T]) JawsGetTag(*Request) any <span class="cov8" title="1">{
        return nil
}</span>

func makeSetter[T comparable](v any) Setter[T] <span class="cov8" title="1">{
        switch v := v.(type) </span>{
        case Setter[T]:<span class="cov8" title="1">
                return v</span>
        case Getter[T]:<span class="cov8" title="1">
                return setterReadOnly[T]{v}</span>
        case T:<span class="cov8" title="1">
                return setterStatic[T]{v}</span>
        }
        <span class="cov8" title="1">var blank T
        panic(fmt.Errorf("expected jaws.Setter[%T], jaws.Getter[%T] or %T not %T", blank, blank, blank, v))</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package jaws

import (
        "fmt"
)

type numeric interface {
        ~float32 | ~float64 |
                ~int | ~int8 | ~int16 | ~int32 | ~int64 |
                ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64
}

type SetterFloat64[T numeric] interface {
        Getter[T]
        // JawsSet may return ErrValueUnchanged to indicate value was already set.
        JawsSet(elem *Element, value T) (err error)
}

type setterFloat64[T numeric] struct {
        Setter[T]
}

func (s setterFloat64[T]) JawsGet(e *Element) float64 <span class="cov8" title="1">{
        v := s.Setter.JawsGet(e)
        return float64(v)
}</span>

func (s setterFloat64[T]) JawsSet(e *Element, v float64) error <span class="cov8" title="1">{
        return s.Setter.JawsSet(e, T(v))
}</span>

func (s setterFloat64[T]) JawsGetTag(*Request) any <span class="cov8" title="1">{
        return s.Setter
}</span>

type setterFloat64ReadOnly[T numeric] struct {
        Getter[T]
}

func (s setterFloat64ReadOnly[T]) JawsGet(e *Element) float64 <span class="cov8" title="1">{
        v := s.Getter.JawsGet(e)
        return float64(v)
}</span>

func (setterFloat64ReadOnly[T]) JawsSet(*Element, float64) error <span class="cov8" title="1">{
        return ErrValueNotSettable
}</span>

func (s setterFloat64ReadOnly[T]) JawsGetTag(*Request) any <span class="cov8" title="1">{
        return s.Getter
}</span>

type setterFloat64Static[T numeric] struct {
        v float64
}

func (setterFloat64Static[T]) JawsSet(*Element, float64) error <span class="cov8" title="1">{
        return ErrValueNotSettable
}</span>

func (s setterFloat64Static[T]) JawsGet(*Element) float64 <span class="cov8" title="1">{
        return s.v
}</span>

func (s setterFloat64Static[T]) JawsGetTag(*Request) any <span class="cov8" title="1">{
        return nil
}</span>

func makeSetterFloat64for[T numeric](s *Setter[float64], v any) bool <span class="cov8" title="1">{
        switch v := v.(type) </span>{
        case Setter[T]:<span class="cov8" title="1">
                *s = setterFloat64[T]{Setter: v}
                return true</span>
        case Getter[T]:<span class="cov8" title="1">
                *s = setterFloat64ReadOnly[T]{Getter: v}
                return true</span>
        case T:<span class="cov8" title="1">
                *s = setterFloat64Static[T]{float64(v)}
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

func makeSetterFloat64(v any) (s Setter[float64]) <span class="cov8" title="1">{
        switch v := v.(type) </span>{
        case Setter[float64]:<span class="cov8" title="1">
                return v</span>
        case Getter[float64]:<span class="cov8" title="1">
                return setterReadOnly[float64]{v}</span>
        case float64:<span class="cov8" title="1">
                return setterStatic[float64]{v}</span>
        default:<span class="cov8" title="1">
                var ok bool
                ok = ok || makeSetterFloat64for[int64](&amp;s, v)
                ok = ok || makeSetterFloat64for[uint64](&amp;s, v)
                ok = ok || makeSetterFloat64for[int](&amp;s, v)
                ok = ok || makeSetterFloat64for[uint](&amp;s, v)
                ok = ok || makeSetterFloat64for[int32](&amp;s, v)
                ok = ok || makeSetterFloat64for[uint32](&amp;s, v)
                ok = ok || makeSetterFloat64for[int8](&amp;s, v)
                ok = ok || makeSetterFloat64for[int16](&amp;s, v)
                ok = ok || makeSetterFloat64for[uint8](&amp;s, v)
                ok = ok || makeSetterFloat64for[uint16](&amp;s, v)
                ok = ok || makeSetterFloat64for[float32](&amp;s, v)
                if ok </span><span class="cov8" title="1">{
                        return
                }</span>
        }
        <span class="cov8" title="1">panic(fmt.Errorf("expected jaws.Setter[float64], jaws.Getter[float64] or float64 not %T", v))</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package jaws

import (
        "errors"
        "fmt"
        "net/http"
        "net/url"
        "path"

        "github.com/linkdata/jaws/staticserve"
)

// HandleFunc matches the signature of http.ServeMux.Handle(), but is called without
// method or parameters for the pattern. E.g. ("/static/filename.1234567.js").
type HandleFunc = func(uri string, handler http.Handler)

// SetupFunc is called by Setup and allows setting up addons for JaWS.
//
// The urls returned will be used in a call to GenerateHeadHTML.
type SetupFunc = func(jw *Jaws, handleFn HandleFunc, prefix string) (urls []*url.URL, err error)

// makeAbsPath prepends the prefix to u's path if it is relative.
// Returns the (possibly modified) u.
func makeAbsPath(prefix string, u *url.URL) *url.URL <span class="cov8" title="1">{
        if prefix != "" &amp;&amp; u != nil </span><span class="cov8" title="1">{
                if !path.IsAbs(u.Path) </span><span class="cov8" title="1">{
                        u.Path = path.Join(prefix, u.Path)
                }</span>
        }
        <span class="cov8" title="1">return u</span>
}

// Setup configures Jaws with extra functionality and resources.
//
// The list of extras can be strings, *url.URL or *staticserve.StaticServe (URL resources)
// or a setup function matching jaws.JawsSetupFunc like jawsboot.JawsSetup.
//
// It calls GenerateHeadHTML with the final list of URLs, with any
// relative URL paths prefixed with prefix.
func (jw *Jaws) Setup(handleFn HandleFunc, prefix string, extras ...any) (err error) <span class="cov8" title="1">{
        var urls []*url.URL

        handleStaticServe := func(ss *staticserve.StaticServe) </span><span class="cov8" title="1">{
                u, uerr := url.Parse(ss.Name)
                err = errors.Join(err, uerr)
                if u != nil </span><span class="cov8" title="1">{
                        u = makeAbsPath(prefix, u)
                        urls = append(urls, u)
                        if handleFn != nil </span><span class="cov8" title="1">{
                                handleFn(u.String(), ss)
                        }</span>
                }
        }

        <span class="cov8" title="1">for _, extra := range extras </span><span class="cov8" title="1">{
                switch extra := extra.(type) </span>{
                case []*staticserve.StaticServe:<span class="cov8" title="1">
                        for _, ss := range extra </span><span class="cov8" title="1">{
                                handleStaticServe(ss)
                        }</span>
                case string:<span class="cov8" title="1">
                        u, uerr := url.Parse(extra)
                        err = errors.Join(err, uerr)
                        urls = append(urls, makeAbsPath(prefix, u))</span>
                case *url.URL:<span class="cov8" title="1">
                        urls = append(urls, makeAbsPath(prefix, extra))</span>
                case *staticserve.StaticServe:<span class="cov8" title="1">
                        handleStaticServe(extra)</span>
                case SetupFunc:<span class="cov8" title="1">
                        setupurls, setuperr := extra(jw, handleFn, prefix)
                        err = errors.Join(err, setuperr)
                        for _, u := range setupurls </span><span class="cov8" title="1">{
                                urls = append(urls, makeAbsPath(prefix, u))
                        }</span>
                default:<span class="cov8" title="1">
                        panic(fmt.Sprintf("expected a string, *url.URL, *staticserve.StaticServe or jaws.SetupFunc, not %T", extra))</span>
                }
        }
        <span class="cov8" title="1">var extraFiles []string
        for _, u := range urls </span><span class="cov8" title="1">{
                if u != nil </span><span class="cov8" title="1">{
                        extraFiles = append(extraFiles, u.String())
                }</span>
        }
        <span class="cov8" title="1">err = errors.Join(err, jw.GenerateHeadHTML(extraFiles...))
        return</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package jaws

type stringGetterFunc struct {
        fn   func(*Element) string
        tags []any
}

func (g *stringGetterFunc) JawsGet(e *Element) string <span class="cov8" title="1">{
        return g.fn(e)
}</span>

func (g *stringGetterFunc) JawsGetTag(e *Request) any <span class="cov8" title="1">{
        return g.tags
}</span>

// StringGetterFunc wraps a function and returns a Getter[string]
func StringGetterFunc(fn func(elem *Element) (s string), tags ...any) Getter[string] <span class="cov8" title="1">{
        return &amp;stringGetterFunc{fn: fn, tags: tags}
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package jaws

import (
        "fmt"
        "html/template"
        "reflect"

        "github.com/linkdata/deadlock"
)

type Tag string

func TagString(tag any) string <span class="cov8" title="1">{
        if rv := reflect.ValueOf(tag); rv.IsValid() </span><span class="cov8" title="1">{
                if rv.Kind() == reflect.Pointer </span><span class="cov8" title="1">{
                        return fmt.Sprintf("%T(%p)", tag, tag)
                }</span> else<span class="cov8" title="1"> if stringer, ok := tag.(fmt.Stringer); ok </span><span class="cov8" title="1">{
                        return fmt.Sprintf("%T(%s)", tag, stringer.String())
                }</span>
        }
        <span class="cov8" title="1">return fmt.Sprintf("%#v", tag)</span>
}

type errTooManyTags struct{}

func (errTooManyTags) Error() string <span class="cov8" title="1">{
        return "too many tags"
}</span>

var ErrTooManyTags = errTooManyTags{}

func tagExpand(l int, rq *Request, tag any, result []any) ([]any, error) <span class="cov8" title="1">{
        if l &gt; 10 || len(result) &gt; 100 </span><span class="cov8" title="1">{
                return result, ErrTooManyTags
        }</span>
        <span class="cov8" title="1">switch data := tag.(type) </span>{
        case string:<span class="cov8" title="1"></span>
        case template.HTML:<span class="cov8" title="1"></span>
        case template.HTMLAttr:<span class="cov8" title="1"></span>
        case int:<span class="cov8" title="1"></span>
        case int8:<span class="cov8" title="1"></span>
        case int16:<span class="cov8" title="1"></span>
        case int32:<span class="cov8" title="1"></span>
        case int64:<span class="cov8" title="1"></span>
        case uint:<span class="cov8" title="1"></span>
        case uint8:<span class="cov8" title="1"></span>
        case uint16:<span class="cov8" title="1"></span>
        case uint32:<span class="cov8" title="1"></span>
        case uint64:<span class="cov8" title="1"></span>
        case float32:<span class="cov8" title="1"></span>
        case float64:<span class="cov8" title="1"></span>
        case bool:<span class="cov8" title="1"></span>
        case error:<span class="cov8" title="1"></span>

        case nil:<span class="cov8" title="1">
                return result, nil</span>
        case []Tag:<span class="cov8" title="1">
                for _, v := range data </span><span class="cov8" title="1">{
                        result = append(result, v)
                }</span>
                <span class="cov8" title="1">return result, nil</span>
        case TagGetter:<span class="cov8" title="1">
                if newTag := data.JawsGetTag(rq); tag != newTag </span><span class="cov8" title="1">{
                        return tagExpand(l+1, rq, newTag, result)
                }</span>
                <span class="cov8" title="1">return append(result, tag), nil</span>
        case []any:<span class="cov8" title="1">
                var err error
                for _, v := range data </span><span class="cov8" title="1">{
                        if result, err = tagExpand(l+1, rq, v, result); err != nil </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
                <span class="cov8" title="1">return result, err</span>
        default:<span class="cov8" title="1">
                if deadlock.Debug </span><span class="cov8" title="1">{
                        if err := newErrNotComparable(data); err != nil </span><span class="cov8" title="1">{
                                return result, err
                        }</span>
                }
                <span class="cov8" title="1">return append(result, data), nil</span>
        }
        <span class="cov8" title="1">return result, errIllegalTagType{tag: tag}</span>
}

func TagExpand(rq *Request, tag any) ([]any, error) <span class="cov8" title="1">{
        return tagExpand(0, rq, tag, nil)
}</span>

func MustTagExpand(rq *Request, tag any) []any <span class="cov8" title="1">{
        result, err := TagExpand(rq, tag)
        if err != nil </span><span class="cov8" title="1">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package jaws

import (
        "bytes"
        "fmt"
        "html/template"
        "io"
        "strings"
        "text/template/parse"

        "github.com/linkdata/deadlock"
        "github.com/linkdata/jaws/what"
)

type Template struct {
        Name string // Template name to be looked up using jaws.LookupTemplate()
        Dot  any    // Dot value to place in With structure
}

var _ UI = Template{}           // statically ensure interface is defined
var _ EventHandler = Template{} // statically ensure interface is defined

func (t Template) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("{%q, %s}", t.Name, TagString(t.Dot))
}</span>

func findJidOrJsOrHTMLNode(node parse.Node) (found bool) <span class="cov8" title="1">{
        switch node := node.(type) </span>{
        case *parse.TextNode:<span class="cov8" title="1">
                if node != nil </span><span class="cov8" title="1">{
                        found = found || bytes.Contains(node.Text, []byte("&lt;/html&gt;"))
                }</span>
        case *parse.ListNode:<span class="cov8" title="1">
                if node != nil </span><span class="cov8" title="1">{
                        for _, n := range node.Nodes </span><span class="cov8" title="1">{
                                found = found || findJidOrJsOrHTMLNode(n)
                        }</span>
                }
        case *parse.ActionNode:<span class="cov8" title="1">
                if node != nil </span><span class="cov8" title="1">{
                        found = findJidOrJsOrHTMLNode(node.Pipe)
                }</span>
        case *parse.WithNode:<span class="cov8" title="1">
                if node != nil </span><span class="cov8" title="1">{
                        found = findJidOrJsOrHTMLNode(&amp;node.BranchNode)
                }</span>
        case *parse.BranchNode:<span class="cov8" title="1">
                if node != nil </span><span class="cov8" title="1">{
                        found = findJidOrJsOrHTMLNode(node.Pipe)
                        found = found || findJidOrJsOrHTMLNode(node.List)
                        found = found || findJidOrJsOrHTMLNode(node.ElseList)
                }</span>
        case *parse.IfNode:<span class="cov8" title="1">
                if node != nil </span><span class="cov8" title="1">{
                        found = findJidOrJsOrHTMLNode(node.Pipe)
                        found = found || findJidOrJsOrHTMLNode(node.List)
                        found = found || findJidOrJsOrHTMLNode(node.ElseList)
                }</span>
        case *parse.PipeNode:<span class="cov8" title="1">
                if node != nil </span><span class="cov8" title="1">{
                        for _, n := range node.Cmds </span><span class="cov8" title="1">{
                                found = found || findJidOrJsOrHTMLNode(n)
                        }</span>
                }
        case *parse.CommandNode:<span class="cov8" title="1">
                if node != nil </span><span class="cov8" title="1">{
                        for _, n := range node.Args </span><span class="cov8" title="1">{
                                found = found || findJidOrJsOrHTMLNode(n)
                        }</span>
                }
        case *parse.VariableNode:<span class="cov8" title="1">
                if node != nil </span><span class="cov8" title="1">{
                        for _, s := range node.Ident </span><span class="cov8" title="1">{
                                found = found || (s == "Jid") || (s == "JsFunc") || (s == "JsVar")
                        }</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

func (t Template) JawsRender(e *Element, wr io.Writer, params []any) (err error) <span class="cov8" title="1">{
        var expandedtags []any
        if expandedtags, err = TagExpand(e.Request, t.Dot); err == nil </span><span class="cov8" title="1">{
                e.Request.tagExpanded(e, expandedtags)
                tags, handlers, attrs := ParseParams(params)
                e.Tag(tags...)
                e.handlers = append(e.handlers, handlers...)
                attrstr := template.HTMLAttr(strings.Join(attrs, " ")) // #nosec G203
                var auth Auth
                auth = defaultAuth{}
                if f := e.Request.Jaws.MakeAuth; f != nil </span><span class="cov8" title="1">{
                        auth = f(e.Request)
                }</span>
                <span class="cov8" title="1">err = errMissingTemplate(t.Name)
                if tmpl := e.Request.Jaws.LookupTemplate(t.Name); tmpl != nil </span><span class="cov8" title="1">{
                        err = tmpl.Execute(wr, With{
                                Element:       e,
                                RequestWriter: e.Request.Writer(wr),
                                Dot:           t.Dot,
                                Attrs:         attrstr,
                                Auth:          auth,
                        })
                        if deadlock.Debug &amp;&amp; e.Jaws.Logger != nil </span><span class="cov8" title="1">{
                                if !findJidOrJsOrHTMLNode(tmpl.Tree.Root) </span><span class="cov8" title="1">{
                                        e.Jaws.Logger.Warn("jaws: template has no Jid reference", "template", t.Name)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return</span>
}

func (t Template) JawsUpdate(e *Element) <span class="cov8" title="1">{
        if dot, ok := t.Dot.(Updater); ok </span><span class="cov8" title="1">{
                dot.JawsUpdate(e)
        }</span>
}

func (t Template) JawsEvent(e *Element, wht what.What, val string) error <span class="cov8" title="1">{
        return callEventHandlers(t.Dot, e, wht, val)
}</span>

func NewTemplate(name string, dot any) Template <span class="cov8" title="1">{
        return Template{Name: name, Dot: dot}
}</span>

// Template renders the given template using jaws.With{Dot: dot} as data.
//
// The name argument is a string to be resolved to a *template.Template
// using Jaws.LookupTemplate().
func (rq RequestWriter) Template(name string, dot any, params ...any) error <span class="cov8" title="1">{
        return rq.UI(NewTemplate(name, dot), params...)
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package jaws

import (
        "io"
)

type UiA struct {
        UiHTMLInner
}

func (ui *UiA) JawsRender(e *Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        return ui.renderInner(e, w, "a", "", params)
}</span>

func NewUiA(innerHTML HTMLGetter) *UiA <span class="cov8" title="1">{
        return &amp;UiA{
                UiHTMLInner{
                        HTMLGetter: innerHTML,
                },
        }
}</span>

func (rq RequestWriter) A(innerHTML any, params ...any) error <span class="cov8" title="1">{
        return rq.UI(NewUiA(MakeHTMLGetter(innerHTML)), params...)
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package jaws

import (
        "io"
)

type UiButton struct {
        UiHTMLInner
}

func (ui *UiButton) JawsRender(e *Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        return ui.renderInner(e, w, "button", "button", params)
}</span>

func NewUiButton(innerHTML HTMLGetter) *UiButton <span class="cov8" title="1">{
        return &amp;UiButton{
                UiHTMLInner{
                        HTMLGetter: innerHTML,
                },
        }
}</span>

func (rq RequestWriter) Button(innerHTML any, params ...any) error <span class="cov8" title="1">{
        return rq.UI(NewUiButton(MakeHTMLGetter(innerHTML)), params...)
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package jaws

import (
        "io"
)

type UiCheckbox struct {
        UiInputBool
}

func (ui *UiCheckbox) JawsRender(e *Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        return ui.renderBoolInput(e, w, "checkbox", params...)
}</span>

func NewUiCheckbox(g Setter[bool]) *UiCheckbox <span class="cov8" title="1">{
        return &amp;UiCheckbox{
                UiInputBool{
                        Setter: g,
                },
        }
}</span>

func (rq RequestWriter) Checkbox(value any, params ...any) error <span class="cov8" title="1">{
        return rq.UI(NewUiCheckbox(makeSetter[bool](value)), params...)
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package jaws

import (
        "io"
)

type UiContainer struct {
        OuterHTMLTag string
        uiWrapContainer
}

func NewUiContainer(outerHTMLTag string, c Container) *UiContainer <span class="cov8" title="1">{
        return &amp;UiContainer{
                OuterHTMLTag: outerHTMLTag,
                uiWrapContainer: uiWrapContainer{
                        Container: c,
                },
        }
}</span>

func (ui *UiContainer) JawsRender(e *Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        return ui.renderContainer(e, w, ui.OuterHTMLTag, params)
}</span>

func (rq RequestWriter) Container(outerHTMLTag string, c Container, params ...any) error <span class="cov8" title="1">{
        return rq.UI(NewUiContainer(outerHTMLTag, c), params...)
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package jaws

import (
        "io"
        "time"
)

const ISO8601 = "2006-01-02"

type UiDate struct {
        UiInputDate
}

func (ui *UiDate) JawsRender(e *Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        return ui.renderDateInput(e, w, "date", params...)
}</span>

func NewUiDate(g Setter[time.Time]) *UiDate <span class="cov8" title="1">{
        return &amp;UiDate{
                UiInputDate{
                        Setter: g,
                },
        }
}</span>

func (rq RequestWriter) Date(value any, params ...any) error <span class="cov8" title="1">{
        return rq.UI(NewUiDate(makeSetter[time.Time](value)), params...)
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package jaws

import (
        "io"
)

type UiDiv struct {
        UiHTMLInner
}

func (ui *UiDiv) JawsRender(e *Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        return ui.renderInner(e, w, "div", "", params)
}</span>

func NewUiDiv(innerHTML HTMLGetter) *UiDiv <span class="cov8" title="1">{
        return &amp;UiDiv{
                UiHTMLInner{
                        HTMLGetter: innerHTML,
                },
        }
}</span>

func (rq RequestWriter) Div(innerHTML any, params ...any) error <span class="cov8" title="1">{
        return rq.UI(NewUiDiv(MakeHTMLGetter(innerHTML)), params...)
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package jaws

import (
        "io"
)

type UiHTMLInner struct {
        HTMLGetter
}

func (ui *UiHTMLInner) renderInner(e *Element, w io.Writer, htmltag, htmltype string, params []any) (err error) <span class="cov8" title="1">{
        if _, err = e.ApplyGetter(ui.HTMLGetter); err == nil </span><span class="cov8" title="1">{
                err = WriteHTMLInner(w, e.Jid(), htmltag, htmltype, ui.JawsGetHTML(e), e.ApplyParams(params)...)
        }</span>
        <span class="cov8" title="1">return</span>
}

func (ui *UiHTMLInner) JawsUpdate(e *Element) <span class="cov8" title="1">{
        e.SetInner(ui.JawsGetHTML(e))
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package jaws

import (
        "html/template"
        "io"
        "strconv"
)

type UiImg struct {
        Getter[string]
}

func (ui *UiImg) JawsRender(e *Element, w io.Writer, params []any) (err error) <span class="cov8" title="1">{
        if _, err = e.ApplyGetter(ui.Getter); err == nil </span><span class="cov8" title="1">{
                srcattr := template.HTMLAttr("src=" + strconv.Quote(ui.JawsGet(e))) // #nosec G203
                attrs := append(e.ApplyParams(params), srcattr)
                err = WriteHTMLInner(w, e.Jid(), "img", "", "", attrs...)
        }</span>
        <span class="cov8" title="1">return</span>
}

func (ui *UiImg) JawsUpdate(e *Element) <span class="cov8" title="1">{
        e.SetAttr("src", ui.JawsGet(e))
}</span>

func NewUiImg(g Getter[string]) *UiImg <span class="cov8" title="1">{
        return &amp;UiImg{
                Getter: g,
        }
}</span>

func (rq RequestWriter) Img(imageSrc any, params ...any) error <span class="cov8" title="1">{
        return rq.UI(NewUiImg(makeGetter[string](imageSrc)), params...)
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package jaws

import "sync/atomic"

type UiInput struct {
        Tag  any
        Last atomic.Value
}

func (ui *UiInput) applyGetter(e *Element, getter any) (err error) <span class="cov8" title="1">{
        ui.Tag, err = e.ApplyGetter(getter)
        return
}</span>

func (ui *UiInput) maybeDirty(val any, e *Element, err error) error <span class="cov8" title="1">{
        var changed bool
        if changed, err = e.maybeDirty(ui.Tag, err); changed </span><span class="cov8" title="1">{
                ui.Last.Store(val)
        }</span>
        <span class="cov8" title="1">return err</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package jaws

import (
        "io"
        "strconv"

        "github.com/linkdata/jaws/what"
)

type UiInputBool struct {
        UiInput
        Setter[bool]
}

func (ui *UiInputBool) renderBoolInput(e *Element, w io.Writer, htmltype string, params ...any) (err error) <span class="cov8" title="1">{
        if err = ui.applyGetter(e, ui.Setter); err == nil </span><span class="cov8" title="1">{
                attrs := e.ApplyParams(params)
                v := ui.JawsGet(e)
                ui.Last.Store(v)
                if v </span><span class="cov8" title="1">{
                        attrs = append(attrs, "checked")
                }</span>
                <span class="cov8" title="1">err = WriteHTMLInput(w, e.Jid(), htmltype, "", attrs)</span>
        }
        <span class="cov8" title="1">return</span>
}

func (ui *UiInputBool) JawsUpdate(e *Element) <span class="cov8" title="1">{
        v := ui.JawsGet(e)
        if ui.Last.Swap(v) != v </span><span class="cov8" title="1">{
                txt := "false"
                if v </span><span class="cov8" title="1">{
                        txt = "true"
                }</span>
                <span class="cov8" title="1">e.SetValue(txt)</span>
        }
}

func (ui *UiInputBool) JawsEvent(e *Element, wht what.What, val string) (err error) <span class="cov8" title="1">{
        err = ErrEventUnhandled
        if wht == what.Input </span><span class="cov8" title="1">{
                var v bool
                if val != "" </span><span class="cov8" title="1">{
                        if v, err = strconv.ParseBool(val); err != nil </span><span class="cov8" title="1">{
                                return
                        }</span>
                }
                <span class="cov8" title="1">err = ui.maybeDirty(v, e, ui.Setter.JawsSet(e, v))</span>
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package jaws

import (
        "io"
        "time"

        "github.com/linkdata/jaws/what"
)

type UiInputDate struct {
        UiInput
        Setter[time.Time]
}

func (ui *UiInputDate) str() string <span class="cov8" title="1">{
        return ui.Last.Load().(time.Time).Format(ISO8601)
}</span>

func (ui *UiInputDate) renderDateInput(e *Element, w io.Writer, htmltype string, params ...any) (err error) <span class="cov8" title="1">{
        if err = ui.applyGetter(e, ui.Setter); err == nil </span><span class="cov8" title="1">{
                attrs := e.ApplyParams(params)
                ui.Last.Store(ui.JawsGet(e))
                err = WriteHTMLInput(w, e.Jid(), htmltype, ui.str(), attrs)
        }</span>
        <span class="cov8" title="1">return</span>
}

func (ui *UiInputDate) JawsUpdate(e *Element) <span class="cov8" title="1">{
        if t := ui.JawsGet(e); ui.Last.Swap(t) != t </span><span class="cov8" title="1">{
                e.SetValue(ui.str())
        }</span>
}

func (ui *UiInputDate) JawsEvent(e *Element, wht what.What, val string) (err error) <span class="cov8" title="1">{
        err = ErrEventUnhandled
        if wht == what.Input </span><span class="cov8" title="1">{
                var v time.Time
                if val != "" </span><span class="cov8" title="1">{
                        if v, err = time.Parse(ISO8601, val); err != nil </span><span class="cov8" title="1">{
                                return
                        }</span>
                }
                <span class="cov8" title="1">err = ui.maybeDirty(v, e, ui.Setter.JawsSet(e, v))</span>
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package jaws

import (
        "io"
        "strconv"

        "github.com/linkdata/jaws/what"
)

type UiInputFloat struct {
        UiInput
        Setter[float64]
}

func (ui *UiInputFloat) str() string <span class="cov8" title="1">{
        return strconv.FormatFloat(ui.Last.Load().(float64), 'f', -1, 64)
}</span>

func (ui *UiInputFloat) renderFloatInput(e *Element, w io.Writer, htmltype string, params ...any) (err error) <span class="cov8" title="1">{
        if err = ui.applyGetter(e, ui.Setter); err == nil </span><span class="cov8" title="1">{
                attrs := e.ApplyParams(params)
                ui.Last.Store(ui.JawsGet(e))
                err = WriteHTMLInput(w, e.Jid(), htmltype, ui.str(), attrs)
        }</span>
        <span class="cov8" title="1">return</span>
}

func (ui *UiInputFloat) JawsUpdate(e *Element) <span class="cov8" title="1">{
        if f := ui.JawsGet(e); ui.Last.Swap(f) != f </span><span class="cov8" title="1">{
                e.SetValue(ui.str())
        }</span>
}

func (ui *UiInputFloat) JawsEvent(e *Element, wht what.What, val string) (err error) <span class="cov8" title="1">{
        err = ErrEventUnhandled
        if wht == what.Input </span><span class="cov8" title="1">{
                var v float64
                if val != "" </span><span class="cov8" title="1">{
                        if v, err = strconv.ParseFloat(val, 64); err != nil </span><span class="cov8" title="1">{
                                return
                        }</span>
                }
                <span class="cov8" title="1">err = ui.maybeDirty(v, e, ui.Setter.JawsSet(e, v))</span>
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package jaws

import (
        "io"

        "github.com/linkdata/jaws/what"
)

type UiInputText struct {
        UiInput
        Setter[string]
}

func (ui *UiInputText) renderStringInput(e *Element, w io.Writer, htmltype string, params ...any) (err error) <span class="cov8" title="1">{
        if err = ui.applyGetter(e, ui.Setter); err == nil </span><span class="cov8" title="1">{
                attrs := e.ApplyParams(params)
                v := ui.JawsGet(e)
                ui.Last.Store(v)
                err = WriteHTMLInput(w, e.Jid(), htmltype, v, attrs)
        }</span>
        <span class="cov8" title="1">return</span>
}

func (ui *UiInputText) JawsUpdate(e *Element) <span class="cov8" title="1">{
        if v := ui.JawsGet(e); ui.Last.Swap(v) != v </span><span class="cov8" title="1">{
                e.SetValue(v)
        }</span>
}

func (ui *UiInputText) JawsEvent(e *Element, wht what.What, val string) (err error) <span class="cov8" title="1">{
        err = ErrEventUnhandled
        if wht == what.Input </span><span class="cov8" title="1">{
                err = ui.maybeDirty(val, e, ui.Setter.JawsSet(e, val))
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package jaws

import (
        "io"
)

type UiLabel struct {
        UiHTMLInner
}

func (ui *UiLabel) JawsRender(e *Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        return ui.renderInner(e, w, "label", "", params)
}</span>

func NewUiLabel(innerHTML HTMLGetter) *UiLabel <span class="cov8" title="1">{
        return &amp;UiLabel{
                UiHTMLInner{
                        HTMLGetter: innerHTML,
                },
        }
}</span>

func (rq RequestWriter) Label(innerHTML any, params ...any) error <span class="cov8" title="1">{
        return rq.UI(NewUiLabel(MakeHTMLGetter(innerHTML)), params...)
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package jaws

import (
        "io"
)

type UiLi struct {
        UiHTMLInner
}

func (ui *UiLi) JawsRender(e *Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        return ui.renderInner(e, w, "li", "", params)
}</span>

func NewUiLi(innerHTML HTMLGetter) *UiLi <span class="cov8" title="1">{
        return &amp;UiLi{
                UiHTMLInner{
                        HTMLGetter: innerHTML,
                },
        }
}</span>

func (rq RequestWriter) Li(innerHTML any, params ...any) error <span class="cov8" title="1">{
        return rq.UI(NewUiLi(MakeHTMLGetter(innerHTML)), params...)
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package jaws

import (
        "io"
)

type UiNumber struct {
        UiInputFloat
}

func (ui *UiNumber) JawsRender(e *Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        return ui.renderFloatInput(e, w, "number", params...)
}</span>

func NewUiNumber(g Setter[float64]) *UiNumber <span class="cov8" title="1">{
        return &amp;UiNumber{
                UiInputFloat{
                        Setter: g,
                },
        }
}</span>

func (rq RequestWriter) Number(value any, params ...any) error <span class="cov8" title="1">{
        return rq.UI(NewUiNumber(makeSetterFloat64(value)), params...)
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">package jaws

import (
        "html"
        "html/template"
        "io"
)

type UiOption struct{ *NamedBool }

func (ui UiOption) JawsRender(e *Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        e.Tag(ui.NamedBool)
        attrs := e.ApplyParams(params)
        valattr := template.HTMLAttr(`value="` + html.EscapeString(ui.Name()) + `"`) // #nosec G203
        attrs = append(attrs, valattr)
        if ui.Checked() </span><span class="cov8" title="1">{
                attrs = append(attrs, "selected")
        }</span>
        <span class="cov8" title="1">return WriteHTMLInner(w, e.Jid(), "option", "", ui.JawsGetHTML(e), attrs...)</span>
}

func (ui UiOption) JawsUpdate(e *Element) <span class="cov8" title="1">{
        if ui.Checked() </span><span class="cov8" title="1">{
                e.SetAttr("selected", "")
        }</span> else<span class="cov8" title="1"> {
                e.RemoveAttr("selected")
        }</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package jaws

import (
        "io"
)

type UiPassword struct {
        UiInputText
}

func (ui *UiPassword) JawsRender(e *Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        return ui.renderStringInput(e, w, "password", params...)
}</span>

func NewUiPassword(g Setter[string]) *UiPassword <span class="cov8" title="1">{
        return &amp;UiPassword{
                UiInputText{
                        Setter: g,
                },
        }
}</span>

func (rq RequestWriter) Password(value any, params ...any) error <span class="cov8" title="1">{
        return rq.UI(NewUiPassword(makeSetter[string](value)), params...)
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">package jaws

import (
        "io"
)

type UiRadio struct {
        UiInputBool
}

func (ui *UiRadio) JawsRender(e *Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        return ui.renderBoolInput(e, w, "radio", params...)
}</span>

func NewUiRadio(vp Setter[bool]) *UiRadio <span class="cov8" title="1">{
        return &amp;UiRadio{
                UiInputBool{
                        Setter: vp,
                },
        }
}</span>

func (rq RequestWriter) Radio(value any, params ...any) error <span class="cov8" title="1">{
        return rq.UI(NewUiRadio(makeSetter[bool](value)), params...)
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package jaws

import (
        "html/template"
        "strings"
)

type RadioElement struct {
        radio    *Element
        label    *Element
        nameAttr string
}

func (rw RequestWriter) RadioGroup(nba *NamedBoolArray) (rel []RadioElement) <span class="cov8" title="1">{
        nameAttr := `name="` + MakeID() + `"`
        nba.ReadLocked(func(nbl []*NamedBool) </span><span class="cov8" title="1">{
                for _, nb := range nbl </span><span class="cov8" title="1">{
                        rel = append(rel, RadioElement{
                                radio:    rw.Request().NewElement(NewUiRadio(nb)),
                                label:    rw.Request().NewElement(NewUiLabel(nb)),
                                nameAttr: nameAttr,
                        },
                        )
                }</span>
        })
        <span class="cov8" title="1">return</span>
}

// Radio renders a HTML input element of type 'radio'.
func (re RadioElement) Radio(params ...any) template.HTML <span class="cov8" title="1">{
        var sb strings.Builder
        maybePanic(re.radio.JawsRender(&amp;sb, append(params, re.nameAttr)))
        return template.HTML(sb.String()) // #nosec G203
}</span>

// Label renders a HTML label element.
func (re RadioElement) Label(params ...any) template.HTML <span class="cov8" title="1">{
        var sb strings.Builder
        forAttr := string(re.radio.Jid().AppendQuote([]byte("for=")))
        maybePanic(re.label.JawsRender(&amp;sb, append(params, forAttr)))
        return template.HTML(sb.String()) // #nosec G203
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package jaws

import (
        "io"
)

type UiRange struct {
        UiInputFloat
}

func (ui *UiRange) JawsRender(e *Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        return ui.renderFloatInput(e, w, "range", params...)
}</span>

func NewUiRange(g Setter[float64]) *UiRange <span class="cov8" title="1">{
        return &amp;UiRange{
                UiInputFloat{
                        Setter: g,
                },
        }
}</span>

func (rq RequestWriter) Range(value any, params ...any) error <span class="cov8" title="1">{
        return rq.UI(NewUiRange(makeSetterFloat64(value)), params...)
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package jaws

import (
        "io"

        "github.com/linkdata/jaws/jid"
)

type UiRegister struct {
        Updater
}

func (ui UiRegister) JawsRender(e *Element, w io.Writer, params []any) (err error) <span class="cov8" title="1">{
        return
}</span>

// Register creates a new Element with the given Updater as a tag
// for dynamic updates. Additional tags may be provided in params.
// The updaters JawsUpdate method will be called immediately to
// ensure the initial rendering is correct.
//
// Returns a Jid, suitable for including as a HTML "id" attribute:
//
//        &lt;div id="{{$.Register .MyUpdater}}"&gt;...&lt;/div&gt;
func (rq RequestWriter) Register(updater Updater, params ...any) jid.Jid <span class="cov8" title="1">{
        elem := rq.rq.NewElement(UiRegister{Updater: updater})
        elem.Tag(updater)
        elem.ApplyParams(params)
        updater.JawsUpdate(elem)
        return elem.Jid()
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package jaws

import (
        "io"

        "github.com/linkdata/jaws/what"
)

type UiSelect struct {
        uiWrapContainer
}

func NewUiSelect(sh SelectHandler) *UiSelect <span class="cov8" title="1">{
        return &amp;UiSelect{
                uiWrapContainer: uiWrapContainer{
                        Container: sh,
                },
        }
}</span>

func (ui *UiSelect) JawsRender(e *Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        return ui.renderContainer(e, w, "select", params)
}</span>

func (ui *UiSelect) JawsUpdate(e *Element) <span class="cov8" title="1">{
        e.SetValue(ui.uiWrapContainer.Container.(Getter[string]).JawsGet(e))
        ui.uiWrapContainer.JawsUpdate(e)
}</span>

func (ui *UiSelect) JawsEvent(e *Element, wht what.What, val string) (err error) <span class="cov8" title="1">{
        err = ErrEventUnhandled
        if wht == what.Input </span><span class="cov8" title="1">{
                _, err = e.maybeDirty(ui.Tag, ui.uiWrapContainer.Container.(Setter[string]).JawsSet(e, val))
        }</span>
        <span class="cov8" title="1">return</span>
}

func (rq RequestWriter) Select(sh SelectHandler, params ...any) error <span class="cov8" title="1">{
        return rq.UI(NewUiSelect(sh), params...)
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package jaws

import (
        "io"
)

type UiSpan struct {
        UiHTMLInner
}

func (ui *UiSpan) JawsRender(e *Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        return ui.renderInner(e, w, "span", "", params)
}</span>

func NewUiSpan(innerHTML HTMLGetter) *UiSpan <span class="cov8" title="1">{
        return &amp;UiSpan{
                UiHTMLInner{
                        HTMLGetter: innerHTML,
                },
        }
}</span>

func (rq RequestWriter) Span(innerHTML any, params ...any) error <span class="cov8" title="1">{
        return rq.UI(NewUiSpan(MakeHTMLGetter(innerHTML)), params...)
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package jaws

import (
        "io"
)

type UiTbody struct {
        uiWrapContainer
}

func NewUiTbody(c Container) *UiTbody <span class="cov8" title="1">{
        return &amp;UiTbody{
                uiWrapContainer{
                        Container: c,
                },
        }
}</span>

func (ui *UiTbody) JawsRender(e *Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        return ui.renderContainer(e, w, "tbody", params)
}</span>

func (rq RequestWriter) Tbody(c Container, params ...any) error <span class="cov8" title="1">{
        return rq.UI(NewUiTbody(c), params...)
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package jaws

import (
        "io"
)

type UiTd struct {
        UiHTMLInner
}

func (ui *UiTd) JawsRender(e *Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        return ui.renderInner(e, w, "td", "", params)
}</span>

func NewUiTd(innerHTML HTMLGetter) *UiTd <span class="cov8" title="1">{
        return &amp;UiTd{
                UiHTMLInner{
                        HTMLGetter: innerHTML,
                },
        }
}</span>

func (rq RequestWriter) Td(innerHTML any, params ...any) error <span class="cov8" title="1">{
        return rq.UI(NewUiTd(MakeHTMLGetter(innerHTML)), params...)
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package jaws

import (
        "io"
)

type UiText struct {
        UiInputText
}

func (ui *UiText) JawsRender(e *Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        return ui.renderStringInput(e, w, "text", params...)
}</span>

func NewUiText(vp Setter[string]) (ui *UiText) <span class="cov8" title="1">{
        return &amp;UiText{
                UiInputText{
                        Setter: vp,
                },
        }
}</span>

func (rq RequestWriter) Text(value any, params ...any) error <span class="cov8" title="1">{
        return rq.UI(NewUiText(makeSetter[string](value)), params...)
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">package jaws

import (
        "html/template"
        "io"
)

type UiTextarea struct {
        UiInputText
}

func (ui *UiTextarea) JawsRender(e *Element, w io.Writer, params []any) (err error) <span class="cov8" title="1">{
        if err = ui.applyGetter(e, ui.Setter); err == nil </span><span class="cov8" title="1">{
                attrs := e.ApplyParams(params)
                err = WriteHTMLInner(w, e.Jid(), "textarea", "", template.HTML(ui.JawsGet(e)), attrs...) // #nosec G203
        }</span>
        <span class="cov8" title="1">return</span>
}

func (ui *UiTextarea) JawsUpdate(e *Element) <span class="cov8" title="1">{
        e.SetValue(ui.JawsGet(e))
}</span>

func NewUiTextarea(g Setter[string]) (ui *UiTextarea) <span class="cov8" title="1">{
        return &amp;UiTextarea{
                UiInputText{
                        Setter: g,
                },
        }
}</span>

func (rq RequestWriter) Textarea(value any, params ...any) error <span class="cov8" title="1">{
        return rq.UI(NewUiTextarea(makeSetter[string](value)), params...)
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">package jaws

import (
        "io"
)

type UiTr struct {
        UiHTMLInner
}

func (ui *UiTr) JawsRender(e *Element, w io.Writer, params []any) error <span class="cov8" title="1">{
        return ui.renderInner(e, w, "tr", "", params)
}</span>

func NewUiTr(innerHTML HTMLGetter) *UiTr <span class="cov8" title="1">{
        return &amp;UiTr{
                UiHTMLInner{
                        HTMLGetter: innerHTML,
                },
        }
}</span>

func (rq RequestWriter) Tr(innerHTML any, params ...any) error <span class="cov8" title="1">{
        return rq.UI(NewUiTr(MakeHTMLGetter(innerHTML)), params...)
}</span>
</pre>
		
		<pre class="file" id="file66" style="display: none">package jaws

import (
        "html/template"
        "io"
        "slices"
        "strings"

        "github.com/linkdata/deadlock"
)

type uiWrapContainer struct {
        Container
        Tag      any
        mu       deadlock.Mutex
        contents []*Element
}

func (ui *uiWrapContainer) renderContainer(e *Element, w io.Writer, outerhtmltag string, params []any) (err error) <span class="cov8" title="1">{
        if ui.Tag, err = e.ApplyGetter(ui.Container); err == nil </span><span class="cov8" title="1">{
                attrs := e.ApplyParams(params)
                b := e.Jid().AppendStartTagAttr(nil, outerhtmltag)
                for _, attr := range attrs </span><span class="cov8" title="1">{
                        b = append(b, ' ')
                        b = append(b, attr...)
                }</span>
                <span class="cov8" title="1">b = append(b, '&gt;')
                _, err = w.Write(b)
                if err == nil </span><span class="cov8" title="1">{
                        for _, cui := range ui.Container.JawsContains(e) </span><span class="cov8" title="1">{
                                if err == nil </span><span class="cov8" title="1">{
                                        elem := e.Request.NewElement(cui)
                                        ui.contents = append(ui.contents, elem)
                                        err = elem.JawsRender(w, nil)
                                }</span>
                        }
                        <span class="cov8" title="1">b = b[:0]
                        b = append(b, "&lt;/"...)
                        b = append(b, outerhtmltag...)
                        b = append(b, '&gt;')
                        if _, err2 := w.Write(b); err == nil </span><span class="cov8" title="1">{
                                err = err2
                        }</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

func (ui *uiWrapContainer) JawsUpdate(e *Element) <span class="cov8" title="1">{
        var toRemove, toAppend []*Element
        var orderData []Jid

        oldMap := make(map[UI]*Element)
        newMap := make(map[UI]struct{})
        newContents := ui.Container.JawsContains(e)
        for _, t := range newContents </span><span class="cov8" title="1">{
                newMap[t] = struct{}{}
        }</span>

        <span class="cov8" title="1">ui.mu.Lock()
        oldOrder := make([]Jid, len(ui.contents))
        for i, elem := range ui.contents </span><span class="cov8" title="1">{
                oldOrder[i] = elem.Jid()
                oldMap[elem.Ui()] = elem
                if _, ok := newMap[elem.Ui()]; !ok </span><span class="cov8" title="1">{
                        toRemove = append(toRemove, elem)
                }</span>
        }
        <span class="cov8" title="1">ui.contents = ui.contents[:0]
        for _, cui := range newContents </span><span class="cov8" title="1">{
                var elem *Element
                if elem = oldMap[cui]; elem == nil </span><span class="cov8" title="1">{
                        elem = e.Request.NewElement(cui)
                        toAppend = append(toAppend, elem)
                }</span>
                <span class="cov8" title="1">ui.contents = append(ui.contents, elem)
                orderData = append(orderData, elem.Jid())</span>
        }
        <span class="cov8" title="1">ui.mu.Unlock()

        for _, elem := range toRemove </span><span class="cov8" title="1">{
                e.Remove(elem.Jid().String())
                e.Request.deleteElement(elem)
        }</span>

        <span class="cov8" title="1">for _, elem := range toAppend </span><span class="cov8" title="1">{
                var sb strings.Builder
                maybePanic(elem.JawsRender(&amp;sb, nil))
                e.Append(template.HTML(sb.String())) // #nosec G203
        }</span>

        <span class="cov8" title="1">if !slices.Equal(oldOrder, orderData) </span><span class="cov8" title="1">{
                e.Order(orderData)
        }</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package jaws

import (
        "html/template"
        "io"
        "strconv"

        "github.com/linkdata/jaws/jid"
)

var singletonTags = map[string]struct{}{
        "area":    {},
        "base":    {},
        "br":      {},
        "col":     {},
        "command": {},
        "embed":   {},
        "hr":      {},
        "img":     {},
        "input":   {},
        "keygen":  {},
        "link":    {},
        "meta":    {},
        "param":   {},
        "source":  {},
        "track":   {},
        "wbr":     {},
}

func needClosingTag(tag string) bool <span class="cov8" title="1">{
        _, ok := singletonTags[tag]
        return !ok
}</span>

func appendAttrs(b []byte, attrs []template.HTMLAttr) []byte <span class="cov8" title="1">{
        for _, s := range attrs </span><span class="cov8" title="1">{
                if s != "" </span><span class="cov8" title="1">{
                        b = append(b, ' ')
                        b = append(b, s...)
                }</span>
        }
        <span class="cov8" title="1">return b</span>
}

func WriteHTMLTag(w io.Writer, jid jid.Jid, htmlTag, typeAttr, valueAttr string, attrs []template.HTMLAttr) (err error) <span class="cov8" title="1">{
        b := jid.AppendStartTagAttr(nil, htmlTag)
        if typeAttr != "" </span><span class="cov8" title="1">{
                b = append(b, ` type=`...)
                b = strconv.AppendQuote(b, typeAttr)
        }</span>
        <span class="cov8" title="1">if valueAttr != "" </span><span class="cov8" title="1">{
                b = append(b, ` value=`...)
                b = strconv.AppendQuote(b, valueAttr)
        }</span>
        <span class="cov8" title="1">b = appendAttrs(b, attrs)
        b = append(b, '&gt;')
        _, err = w.Write(b)
        return</span>
}

func WriteHTMLInput(w io.Writer, jid jid.Jid, typeAttr, valueAttr string, attrs []template.HTMLAttr) (err error) <span class="cov8" title="1">{
        return WriteHTMLTag(w, jid, "input", typeAttr, valueAttr, attrs)
}</span>

func WriteHTMLInner(w io.Writer, jid jid.Jid, htmlTag, typeAttr string, innerHTML template.HTML, attrs ...template.HTMLAttr) (err error) <span class="cov8" title="1">{
        if err = WriteHTMLTag(w, jid, htmlTag, typeAttr, "", attrs); err == nil </span><span class="cov8" title="1">{
                if innerHTML != "" || needClosingTag(htmlTag) </span><span class="cov8" title="1">{
                        var b []byte
                        b = append(b, innerHTML...)
                        b = append(b, "&lt;/"...)
                        b = append(b, htmlTag...)
                        b = append(b, '&gt;')
                        _, err = w.Write(b)
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func WriteHTMLSelect(w io.Writer, jid jid.Jid, nba *NamedBoolArray, attrs []template.HTMLAttr) (err error) <span class="cov8" title="1">{
        if err = WriteHTMLTag(w, jid, "select", "", "", attrs); err == nil </span><span class="cov8" title="1">{
                var b []byte
                nba.ReadLocked(func(nba []*NamedBool) </span><span class="cov8" title="1">{
                        for _, nb := range nba </span><span class="cov8" title="1">{
                                b = append(b, "\n&lt;option value="...)
                                b = strconv.AppendQuote(b, nb.Name())
                                if nb.Checked() </span><span class="cov8" title="1">{
                                        b = append(b, ` selected`...)
                                }</span>
                                <span class="cov8" title="1">b = append(b, '&gt;')
                                b = append(b, nb.HTML()...)
                                b = append(b, "&lt;/option&gt;"...)</span>
                        }
                })
                <span class="cov8" title="1">b = append(b, "\n&lt;/select&gt;"...)
                _, err = w.Write(b)</span>
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package jaws

import (
        "context"
        "errors"
        "io"
        "net/http"
        "net/url"
        "strings"

        "github.com/coder/websocket"
)

func (rq *Request) startServe() (ok bool) <span class="cov8" title="1">{
        return rq.claimed.Load() &amp;&amp; rq.running.CompareAndSwap(false, true)
}</span>

func (rq *Request) stopServe() <span class="cov8" title="1">{
        rq.cancel(nil)
        rq.Jaws.recycle(rq)
}</span>

// ServeHTTP implements http.HanderFunc.
//
// Requires UseRequest() have been successfully called for the Request.
func (rq *Request) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if rq.startServe() </span><span class="cov8" title="1">{
                defer rq.stopServe()
                if strings.HasSuffix(r.RequestURI, "/noscript") </span><span class="cov8" title="1">{
                        w.WriteHeader(http.StatusNoContent)
                        rq.cancel(nil)
                        return
                }</span>
                <span class="cov8" title="1">var err error
                if r.Header.Get("Sec-WebSocket-Key") != "" </span><span class="cov8" title="1">{
                        if err = rq.validateWebSocketOrigin(r); err != nil </span><span class="cov8" title="1">{
                                http.Error(w, http.StatusText(http.StatusForbidden), http.StatusForbidden)
                                rq.cancel(err)
                                return
                        }</span>
                }
                <span class="cov8" title="1">var ws *websocket.Conn
                ws, err = websocket.Accept(w, r, nil)
                if err == nil </span><span class="cov8" title="1">{
                        if err = rq.onConnect(); err == nil </span><span class="cov8" title="1">{
                                incomingMsgCh := make(chan wsMsg)
                                broadcastMsgCh := rq.Jaws.subscribe(rq, 4+len(rq.elems)*4)
                                outboundMsgCh := make(chan wsMsg, cap(broadcastMsgCh))
                                go wsReader(rq.ctx, rq.cancelFn, rq.Jaws.Done(), incomingMsgCh, ws) // closes incomingMsgCh
                                go wsWriter(rq.ctx, rq.cancelFn, rq.Jaws.Done(), outboundMsgCh, ws) // calls ws.Close()
                                rq.process(broadcastMsgCh, incomingMsgCh, outboundMsgCh)            // unsubscribes broadcastMsgCh, closes outboundMsgCh
                        }</span> else<span class="cov8" title="1"> {
                                defer ws.Close(websocket.StatusNormalClosure, err.Error())
                                var msg wsMsg
                                msg.FillAlert(rq.Jaws.Log(err))
                                _ = ws.Write(r.Context(), websocket.MessageText, msg.Append(nil))
                        }</span>
                }
                <span class="cov8" title="1">rq.cancel(err)</span>
        }
}

var (
        ErrWebsocketOriginMissing     = errors.New("websocket request missing Origin header")
        ErrWebsocketOriginWrongScheme = errors.New("websocket Origin not http or https")
        ErrWebsocketOriginWrongHost   = errors.New("websocket Origin not http or https")
)

func (rq *Request) validateWebSocketOrigin(r *http.Request) (err error) <span class="cov8" title="1">{
        err = ErrWebsocketOriginMissing
        if origin := r.Header.Get("Origin"); origin != "" </span><span class="cov8" title="1">{
                var u *url.URL
                if u, err = url.Parse(origin); err == nil </span><span class="cov8" title="1">{
                        err = ErrWebsocketOriginWrongScheme
                        switch u.Scheme </span>{
                        case "http", "https":<span class="cov8" title="1">
                                err = ErrWebsocketOriginWrongHost
                                if u.Host != "" </span><span class="cov8" title="1">{
                                        if initial := rq.Initial(); initial != nil </span><span class="cov8" title="1">{
                                                if strings.EqualFold(u.Host, initial.Host) </span><span class="cov8" title="1">{
                                                        err = nil
                                                }</span>
                                        }
                                }
                        }
                }
        }
        <span class="cov8" title="1">return</span>
}

// wsReader reads websocket text messages, parses them and sends them on incomingMsgCh.
//
// Closes incomingMsgCh on exit.
func wsReader(ctx context.Context, ccf context.CancelCauseFunc, jawsDoneCh &lt;-chan struct{}, incomingMsgCh chan&lt;- wsMsg, ws *websocket.Conn) <span class="cov8" title="1">{
        var typ websocket.MessageType
        var txt []byte
        var err error
        defer close(incomingMsgCh)
        for err == nil </span><span class="cov8" title="1">{
                if typ, txt, err = ws.Read(ctx); typ == websocket.MessageText </span><span class="cov8" title="1">{
                        if msg, ok := wsParse(txt); ok </span><span class="cov8" title="1">{
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov8" title="1">
                                        return</span>
                                case &lt;-jawsDoneCh:<span class="cov8" title="1">
                                        return</span>
                                case incomingMsgCh &lt;- msg:<span class="cov8" title="1"></span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">if ccf != nil </span><span class="cov8" title="1">{
                ccf(err)
        }</span>
}

// wsWriter reads JaWS messages from outboundMsgCh, formats them and writes them to the websocket.
//
// Closes the websocket on exit.
func wsWriter(ctx context.Context, ccf context.CancelCauseFunc, jawsDoneCh &lt;-chan struct{}, outboundMsgCh &lt;-chan wsMsg, ws *websocket.Conn) <span class="cov8" title="1">{
        defer ws.Close(websocket.StatusNormalClosure, "")
        var err error
        for err == nil </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-jawsDoneCh:<span class="cov8" title="1">
                        return</span>
                case msg, ok := &lt;-outboundMsgCh:<span class="cov8" title="1">
                        if !ok </span><span class="cov8" title="1">{
                                return
                        }</span>
                        <span class="cov8" title="1">var wc io.WriteCloser
                        if wc, err = ws.Writer(ctx, websocket.MessageText); err == nil </span><span class="cov8" title="1">{
                                err = wsWriteData(wc, msg, outboundMsgCh)
                        }</span>
                }
        }
        <span class="cov8" title="1">if ccf != nil </span><span class="cov8" title="1">{
                ccf(err)
        }</span>
}

func wsWriteData(wc io.WriteCloser, firstMsg wsMsg, outboundMsgCh &lt;-chan wsMsg) (err error) <span class="cov8" title="1">{
        b := firstMsg.Append(nil)
        // accumulate data to send as long as more messages
        // are available until it exceeds 32K
batchloop:
        for len(b) &lt; 32*1024 </span><span class="cov8" title="1">{
                select </span>{
                case msg := &lt;-outboundMsgCh:<span class="cov8" title="1">
                        b = msg.Append(b)</span>
                default:<span class="cov8" title="1">
                        break batchloop</span>
                }
        }
        <span class="cov8" title="1">_, err = wc.Write(b)
        err = errors.Join(err, wc.Close())
        return</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package jaws

import (
        "bytes"
        "html"
        "strconv"
        "strings"

        "github.com/linkdata/jaws/jid"
        "github.com/linkdata/jaws/what"
)

// wsMsg is a message sent to or from a WebSocket.
type wsMsg struct {
        Data string    // data to send
        Jid  Jid       // Jid to send, or -1 if Data contains that already
        What what.What // command
}

func (m *wsMsg) Append(b []byte) []byte <span class="cov8" title="1">{
        b = append(b, m.What.String()...)
        b = append(b, '\t')
        if m.Jid &gt;= 0 </span><span class="cov8" title="1">{
                if m.Jid &gt; 0 </span><span class="cov8" title="1">{
                        b = m.Jid.Append(b)
                }</span>
                <span class="cov8" title="1">b = append(b, '\t')
                switch m.What </span>{
                case what.Set, what.Call:<span class="cov8" title="1">
                        b = append(b, m.Data...)</span>
                default:<span class="cov8" title="1">
                        b = strconv.AppendQuote(b, m.Data)</span>
                }
        } else<span class="cov8" title="1"> {
                b = append(b, m.Data...)
        }</span>
        <span class="cov8" title="1">b = append(b, '\n')
        return b</span>
}

func (m *wsMsg) Format() string <span class="cov8" title="1">{
        return string(m.Append(nil))
}</span>

// wsParse parses an incoming text buffer into a message.
func wsParse(txt []byte) (wsMsg, bool) <span class="cov8" title="1">{
        if len(txt) &gt; 2 &amp;&amp; txt[len(txt)-1] == '\n' </span><span class="cov8" title="1">{
                if nl1 := bytes.IndexByte(txt, '\t'); nl1 &gt;= 0 </span><span class="cov8" title="1">{
                        if nl2 := bytes.IndexByte(txt[nl1+1:], '\t'); nl2 &gt;= 0 </span><span class="cov8" title="1">{
                                nl2 += nl1 + 1
                                // What       ... Jid              ... Data                  ... EOL
                                // txt[0:nl1] ... txt[nl1+1 : nl2] ... txt[nl2+1:len(txt)-1] ... \n
                                if wht := what.Parse(string(txt[0:nl1])); wht.IsValid() </span><span class="cov8" title="1">{
                                        if id := jid.ParseString(string(txt[nl1+1 : nl2])); id.IsValid() </span><span class="cov8" title="1">{
                                                data := string(txt[nl2+1 : len(txt)-1])
                                                if wht != what.Set &amp;&amp; txt[nl2+1] == '"' </span><span class="cov8" title="1">{
                                                        var err error
                                                        if data, err = strconv.Unquote(data); err != nil </span><span class="cov8" title="1">{
                                                                return wsMsg{}, false
                                                        }</span>
                                                }
                                                <span class="cov8" title="1">return wsMsg{
                                                        Data: strings.ToValidUTF8(data, ""),
                                                        Jid:  id,
                                                        What: wht,
                                                }, true</span>
                                        }
                                }
                        }
                }
        }
        <span class="cov8" title="1">return wsMsg{}, false</span>
}

func (m *wsMsg) FillAlert(err error) <span class="cov8" title="1">{
        m.Jid = 0
        m.What = what.Alert
        m.Data = "danger\n" + html.EscapeString(err.Error())
}</span>
</pre>
		
		<pre class="file" id="file70" style="display: none">package jawsboot

import (
        "embed"
        "errors"
        "net/http"
        "net/url"
        "path"

        "github.com/linkdata/jaws"
        "github.com/linkdata/jaws/staticserve"
)

//go:embed assets
var assetsFS embed.FS

func Setup(jw *jaws.Jaws, handleFn jaws.HandleFunc, prefix string) (urls []*url.URL, err error) <span class="cov8" title="1">{
        var files []*staticserve.StaticServe
        if err = staticserve.WalkDir(assetsFS, "assets/static", func(filename string, ss *staticserve.StaticServe) (err error) </span><span class="cov8" title="1">{
                files = append(files, ss)
                return
        }</span>); err == nil <span class="cov8" title="1">{
                for _, ss := range files </span><span class="cov8" title="1">{
                        u, e := url.Parse(path.Join(prefix, ss.Name))
                        if e == nil </span><span class="cov8" title="1">{
                                urls = append(urls, u)
                                handleFn(u.String(), ss)
                        }</span>
                        <span class="cov8" title="1">err = errors.Join(err, e)</span>
                }
                <span class="cov8" title="1">handleFn(path.Join(prefix, "bootstrap.bundle.min.js.map"), http.NotFoundHandler())
                handleFn(path.Join(prefix, "bootstrap.min.css.map"), http.NotFoundHandler())</span>
        }
        <span class="cov8" title="1">return</span>
}

/*
// GenerateHeadHTML calls jw.GenerateHeadHTML with URL's for the staticserve files
// prefixed with the given path prefix and any extra URL's you provide.
func GenerateHeadHTML(jw *jaws.Jaws, prefix string, files []*staticserve.StaticServe, extra ...string) (err error) {
        var extraFiles []string
        for _, ss := range files {
                extraFiles = append(extraFiles, path.Join(prefix, ss.Name))
        }
        extraFiles = append(extraFiles, extra...)
        return jw.GenerateHeadHTML(extraFiles...)
}


// SetupUsing sets up Jaws to serve the Bootstrap files from the prefix path,
// calling handleFn for each URI and staticserve.StaticServe.
// If handleFn is nil, http.DefaultServeMux.Handle is used instead.
// Any extra URL's given are passed to GenerateHeadHTML.
func SetupUsing(jw *jaws.Jaws, prefix string, handleFn HandleFunc, extra ...string) (err error) {
        var files []*staticserve.StaticServe
        if handleFn == nil {
                handleFn = http.DefaultServeMux.Handle
        }
        if files, err = Files(); err == nil {
                if err = GenerateHeadHTML(jw, prefix, files, extra...); err == nil {
                        for _, ss := range files {
                                handleFn(path.Join(prefix, ss.Name), ss)
                        }
                        handleFn(path.Join(prefix, "bootstrap.bundle.min.js.map"), http.NotFoundHandler())
                        handleFn(path.Join(prefix, "bootstrap.min.css.map"), http.NotFoundHandler())
                }
        }
        return
}

// Setup calls SetupUsing with a prefix of "/static".
func Setup(jw *jaws.Jaws, handleFn HandleFunc, extra ...string) (err error) {
        return SetupUsing(jw, "/static", handleFn, extra...)
}
*/
</pre>
		
		<pre class="file" id="file71" style="display: none">package jawstree

import (
        "fmt"
        "slices"
        "strconv"
        "strings"

        "github.com/linkdata/jaws"
)

var _ jaws.SetPather = (*Node)(nil)

type Node struct {
        Tree     *Tree   `json:"-"`
        Parent   *Node   `json:"-"`
        ID       string  `json:"id,omitzero"`
        Name     string  `json:"name"`
        Selected bool    `json:"selected,omitzero"`
        Children []*Node `json:"children,omitzero"`
}

func (n *Node) JawsPathSet(elem *jaws.Element, jspath string, value any) <span class="cov8" title="1">{
        if jspath, ok := strings.CutSuffix(jspath, ".selected"); ok </span><span class="cov8" title="1">{
                elem.Jaws.JsCall(n.Tree.Tag, "jawstreeSetPath", fmt.Sprintf(`{"tree":%q,"id":%q,"set":%v}`, n.Tree.id, jspath, value))
        }</span>
}

func (n *Node) Walk(jspath string, fn func(jspath string, node *Node)) <span class="cov8" title="1">{
        fn(jspath, n)
        if jspath != "" </span><span class="cov8" title="1">{
                jspath += "."
        }</span>
        <span class="cov8" title="1">for i, child := range n.Children </span><span class="cov8" title="1">{
                child.Walk(jspath+"children."+strconv.Itoa(i), fn)
        }</span>
}

func (n *Node) HasNames(names []string) (yes bool) <span class="cov8" title="1">{
        if yes = (n.Parent == nil) &amp;&amp; (len(names) == 0); !yes &amp;&amp; n.Parent != nil </span><span class="cov8" title="1">{
                if len(names) &gt; 0 </span><span class="cov8" title="1">{
                        yes = n.Parent.HasNames(names[:len(names)-1])
                        yes = yes &amp;&amp; n.Name == names[len(names)-1]
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func (n *Node) GetNames() (names []string) <span class="cov8" title="1">{
        for n.Parent != nil </span><span class="cov8" title="1">{
                names = append(names, n.Name)
                n = n.Parent
        }</span>
        <span class="cov8" title="1">slices.Reverse(names)
        return</span>
}

func (n *Node) GetSelected() (nameslist [][]string) <span class="cov8" title="1">{
        n.Walk("", func(jspath string, node *Node) </span><span class="cov8" title="1">{
                if node.Selected </span><span class="cov8" title="1">{
                        nameslist = append(nameslist, node.GetNames())
                }</span>
        })
        <span class="cov8" title="1">return</span>
}

func (n *Node) SetSelected(nameslist [][]string) (changed []*Node) <span class="cov8" title="1">{
        n.Walk("", func(jspath string, node *Node) </span><span class="cov8" title="1">{
                for _, names := range nameslist </span><span class="cov8" title="1">{
                        if selected := node.HasNames(names); selected != node.Selected </span><span class="cov8" title="1">{
                                node.Selected = selected
                                changed = append(changed, node)
                        }</span>
                }
        })
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package jawstree

import (
        "errors"
        "io/fs"
        "os"
        "path"
)

func Root(r *os.Root) (rootnode *Node, err error) <span class="cov8" title="1">{
        rootnode = &amp;Node{}
        err = getNodes(r.FS(), rootnode, ".")
        return
}</span>

func getNodes(rootfs fs.FS, parent *Node, dirpath string) (err error) <span class="cov8" title="1">{
        var ents []fs.DirEntry
        if ents, err = fs.ReadDir(rootfs, dirpath); err == nil </span><span class="cov8" title="1">{
                for _, ent := range ents </span><span class="cov8" title="1">{
                        id := path.Join(parent.ID, ent.Name())
                        child := &amp;Node{Tree: parent.Tree, Parent: parent, ID: id, Name: ent.Name()}
                        if ent.Type().IsRegular() </span><span class="cov8" title="1">{
                                parent.Children = append(parent.Children, child)
                        }</span> else<span class="cov8" title="1"> if ent.IsDir() </span><span class="cov8" title="1">{
                                if err = errors.Join(err, getNodes(rootfs, child, path.Join(dirpath, child.Name))); err == nil </span><span class="cov8" title="1">{
                                        parent.Children = append(parent.Children, child)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package jawstree

import (
        "embed"
        "errors"
        "net/http"
        "net/url"
        "path"

        "github.com/linkdata/jaws"
        "github.com/linkdata/jaws/staticserve"
)

//go:embed assets
var assetsFS embed.FS

// treeview from https://github.com/stefaneichert/quercus.js

func Setup(jw *jaws.Jaws, handleFn jaws.HandleFunc, prefix string) (urls []*url.URL, err error) <span class="cov8" title="1">{
        var files []*staticserve.StaticServe
        if err = staticserve.WalkDir(assetsFS, "assets", func(filename string, ss *staticserve.StaticServe) (err error) </span><span class="cov8" title="1">{
                files = append(files, ss)
                return
        }</span>); err == nil <span class="cov8" title="1">{
                for _, ss := range files </span><span class="cov8" title="1">{
                        u, e := url.Parse(path.Join(prefix, ss.Name))
                        if e == nil </span><span class="cov8" title="1">{
                                urls = append(urls, u)
                                handleFn(u.String(), ss)
                        }</span>
                        <span class="cov8" title="1">err = errors.Join(err, e)</span>
                }
                <span class="cov8" title="1">handleFn(path.Join(prefix, "treeview.js.map"), http.NotFoundHandler())</span>
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package jawstree

import (
        "fmt"
        "io"

        "github.com/linkdata/jaws"
)

var _ jaws.UI = (*Tree)(nil)

type Tree struct {
        id string // HTML ID of the tree
        *jaws.JsVar[Node]
}

func New(id string, jsvar *jaws.JsVar[Node]) (t *Tree) <span class="cov8" title="1">{
        t = &amp;Tree{
                id:    id,
                JsVar: jsvar,
        }
        jsvar.Ptr.Walk("", func(jspath string, n *Node) </span><span class="cov8" title="1">{ n.ID = jspath; n.Tree = t }</span>)
        <span class="cov8" title="1">return</span>
}

const newtreeTemplate = `
&lt;script&gt;var jawstreeroot_%s; document.addEventListener("DOMContentLoaded",function(){window.jawstree_%s=jawstreeNew("%s",jawstreeroot_%s);});&lt;/script&gt;`

func (t *Tree) JawsRender(e *jaws.Element, w io.Writer, params []any) (err error) <span class="cov8" title="1">{
        if err = t.JsVar.JawsRender(e, w, []any{"jawstreeroot_" + t.id}); err == nil </span><span class="cov8" title="1">{
                if _, err = fmt.Fprintf(w, newtreeTemplate, t.id, t.id, t.id, t.id); err == nil </span>{<span class="cov8" title="1">
                }</span>
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package jid

import (
        "strconv"
        "strings"
)

// Jid is the basis for the HTML `id` attribute for an UI Element within an active Request.
// It is per-Request, meaning Jid(1) in one Request is not the same as Jid(1) in another.
type Jid int64

const Prefix = "Jid." // String prefixing HTML ID's based on Jid's.
const Invalid = Jid(-1)

func (jid Jid) IsValid() bool <span class="cov8" title="1">{
        return jid &gt;= 0
}</span>

// AppendInt appends just the text format of the Jid's numerical value.
func (jid Jid) AppendInt(dst []byte) []byte <span class="cov8" title="1">{
        if jid &gt; 0 </span><span class="cov8" title="1">{
                dst = strconv.AppendInt(dst, int64(jid), 10)
        }</span>
        <span class="cov8" title="1">return dst</span>
}

// Append appends the unquoted string format of the Jid.
func (jid Jid) Append(dst []byte) []byte <span class="cov8" title="1">{
        if jid &gt; 0 </span><span class="cov8" title="1">{
                dst = append(dst, []byte(Prefix)...)
                dst = jid.AppendInt(dst)
        }</span>
        <span class="cov8" title="1">return dst</span>
}

// AppendQuote appends the string format of the Jid surrounded by double quotes.
func (jid Jid) AppendQuote(dst []byte) []byte <span class="cov8" title="1">{
        dst = append(dst, '"')
        dst = jid.Append(dst)
        dst = append(dst, '"')
        return dst
}</span>

// AppendAttr appends `&lt;startTag` followed by the quoted Jid as a HTML id attribute.
func (jid Jid) AppendStartTagAttr(dst []byte, startTag string) []byte <span class="cov8" title="1">{
        dst = append(dst, '&lt;')
        dst = append(dst, startTag...)
        if jid &gt; 0 </span><span class="cov8" title="1">{
                dst = append(dst, ` id=`...)
                dst = jid.AppendQuote(dst)
        }</span>
        <span class="cov8" title="1">return dst</span>
}

// ParseInt parses a Jid integer and returns it as a Jid.
//
// Returns jid.Invalid if it's not a valid Jid or an error occurs.
func ParseInt(s string) Jid <span class="cov8" title="1">{
        if n, err := strconv.ParseInt(s, 10, 32); err == nil &amp;&amp; n &gt;= 0 </span><span class="cov8" title="1">{
                return Jid(n)
        }</span>
        <span class="cov8" title="1">return Invalid</span>
}

// ParseString parses an unquoted Jid string (e.g. `Jid.2`) and returns the Jid value (e.g. Jid(2)).
//
// Returns jid.Invalid if it's not a valid Jid string.
func ParseString(s string) Jid <span class="cov8" title="1">{
        if s == "" </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">if strings.HasPrefix(s, Prefix) </span><span class="cov8" title="1">{
                return ParseInt(s[len(Prefix):])
        }</span>
        <span class="cov8" title="1">return Invalid</span>
}

// String returns the unquoted string representation of the Jid.
func (jid Jid) String() string <span class="cov8" title="1">{
        if jid &gt; 0 </span><span class="cov8" title="1">{
                return string(jid.Append(nil))
        }</span>
        <span class="cov8" title="1">return ""</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">package staticserve

import (
        "errors"
        "io"
        "io/fs"
        "net/http"
        "path"
        "strings"
)

// HandleFunc matches the signature of http.ServeMux.Handle(), but is called without
// method or parameters for the pattern. E.g. ("/static/filename.1234567.js").
type HandleFunc = func(uri string, handler http.Handler)

func ensurePrefixSlash(s string) string <span class="cov8" title="1">{
        if !strings.HasPrefix(s, "/") </span><span class="cov8" title="1">{
                s = "/" + s
        }</span>
        <span class="cov8" title="1">return s</span>
}

// Handle creates a new StaticServe for the fpath that returns the data given.
// Returns the URI of the resource.
func Handle(fpath string, data []byte, handleFn HandleFunc) (uri string, err error) <span class="cov8" title="1">{
        var ss *StaticServe
        if ss, err = New(fpath, data); err == nil </span><span class="cov8" title="1">{
                uri = ensurePrefixSlash(ss.Name)
                handleFn(uri, ss)
        }</span>
        <span class="cov8" title="1">return</span>
}

// HandleFS creates StaticServe handlers for the filepaths given.
// Returns the URI(s) of the resources. If an error occurs, the URI
// of the failed resource will be the empty string.
func HandleFS(fsys fs.FS, handleFn HandleFunc, root string, filepaths ...string) (uris []string, err error) <span class="cov8" title="1">{
        for _, filepath := range filepaths </span><span class="cov8" title="1">{
                var uri string
                f, ferr := fsys.Open(path.Join(root, filepath))
                if ferr == nil </span><span class="cov8" title="1">{
                        var b []byte
                        if b, ferr = io.ReadAll(f); ferr == nil </span><span class="cov8" title="1">{
                                uri, ferr = Handle(filepath, b, handleFn)
                        }</span>
                        <span class="cov8" title="1">ferr = errors.Join(ferr, f.Close())</span>
                }
                <span class="cov8" title="1">uris = append(uris, uri)
                err = errors.Join(err, ferr)</span>
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package staticserve

import (
        "io"
        "io/fs"
        "path"
)

// NewFS reads the file at fpath from fsys and then calls New.
func NewFS(fsys fs.FS, root, fpath string) (ss *StaticServe, err error) <span class="cov8" title="1">{
        var f fs.File
        if f, err = fsys.Open(path.Join(root, fpath)); err == nil </span><span class="cov8" title="1">{
                defer f.Close()
                var b []byte
                if b, err = io.ReadAll(f); err == nil </span><span class="cov8" title="1">{
                        ss, err = New(fpath, b)
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func MustNewFS(fsys fs.FS, root string, fpaths ...string) (ssl []*StaticServe) <span class="cov8" title="1">{
        for _, fpath := range fpaths </span><span class="cov8" title="1">{
                ss, err := NewFS(fsys, root, fpath)
                MaybePanic(err)
                ssl = append(ssl, ss)
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package staticserve

import (
        "bytes"
        "compress/gzip"
        "io"
        "net/http"
        "strconv"
        "strings"
)

var HeaderCacheControl = []string{"public, max-age=31536000, s-maxage=31536000, immutable"}
var HeaderVary = []string{"Accept-Encoding"}
var headerContentEncoding = []string{"gzip"}

func acceptsGzip(hdr http.Header) bool <span class="cov8" title="1">{
        for _, s := range hdr["Accept-Encoding"] </span><span class="cov8" title="1">{
                if strings.Contains(s, "gzip") </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (ss *StaticServe) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var body io.Reader
        statusCode := http.StatusMethodNotAllowed
        if r.Method == http.MethodGet </span><span class="cov8" title="1">{
                hdr := w.Header()
                if acceptsGzip(r.Header) </span><span class="cov8" title="1">{
                        body = bytes.NewReader(ss.Gz)
                        hdr["Content-Encoding"] = headerContentEncoding
                        hdr["Content-Length"] = []string{strconv.Itoa(len(ss.Gz))}
                }</span> else<span class="cov8" title="1"> {
                        statusCode = http.StatusInternalServerError
                        if gzr, err := gzip.NewReader(bytes.NewReader(ss.Gz)); err == nil </span><span class="cov8" title="1">{
                                defer gzr.Close()
                                body = gzr
                        }</span>
                }
                <span class="cov8" title="1">if body != nil </span><span class="cov8" title="1">{
                        statusCode = http.StatusOK
                        hdr["Cache-Control"] = HeaderCacheControl
                        hdr["Vary"] = HeaderVary
                        if ss.ContentType != "" </span><span class="cov8" title="1">{
                                hdr["Content-Type"] = []string{ss.ContentType}
                        }</span>
                }
        }
        <span class="cov8" title="1">w.WriteHeader(statusCode)
        if body != nil </span><span class="cov8" title="1">{
                _, _ = io.Copy(w, body)
        }</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package staticserve

import (
        "bytes"
        "compress/gzip"
        "hash/fnv"
        "mime"
        "path/filepath"
        "strconv"
        "strings"
)

type StaticServe struct {
        Name        string // the cache-busting file name, e.g. "static/filename.1234567.js"
        ContentType string // Content-Type of the file, e.g. "application/javascript"
        Gz          []byte // gzipped data, will be unpacked as needed
}

// New returns a StaticServe that serves the given data with a filename like 'filename.12345678.ext'.
// The filename must have the suffix ".gz" if the data is GZip compressed. The ".gz" suffix will
// not be part of the filename presented in this case.
func New(filename string, data []byte) (ss *StaticServe, err error) <span class="cov8" title="1">{
        var gz []byte
        if strings.HasSuffix(filename, ".gz") </span><span class="cov8" title="1">{
                gz = data
                filename = strings.TrimSuffix(filename, ".gz")
        }</span> else<span class="cov8" title="1"> {
                var buf bytes.Buffer
                gzw := gzip.NewWriter(&amp;buf)
                defer gzw.Close()
                if _, err = gzw.Write(data); err == nil </span><span class="cov8" title="1">{
                        if err = gzw.Flush(); err == nil </span><span class="cov8" title="1">{
                                gz = buf.Bytes()
                        }</span>
                }
        }

        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                ext := filepath.Ext(filename)
                filename = strings.TrimSuffix(filename, ext)
                h := fnv.New64a()
                if _, err = h.Write(gz); err == nil </span><span class="cov8" title="1">{
                        ss = &amp;StaticServe{
                                Name:        filename + "." + strconv.FormatUint(h.Sum64(), 36) + ext,
                                ContentType: mime.TypeByExtension(ext),
                                Gz:          gz,
                        }
                }</span>
        }

        <span class="cov8" title="1">return</span>
}

func MaybePanic(err error) <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                panic(err)</span>
        }
}

// Must calls New and panics on error.
func Must(filename string, data []byte) (ss *StaticServe) <span class="cov8" title="1">{
        var err error
        ss, err = New(filename, data)
        MaybePanic(err)
        return
}</span>
</pre>
		
		<pre class="file" id="file80" style="display: none">package staticserve

import (
        "io"
        "io/fs"
        "strings"
)

// WalkDir walks the file tree rooted at root, calling fn for each file in the tree with
// the filename having root trimmed (e.g. "root/dir/file.ext" becomes "dir/file.ext").
func WalkDir(fsys fs.FS, root string, fn func(filename string, ss *StaticServe) (err error)) (err error) <span class="cov8" title="1">{
        err = fs.WalkDir(fsys, root, func(filename string, d fs.DirEntry, err error) error </span><span class="cov8" title="1">{
                if err == nil &amp;&amp; !d.IsDir() </span><span class="cov8" title="1">{
                        var f fs.File
                        if f, err = fsys.Open(filename); err == nil </span><span class="cov8" title="1">{
                                defer f.Close()
                                var b []byte
                                if b, err = io.ReadAll(f); err == nil </span><span class="cov8" title="1">{
                                        var ss *StaticServe
                                        filename = strings.TrimPrefix(strings.TrimPrefix(filename, root), "/")
                                        if ss, err = New(filename, b); err == nil </span><span class="cov8" title="1">{
                                                err = fn(filename, ss)
                                        }</span>
                                }
                        }
                }
                <span class="cov8" title="1">return err</span>
        })
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package templatereloader

import (
        "html/template"
        "io/fs"
        "path"
        "time"

        "github.com/linkdata/deadlock"
        "github.com/linkdata/jaws"
)

// A TemplateReloader reloads and reparses templates if more than one second
// has passed since the last Lookup.
type TemplateReloader struct {
        Path string // the file path we are loading from
        mu   deadlock.RWMutex
        when time.Time
        curr *template.Template
}

// New returns a jaws.TemplateLookuper.
//
// If deadlock.Debug is false, it calls template.New("").ParseFS(fsys, fpath).
//
// If deadlock.Debug is true, fsys is ignored and it returns a TemplateReloader
// that loads the templates using ParseGlob(relpath/fpath).
func New(fsys fs.FS, fpath, relpath string) (jtl jaws.TemplateLookuper, err error) <span class="cov8" title="1">{
        return create(deadlock.Debug, fsys, fpath, relpath)
}</span>

func create(debug bool, fsys fs.FS, fpath, relpath string) (tl jaws.TemplateLookuper, err error) <span class="cov8" title="1">{
        if !debug </span><span class="cov8" title="1">{
                return template.New("").ParseFS(fsys, fpath)
        }</span>
        <span class="cov8" title="1">var tmpl *template.Template
        fpath = path.Join(relpath, fpath)
        if tmpl, err = template.New("").ParseGlob(fpath); err == nil </span><span class="cov8" title="1">{
                tl = &amp;TemplateReloader{
                        Path: fpath,
                        when: time.Now(),
                        curr: tmpl,
                }
        }</span>
        <span class="cov8" title="1">return</span>
}

func (tr *TemplateReloader) Lookup(name string) *template.Template <span class="cov8" title="1">{
        tr.mu.RLock()
        tl := tr.curr
        d := time.Since(tr.when)
        tr.mu.RUnlock()
        if d &gt; time.Second </span><span class="cov8" title="1">{
                tr.mu.Lock()
                defer tr.mu.Unlock()
                tr.curr = template.Must(template.New("").ParseGlob(tr.Path))
                tr.when = tr.when.Add(d)
                tl = tr.curr
        }</span>
        <span class="cov8" title="1">return tl.Lookup(name)</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">package what

import "strings"

//go:generate go run golang.org/x/tools/cmd/stringer@latest -type=What
type What uint8

const (
        invalid What = iota

        // Commands not associated with an Element
        Update   // Used for update scheduling
        Reload   // Tells browser to reload the current URL
        Redirect // Tells browser to load another URL
        Alert    // Display (if using Bootstrap) an alert message
        Order    // Re-order a set of elements
        Call     // Call javascript function
        Set      // Set javascript variable (JSON path + tab char + JSON data)

        separator

        // Element manipulation
        Inner   // Set the elements inner HTML
        Delete  // Delete the element
        Replace // Replace the element with new HTML
        Remove  // Remove child element
        Insert  // Insert child element
        Append  // Append child element
        SAttr   // Set element attribute
        RAttr   // Remove element attribute
        SClass  // Set element class
        RClass  // Remove element class
        Value   // Set element value
        // Element input events
        Input
        Click
        // Testing
        Hook // Calls event handler synchronously
)

func (w What) IsCommand() bool <span class="cov8" title="1">{
        return w &lt; separator &amp;&amp; w.IsValid()
}</span>

func (w What) IsValid() bool <span class="cov8" title="1">{
        return w != invalid &amp;&amp; w != separator
}</span>

func Parse(s string) What <span class="cov8" title="1">{
        if s == "" </span><span class="cov8" title="1">{
                return Update
        }</span>
        <span class="cov8" title="1">for i := 0; i &lt; len(_What_index)-1; i++ </span><span class="cov8" title="1">{
                if s == _What_name[_What_index[i]:_What_index[i+1]] </span><span class="cov8" title="1">{
                        return What(i) // #nosec G115
                }</span>
        }
        <span class="cov8" title="1">for i := 0; i &lt; len(_What_index)-1; i++ </span><span class="cov8" title="1">{
                if strings.EqualFold(s, _What_name[_What_index[i]:_What_index[i+1]]) </span><span class="cov8" title="1">{
                        return What(i) // #nosec G115
                }</span>
        }
        <span class="cov8" title="1">return invalid</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">// Code generated by "stringer -type=What"; DO NOT EDIT.

package what

import "strconv"

func _() {
        // An "invalid array index" compiler error signifies that the constant values have changed.
        // Re-run the stringer command to generate them again.
        var x [1]struct{}
        _ = x[invalid-0]
        _ = x[Update-1]
        _ = x[Reload-2]
        _ = x[Redirect-3]
        _ = x[Alert-4]
        _ = x[Order-5]
        _ = x[Call-6]
        _ = x[Set-7]
        _ = x[separator-8]
        _ = x[Inner-9]
        _ = x[Delete-10]
        _ = x[Replace-11]
        _ = x[Remove-12]
        _ = x[Insert-13]
        _ = x[Append-14]
        _ = x[SAttr-15]
        _ = x[RAttr-16]
        _ = x[SClass-17]
        _ = x[RClass-18]
        _ = x[Value-19]
        _ = x[Input-20]
        _ = x[Click-21]
        _ = x[Hook-22]
}

const _What_name = "invalidUpdateReloadRedirectAlertOrderCallSetseparatorInnerDeleteReplaceRemoveInsertAppendSAttrRAttrSClassRClassValueInputClickHook"

var _What_index = [...]uint8{0, 7, 13, 19, 27, 32, 37, 41, 44, 53, 58, 64, 71, 77, 83, 89, 94, 99, 105, 111, 116, 121, 126, 130}

func (i What) String() string <span class="cov8" title="1">{
        if i &gt;= What(len(_What_index)-1) </span><span class="cov8" title="1">{
                return "What(" + strconv.FormatInt(int64(i), 10) + ")"
        }</span>
        <span class="cov8" title="1">return _What_name[_What_index[i]:_What_index[i+1]]</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
